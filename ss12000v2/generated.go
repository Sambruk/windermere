// Package ss12000v2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version (devel) DO NOT EDIT.
package ss12000v2

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for AbsenceEnum.
const (
	AnmäldFrånvaro   AbsenceEnum = "Anmäld frånvaro"
	BeviljadLedighet AbsenceEnum = "Beviljad ledighet"
)

// Defines values for AbsenceRegisteredBySecurityMarking.
const (
	AbsenceRegisteredBySecurityMarkingIngen                AbsenceRegisteredBySecurityMarking = "Ingen"
	AbsenceRegisteredBySecurityMarkingSekretessmarkering   AbsenceRegisteredBySecurityMarking = "Sekretessmarkering"
	AbsenceRegisteredBySecurityMarkingSkyddadFolkbokföring AbsenceRegisteredBySecurityMarking = "Skyddad folkbokföring"
)

// Defines values for ActivityActivityType.
const (
	ActivityActivityTypeElevaktivitet  ActivityActivityType = "Elevaktivitet"
	ActivityActivityTypeLäraraktivitet ActivityActivityType = "Läraraktivitet"
	ActivityActivityTypeProvaktivitet  ActivityActivityType = "Provaktivitet"
	ActivityActivityTypeUndervisning   ActivityActivityType = "Undervisning"
	ActivityActivityTypeÖvrigt         ActivityActivityType = "Övrigt"
)

// Defines values for ActivityExpandedActivityType.
const (
	ActivityExpandedActivityTypeElevaktivitet  ActivityExpandedActivityType = "Elevaktivitet"
	ActivityExpandedActivityTypeLäraraktivitet ActivityExpandedActivityType = "Läraraktivitet"
	ActivityExpandedActivityTypeProvaktivitet  ActivityExpandedActivityType = "Provaktivitet"
	ActivityExpandedActivityTypeUndervisning   ActivityExpandedActivityType = "Undervisning"
	ActivityExpandedActivityTypeÖvrigt         ActivityExpandedActivityType = "Övrigt"
)

// Defines values for AggregatedAttendanceStudentSecurityMarking.
const (
	AggregatedAttendanceStudentSecurityMarkingIngen                AggregatedAttendanceStudentSecurityMarking = "Ingen"
	AggregatedAttendanceStudentSecurityMarkingSekretessmarkering   AggregatedAttendanceStudentSecurityMarking = "Sekretessmarkering"
	AggregatedAttendanceStudentSecurityMarkingSkyddadFolkbokföring AggregatedAttendanceStudentSecurityMarking = "Skyddad folkbokföring"
)

// Defines values for AssignmentRoleTypeEnum.
const (
	AssignmentRoleTypeEnumAdministrativPersonal AssignmentRoleTypeEnum = "Administrativ personal"
	AssignmentRoleTypeEnumBarnskötare           AssignmentRoleTypeEnum = "Barnskötare"
	AssignmentRoleTypeEnumElevhälsopersonal     AssignmentRoleTypeEnum = "Elevhälsopersonal"
	AssignmentRoleTypeEnumFritidspedagog        AssignmentRoleTypeEnum = "Fritidspedagog"
	AssignmentRoleTypeEnumFörskollärare         AssignmentRoleTypeEnum = "Förskollärare"
	AssignmentRoleTypeEnumLärarassistent        AssignmentRoleTypeEnum = "Lärarassistent"
	AssignmentRoleTypeEnumMentor                AssignmentRoleTypeEnum = "Mentor"
	AssignmentRoleTypeEnumPedagogiskLedare      AssignmentRoleTypeEnum = "Pedagogisk ledare"
	AssignmentRoleTypeEnumSchemaläggare         AssignmentRoleTypeEnum = "Schemaläggare"
	AssignmentRoleTypeEnumSpecialpedagog        AssignmentRoleTypeEnum = "Specialpedagog"
)

// Defines values for AttendanceEventEventType.
const (
	In AttendanceEventEventType = "In"
	Ut AttendanceEventEventType = "Ut"
)

// Defines values for AttendanceEventPersonSecurityMarking.
const (
	AttendanceEventPersonSecurityMarkingIngen                AttendanceEventPersonSecurityMarking = "Ingen"
	AttendanceEventPersonSecurityMarkingSekretessmarkering   AttendanceEventPersonSecurityMarking = "Sekretessmarkering"
	AttendanceEventPersonSecurityMarkingSkyddadFolkbokföring AttendanceEventPersonSecurityMarking = "Skyddad folkbokföring"
)

// Defines values for AttendanceEventRegisteredBySecurityMarking.
const (
	AttendanceEventRegisteredBySecurityMarkingIngen                AttendanceEventRegisteredBySecurityMarking = "Ingen"
	AttendanceEventRegisteredBySecurityMarkingSekretessmarkering   AttendanceEventRegisteredBySecurityMarking = "Sekretessmarkering"
	AttendanceEventRegisteredBySecurityMarkingSkyddadFolkbokföring AttendanceEventRegisteredBySecurityMarking = "Skyddad folkbokföring"
)

// Defines values for AttendanceScheduleEntryDayOfWeek.
const (
	Fredag  AttendanceScheduleEntryDayOfWeek = "Fredag"
	Lördag  AttendanceScheduleEntryDayOfWeek = "Lördag"
	Måndag  AttendanceScheduleEntryDayOfWeek = "Måndag"
	Onsdag  AttendanceScheduleEntryDayOfWeek = "Onsdag"
	Söndag  AttendanceScheduleEntryDayOfWeek = "Söndag"
	Tisdag  AttendanceScheduleEntryDayOfWeek = "Tisdag"
	Torsdag AttendanceScheduleEntryDayOfWeek = "Torsdag"
)

// Defines values for AttendanceScheduleStateState.
const (
	Begärt  AttendanceScheduleStateState = "Begärt"
	Godkänt AttendanceScheduleStateState = "Godkänt"
	Nekat   AttendanceScheduleStateState = "Nekat"
)

// Defines values for AttendanceScheduleStateRegisteredBySecurityMarking.
const (
	AttendanceScheduleStateRegisteredBySecurityMarkingIngen                AttendanceScheduleStateRegisteredBySecurityMarking = "Ingen"
	AttendanceScheduleStateRegisteredBySecurityMarkingSekretessmarkering   AttendanceScheduleStateRegisteredBySecurityMarking = "Sekretessmarkering"
	AttendanceScheduleStateRegisteredBySecurityMarkingSkyddadFolkbokföring AttendanceScheduleStateRegisteredBySecurityMarking = "Skyddad folkbokföring"
)

// Defines values for AttendanceReporterSecurityMarking.
const (
	AttendanceReporterSecurityMarkingIngen                AttendanceReporterSecurityMarking = "Ingen"
	AttendanceReporterSecurityMarkingSekretessmarkering   AttendanceReporterSecurityMarking = "Sekretessmarkering"
	AttendanceReporterSecurityMarkingSkyddadFolkbokföring AttendanceReporterSecurityMarking = "Skyddad folkbokföring"
)

// Defines values for AttendanceStudentSecurityMarking.
const (
	AttendanceStudentSecurityMarkingIngen                AttendanceStudentSecurityMarking = "Ingen"
	AttendanceStudentSecurityMarkingSekretessmarkering   AttendanceStudentSecurityMarking = "Sekretessmarkering"
	AttendanceStudentSecurityMarkingSkyddadFolkbokföring AttendanceStudentSecurityMarking = "Skyddad folkbokföring"
)

// Defines values for ContactInfoInfoType.
const (
	Publik  ContactInfoInfoType = "Publik"
	Support ContactInfoInfoType = "Support"
)

// Defines values for CurriculumEnum.
const (
	GR2000    CurriculumEnum = "GR2000"
	GR2011    CurriculumEnum = "GR2011"
	GRSÄR2011 CurriculumEnum = "GRSÄR2011"
	GY2000    CurriculumEnum = "GY2000"
	GY2011    CurriculumEnum = "GY2011"
	GYSÄR2000 CurriculumEnum = "GYSÄR2000"
	GYSÄR2013 CurriculumEnum = "GYSÄR2013"
	GYVUX2000 CurriculumEnum = "GYVUX2000"
	GYVUX2001 CurriculumEnum = "GYVUX2001"
	GYVUX2002 CurriculumEnum = "GYVUX2002"
	Lgr80     CurriculumEnum = "Lgr80"
	Lgy70     CurriculumEnum = "Lgy70"
	Lpf94     CurriculumEnum = "Lpf94"
	Lpfö98    CurriculumEnum = "Lpfö98"
	Lpo94     CurriculumEnum = "Lpo94"
	Lvux12    CurriculumEnum = "Lvux12"
	SAM2011   CurriculumEnum = "SAM2011"
	SPEC2011  CurriculumEnum = "SPEC2011"
	VU2013    CurriculumEnum = "VU2013"
)

// Defines values for DutyDutyRole.
const (
	DutyDutyRoleAnnanPersonal               DutyDutyRole = "Annan personal"
	DutyDutyRoleBarnskötare                 DutyDutyRole = "Barnskötare"
	DutyDutyRoleBibliotekarie               DutyDutyRole = "Bibliotekarie"
	DutyDutyRoleFritidspedagog              DutyDutyRole = "Fritidspedagog"
	DutyDutyRoleFörskolechef                DutyDutyRole = "Förskolechef"
	DutyDutyRoleFörskollärare               DutyDutyRole = "Förskollärare"
	DutyDutyRoleFörstelärare                DutyDutyRole = "Förstelärare"
	DutyDutyRoleKurator                     DutyDutyRole = "Kurator"
	DutyDutyRoleLärarassistent              DutyDutyRole = "Lärarassistent"
	DutyDutyRoleLärare                      DutyDutyRole = "Lärare"
	DutyDutyRoleRektor                      DutyDutyRole = "Rektor"
	DutyDutyRoleSkoladministratör           DutyDutyRole = "Skoladministratör"
	DutyDutyRoleSkolläkare                  DutyDutyRole = "Skolläkare"
	DutyDutyRoleSkolpsykolog                DutyDutyRole = "Skolpsykolog"
	DutyDutyRoleSkolsköterska               DutyDutyRole = "Skolsköterska"
	DutyDutyRoleSpeciallärarespecialpedagog DutyDutyRole = "Speciallärare/specialpedagog"
	DutyDutyRoleStudieOchYrkesvägledare     DutyDutyRole = "Studie- och yrkesvägledare"
	DutyDutyRoleÖvrigArbetsledning          DutyDutyRole = "Övrig arbetsledning"
	DutyDutyRoleÖvrigPedagogiskPersonal     DutyDutyRole = "Övrig pedagogisk personal"
)

// Defines values for DutyExpandedDutyRole.
const (
	DutyExpandedDutyRoleAnnanPersonal               DutyExpandedDutyRole = "Annan personal"
	DutyExpandedDutyRoleBarnskötare                 DutyExpandedDutyRole = "Barnskötare"
	DutyExpandedDutyRoleBibliotekarie               DutyExpandedDutyRole = "Bibliotekarie"
	DutyExpandedDutyRoleFritidspedagog              DutyExpandedDutyRole = "Fritidspedagog"
	DutyExpandedDutyRoleFörskolechef                DutyExpandedDutyRole = "Förskolechef"
	DutyExpandedDutyRoleFörskollärare               DutyExpandedDutyRole = "Förskollärare"
	DutyExpandedDutyRoleFörstelärare                DutyExpandedDutyRole = "Förstelärare"
	DutyExpandedDutyRoleKurator                     DutyExpandedDutyRole = "Kurator"
	DutyExpandedDutyRoleLärarassistent              DutyExpandedDutyRole = "Lärarassistent"
	DutyExpandedDutyRoleLärare                      DutyExpandedDutyRole = "Lärare"
	DutyExpandedDutyRoleRektor                      DutyExpandedDutyRole = "Rektor"
	DutyExpandedDutyRoleSkoladministratör           DutyExpandedDutyRole = "Skoladministratör"
	DutyExpandedDutyRoleSkolläkare                  DutyExpandedDutyRole = "Skolläkare"
	DutyExpandedDutyRoleSkolpsykolog                DutyExpandedDutyRole = "Skolpsykolog"
	DutyExpandedDutyRoleSkolsköterska               DutyExpandedDutyRole = "Skolsköterska"
	DutyExpandedDutyRoleSpeciallärarespecialpedagog DutyExpandedDutyRole = "Speciallärare/specialpedagog"
	DutyExpandedDutyRoleStudieOchYrkesvägledare     DutyExpandedDutyRole = "Studie- och yrkesvägledare"
	DutyExpandedDutyRoleÖvrigArbetsledning          DutyExpandedDutyRole = "Övrig arbetsledning"
	DutyExpandedDutyRoleÖvrigPedagogiskPersonal     DutyExpandedDutyRole = "Övrig pedagogisk personal"
)

// Defines values for DutyRole.
const (
	DutyRoleAnnanPersonal               DutyRole = "Annan personal"
	DutyRoleBarnskötare                 DutyRole = "Barnskötare"
	DutyRoleBibliotekarie               DutyRole = "Bibliotekarie"
	DutyRoleFritidspedagog              DutyRole = "Fritidspedagog"
	DutyRoleFörskolechef                DutyRole = "Förskolechef"
	DutyRoleFörskollärare               DutyRole = "Förskollärare"
	DutyRoleFörstelärare                DutyRole = "Förstelärare"
	DutyRoleKurator                     DutyRole = "Kurator"
	DutyRoleLärarassistent              DutyRole = "Lärarassistent"
	DutyRoleLärare                      DutyRole = "Lärare"
	DutyRoleRektor                      DutyRole = "Rektor"
	DutyRoleSkoladministratör           DutyRole = "Skoladministratör"
	DutyRoleSkolläkare                  DutyRole = "Skolläkare"
	DutyRoleSkolpsykolog                DutyRole = "Skolpsykolog"
	DutyRoleSkolsköterska               DutyRole = "Skolsköterska"
	DutyRoleSpeciallärarespecialpedagog DutyRole = "Speciallärare/specialpedagog"
	DutyRoleStudieOchYrkesvägledare     DutyRole = "Studie- och yrkesvägledare"
	DutyRoleÖvrigArbetsledning          DutyRole = "Övrig arbetsledning"
	DutyRoleÖvrigPedagogiskPersonal     DutyRole = "Övrig pedagogisk personal"
)

// Defines values for DutyPersonSecurityMarking.
const (
	DutyPersonSecurityMarkingIngen                DutyPersonSecurityMarking = "Ingen"
	DutyPersonSecurityMarkingSekretessmarkering   DutyPersonSecurityMarking = "Sekretessmarkering"
	DutyPersonSecurityMarkingSkyddadFolkbokföring DutyPersonSecurityMarking = "Skyddad folkbokföring"
)

// Defines values for EmailType.
const (
	ArbeteÖvrigt  EmailType = "Arbete övrigt"
	Privat        EmailType = "Privat"
	SkolaElev     EmailType = "Skola elev"
	SkolaPersonal EmailType = "Skola personal"
)

// Defines values for EndPointsEnum.
const (
	EndPointsEnumAbsence            EndPointsEnum = "Absence"
	EndPointsEnumActivity           EndPointsEnum = "Activity"
	EndPointsEnumAttendance         EndPointsEnum = "Attendance"
	EndPointsEnumAttendanceEvent    EndPointsEnum = "AttendanceEvent"
	EndPointsEnumAttendanceSchedule EndPointsEnum = "AttendanceSchedule"
	EndPointsEnumCalendarEvent      EndPointsEnum = "CalendarEvent"
	EndPointsEnumDuty               EndPointsEnum = "Duty"
	EndPointsEnumGrade              EndPointsEnum = "Grade"
	EndPointsEnumGroup              EndPointsEnum = "Group"
	EndPointsEnumOrganisation       EndPointsEnum = "Organisation"
	EndPointsEnumPerson             EndPointsEnum = "Person"
	EndPointsEnumPlacement          EndPointsEnum = "Placement"
	EndPointsEnumProgramme          EndPointsEnum = "Programme"
	EndPointsEnumResource           EndPointsEnum = "Resource"
	EndPointsEnumRoom               EndPointsEnum = "Room"
	EndPointsEnumSchoolUnitOffering EndPointsEnum = "SchoolUnitOffering"
	EndPointsEnumStudyPlan          EndPointsEnum = "StudyPlan"
	EndPointsEnumSyllabus           EndPointsEnum = "Syllabus"
)

// Defines values for GradeCorrectionType.
const (
	Rättelse GradeCorrectionType = "Rättelse"
	Ändring  GradeCorrectionType = "Ändring"
)

// Defines values for GradeSemester.
const (
	HT GradeSemester = "HT"
	VT GradeSemester = "VT"
)

// Defines values for GradeGradingTeacherSecurityMarking.
const (
	GradeGradingTeacherSecurityMarkingIngen                GradeGradingTeacherSecurityMarking = "Ingen"
	GradeGradingTeacherSecurityMarkingSekretessmarkering   GradeGradingTeacherSecurityMarking = "Sekretessmarkering"
	GradeGradingTeacherSecurityMarkingSkyddadFolkbokföring GradeGradingTeacherSecurityMarking = "Skyddad folkbokföring"
)

// Defines values for GradeRegisteredBySecurityMarking.
const (
	GradeRegisteredBySecurityMarkingIngen                GradeRegisteredBySecurityMarking = "Ingen"
	GradeRegisteredBySecurityMarkingSekretessmarkering   GradeRegisteredBySecurityMarking = "Sekretessmarkering"
	GradeRegisteredBySecurityMarkingSkyddadFolkbokföring GradeRegisteredBySecurityMarking = "Skyddad folkbokföring"
)

// Defines values for GroupTypesEnum.
const (
	GroupTypesEnumAvdelning     GroupTypesEnum = "Avdelning"
	GroupTypesEnumKlass         GroupTypesEnum = "Klass"
	GroupTypesEnumMentor        GroupTypesEnum = "Mentor"
	GroupTypesEnumPersonalgrupp GroupTypesEnum = "Personalgrupp"
	GroupTypesEnumProvgrupp     GroupTypesEnum = "Provgrupp"
	GroupTypesEnumSchema        GroupTypesEnum = "Schema"
	GroupTypesEnumUndervisning  GroupTypesEnum = "Undervisning"
	GroupTypesEnumÖvrigt        GroupTypesEnum = "Övrigt"
)

// Defines values for LogEntrySeverityLevel.
const (
	LogEntrySeverityLevelError   LogEntrySeverityLevel = "Error"
	LogEntrySeverityLevelInfo    LogEntrySeverityLevel = "Info"
	LogEntrySeverityLevelWarning LogEntrySeverityLevel = "Warning"
)

// Defines values for OrganisationTypeEnum.
const (
	OrganisationTypeEnumBolag             OrganisationTypeEnum = "Bolag"
	OrganisationTypeEnumFörvaltning       OrganisationTypeEnum = "Förvaltning"
	OrganisationTypeEnumHuvudman          OrganisationTypeEnum = "Huvudman"
	OrganisationTypeEnumRektorsområde     OrganisationTypeEnum = "Rektorsområde"
	OrganisationTypeEnumSkola             OrganisationTypeEnum = "Skola"
	OrganisationTypeEnumSkolenhet         OrganisationTypeEnum = "Skolenhet"
	OrganisationTypeEnumVarumärke         OrganisationTypeEnum = "Varumärke"
	OrganisationTypeEnumVerksamhetsområde OrganisationTypeEnum = "Verksamhetsområde"
	OrganisationTypeEnumÖvrigt            OrganisationTypeEnum = "Övrigt"
)

// Defines values for OrganisationAddressType.
const (
	OrganisationAddressTypeBesöksadress   OrganisationAddressType = "Besöksadress"
	OrganisationAddressTypeFakturaadress  OrganisationAddressType = "Fakturaadress"
	OrganisationAddressTypeLeveransadress OrganisationAddressType = "Leveransadress"
	OrganisationAddressTypePostadress     OrganisationAddressType = "Postadress"
)

// Defines values for PersonPersonStatus.
const (
	PersonPersonStatusAktiv     PersonPersonStatus = "Aktiv"
	PersonPersonStatusAvliden   PersonPersonStatus = "Avliden"
	PersonPersonStatusUtvandrad PersonPersonStatus = "Utvandrad"
)

// Defines values for PersonSecurityMarking.
const (
	PersonSecurityMarkingIngen                PersonSecurityMarking = "Ingen"
	PersonSecurityMarkingSekretessmarkering   PersonSecurityMarking = "Sekretessmarkering"
	PersonSecurityMarkingSkyddadFolkbokföring PersonSecurityMarking = "Skyddad folkbokföring"
)

// Defines values for PersonSex.
const (
	PersonSexKvinna PersonSex = "Kvinna"
	PersonSexMan    PersonSex = "Man"
	PersonSexOkänt  PersonSex = "Okänt"
)

// Defines values for PersonExpandedPersonStatus.
const (
	PersonExpandedPersonStatusAktiv     PersonExpandedPersonStatus = "Aktiv"
	PersonExpandedPersonStatusAvliden   PersonExpandedPersonStatus = "Avliden"
	PersonExpandedPersonStatusUtvandrad PersonExpandedPersonStatus = "Utvandrad"
)

// Defines values for PersonExpandedSecurityMarking.
const (
	PersonExpandedSecurityMarkingIngen                PersonExpandedSecurityMarking = "Ingen"
	PersonExpandedSecurityMarkingSekretessmarkering   PersonExpandedSecurityMarking = "Sekretessmarkering"
	PersonExpandedSecurityMarkingSkyddadFolkbokföring PersonExpandedSecurityMarking = "Skyddad folkbokföring"
)

// Defines values for PersonExpandedSex.
const (
	PersonExpandedSexKvinna PersonExpandedSex = "Kvinna"
	PersonExpandedSexMan    PersonExpandedSex = "Man"
	PersonExpandedSexOkänt  PersonExpandedSex = "Okänt"
)

// Defines values for PersonReferenceSecurityMarking.
const (
	PersonReferenceSecurityMarkingIngen                PersonReferenceSecurityMarking = "Ingen"
	PersonReferenceSecurityMarkingSekretessmarkering   PersonReferenceSecurityMarking = "Sekretessmarkering"
	PersonReferenceSecurityMarkingSkyddadFolkbokföring PersonReferenceSecurityMarking = "Skyddad folkbokföring"
)

// Defines values for PersonReference1SecurityMarking.
const (
	PersonReference1SecurityMarkingIngen                PersonReference1SecurityMarking = "Ingen"
	PersonReference1SecurityMarkingSekretessmarkering   PersonReference1SecurityMarking = "Sekretessmarkering"
	PersonReference1SecurityMarkingSkyddadFolkbokföring PersonReference1SecurityMarking = "Skyddad folkbokföring"
)

// Defines values for PersonAddressesInnerType.
const (
	PersonAddressesInnerTypeFolkbokföring      PersonAddressesInnerType = "Folkbokföring"
	PersonAddressesInnerTypePostadress         PersonAddressesInnerType = "Postadress"
	PersonAddressesInnerTypeSärskildPostadress PersonAddressesInnerType = "Särskild postadress"
	PersonAddressesInnerTypeTillfälligAdress   PersonAddressesInnerType = "Tillfällig adress"
)

// Defines values for PhonenumberType.
const (
	Arbete PhonenumberType = "Arbete"
	Hem    PhonenumberType = "Hem"
)

// Defines values for PlacementReason.
const (
	PlacementReasonEgetBehov    PlacementReason = "Eget behov"
	PlacementReasonErbjudenTid  PlacementReason = "Erbjuden tid"
	PlacementReasonOmsorgsbehov PlacementReason = "Omsorgsbehov"
)

// Defines values for PlacementSchoolType.
const (
	PlacementSchoolTypeFS     PlacementSchoolType = "FS"
	PlacementSchoolTypeFTH    PlacementSchoolType = "FTH"
	PlacementSchoolTypeOPPFTH PlacementSchoolType = "OPPFTH"
)

// Defines values for PlacementExpandedReason.
const (
	PlacementExpandedReasonEgetBehov    PlacementExpandedReason = "Eget behov"
	PlacementExpandedReasonErbjudenTid  PlacementExpandedReason = "Erbjuden tid"
	PlacementExpandedReasonOmsorgsbehov PlacementExpandedReason = "Omsorgsbehov"
)

// Defines values for PlacementExpandedSchoolType.
const (
	PlacementExpandedSchoolTypeFS     PlacementExpandedSchoolType = "FS"
	PlacementExpandedSchoolTypeFTH    PlacementExpandedSchoolType = "FTH"
	PlacementExpandedSchoolTypeOPPFTH PlacementExpandedSchoolType = "OPPFTH"
)

// Defines values for PlacementChildSecurityMarking.
const (
	PlacementChildSecurityMarkingIngen                PlacementChildSecurityMarking = "Ingen"
	PlacementChildSecurityMarkingSekretessmarkering   PlacementChildSecurityMarking = "Sekretessmarkering"
	PlacementChildSecurityMarkingSkyddadFolkbokföring PlacementChildSecurityMarking = "Skyddad folkbokföring"
)

// Defines values for ProgrammeType.
const (
	FjärdeTeknisktÅr            ProgrammeType = "Fjärde tekniskt år"
	HögskoleförberedandeProgram ProgrammeType = "Högskoleförberedande program"
	Intruduktionsprogram        ProgrammeType = "Intruduktionsprogram"
	NationelltYrkespaket        ProgrammeType = "Nationellt yrkespaket"
	Programinriktning           ProgrammeType = "Programinriktning"
	RegionaltYrkespaket         ProgrammeType = "Regionalt yrkespaket"
	Utgång                      ProgrammeType = "Utgång"
	Yrkesprogram                ProgrammeType = "Yrkesprogram"
)

// Defines values for ProgrammeContentInnerType.
const (
	ProgrammeContentInnerTypeGymnasiearbete     ProgrammeContentInnerType = "Gymnasiearbete"
	ProgrammeContentInnerTypeGymnasiegemensamma ProgrammeContentInnerType = "Gymnasiegemensamma"
	ProgrammeContentInnerTypeIndividuelltVal    ProgrammeContentInnerType = "Individuellt val"
	ProgrammeContentInnerTypeInriktning         ProgrammeContentInnerType = "Inriktning"
	ProgrammeContentInnerTypeProgramfördjupning ProgrammeContentInnerType = "Programfördjupning"
	ProgrammeContentInnerTypeProgramgemensamma  ProgrammeContentInnerType = "Programgemensamma"
)

// Defines values for RelationTypesEnum.
const (
	AnnanAnsvarig  RelationTypesEnum = "Annan ansvarig"
	GodMan         RelationTypesEnum = "God man"
	UtseddBehörig  RelationTypesEnum = "Utsedd behörig"
	Vårdnadshavare RelationTypesEnum = "Vårdnadshavare"
)

// Defines values for SchoolTypesEnum.
const (
	ABU      SchoolTypesEnum = "ABU"
	AU       SchoolTypesEnum = "AU"
	FHS      SchoolTypesEnum = "FHS"
	FKLASS   SchoolTypesEnum = "FKLASS"
	FS       SchoolTypesEnum = "FS"
	FTH      SchoolTypesEnum = "FTH"
	GR       SchoolTypesEnum = "GR"
	GRS      SchoolTypesEnum = "GRS"
	GY       SchoolTypesEnum = "GY"
	GYS      SchoolTypesEnum = "GYS"
	HS       SchoolTypesEnum = "HS"
	KKU      SchoolTypesEnum = "KKU"
	KU       SchoolTypesEnum = "KU"
	OPPFTH   SchoolTypesEnum = "OPPFTH"
	SAM      SchoolTypesEnum = "SAM"
	SARVUX   SchoolTypesEnum = "SARVUX"
	SARVUXGR SchoolTypesEnum = "SARVUXGR"
	SARVUXGY SchoolTypesEnum = "SARVUXGY"
	SFI      SchoolTypesEnum = "SFI"
	SP       SchoolTypesEnum = "SP"
	STF      SchoolTypesEnum = "STF"
	TR       SchoolTypesEnum = "TR"
	VUX      SchoolTypesEnum = "VUX"
	VUXGR    SchoolTypesEnum = "VUXGR"
	VUXGY    SchoolTypesEnum = "VUXGY"
	VUXSARGR SchoolTypesEnum = "VUXSARGR"
	VUXSARGY SchoolTypesEnum = "VUXSARGY"
	VUXSARTR SchoolTypesEnum = "VUXSARTR"
	VUXSFI   SchoolTypesEnum = "VUXSFI"
	YH       SchoolTypesEnum = "YH"
)

// Defines values for StudyPlanContentType.
const (
	StudyPlanContentTypeBorttagna          StudyPlanContentType = "Borttagna"
	StudyPlanContentTypeGymnasiearbete     StudyPlanContentType = "Gymnasiearbete"
	StudyPlanContentTypeGymnasiegemensamma StudyPlanContentType = "Gymnasiegemensamma"
	StudyPlanContentTypeIndividuelltVal    StudyPlanContentType = "Individuellt val"
	StudyPlanContentTypeInriktning         StudyPlanContentType = "Inriktning"
	StudyPlanContentTypeProgramfördjupning StudyPlanContentType = "Programfördjupning"
	StudyPlanContentTypeProgramgemensamma  StudyPlanContentType = "Programgemensamma"
	StudyPlanContentTypeUtökade            StudyPlanContentType = "Utökade"
)

// Defines values for StudyPlanNotesType.
const (
	AndraInsatserSomÄrGynnsammaFörElevensKunskapsutveckling StudyPlanNotesType = "Andra insatser som är gynnsamma för elevens kunskapsutveckling"
	Anteckningar                                            StudyPlanNotesType = "Anteckningar"
	ElevensMålMedStudierna                                  StudyPlanNotesType = "Elevens mål med studierna"
	ElevensTidigareArbetslivserfarenhetOchStudier           StudyPlanNotesType = "Elevens tidigare arbetslivserfarenhet och studier"
	ValideringAvKunskaperOchKompetenser                     StudyPlanNotesType = "Validering av kunskaper och kompetenser"
)

// Defines values for StudyPlanStudentSecurityMarking.
const (
	StudyPlanStudentSecurityMarkingIngen                StudyPlanStudentSecurityMarking = "Ingen"
	StudyPlanStudentSecurityMarkingSekretessmarkering   StudyPlanStudentSecurityMarking = "Sekretessmarkering"
	StudyPlanStudentSecurityMarkingSkyddadFolkbokföring StudyPlanStudentSecurityMarking = "Skyddad folkbokföring"
)

// Defines values for GetAbsencesParamsSortkey.
const (
	GetAbsencesParamsSortkeyModifiedDesc  GetAbsencesParamsSortkey = "ModifiedDesc"
	GetAbsencesParamsSortkeyStartTimeAsc  GetAbsencesParamsSortkey = "StartTimeAsc"
	GetAbsencesParamsSortkeyStartTimeDesc GetAbsencesParamsSortkey = "StartTimeDesc"
)

// Defines values for GetActivitiesParamsExpand.
const (
	GetActivitiesParamsExpandGroups   GetActivitiesParamsExpand = "groups"
	GetActivitiesParamsExpandSyllabus GetActivitiesParamsExpand = "syllabus"
	GetActivitiesParamsExpandTeachers GetActivitiesParamsExpand = "teachers"
)

// Defines values for GetActivitiesParamsSortkey.
const (
	GetActivitiesParamsSortkeyDisplayNameAsc GetActivitiesParamsSortkey = "DisplayNameAsc"
	GetActivitiesParamsSortkeyModifiedDesc   GetActivitiesParamsSortkey = "ModifiedDesc"
)

// Defines values for PostActivitiesLookupParamsExpand.
const (
	PostActivitiesLookupParamsExpandGroups   PostActivitiesLookupParamsExpand = "groups"
	PostActivitiesLookupParamsExpandSyllabus PostActivitiesLookupParamsExpand = "syllabus"
	PostActivitiesLookupParamsExpandTeachers PostActivitiesLookupParamsExpand = "teachers"
)

// Defines values for GetActivitiesIdParamsExpand.
const (
	GetActivitiesIdParamsExpandGroups   GetActivitiesIdParamsExpand = "groups"
	GetActivitiesIdParamsExpandSyllabus GetActivitiesIdParamsExpand = "syllabus"
	GetActivitiesIdParamsExpandTeachers GetActivitiesIdParamsExpand = "teachers"
)

// Defines values for GetAggregatedAttendanceParamsExpand.
const (
	GetAggregatedAttendanceParamsExpandActivity GetAggregatedAttendanceParamsExpand = "activity"
	GetAggregatedAttendanceParamsExpandStudent  GetAggregatedAttendanceParamsExpand = "student"
)

// Defines values for GetAttendanceEventsParamsExpand.
const (
	GetAttendanceEventsParamsExpandGroup        GetAttendanceEventsParamsExpand = "group"
	GetAttendanceEventsParamsExpandPerson       GetAttendanceEventsParamsExpand = "person"
	GetAttendanceEventsParamsExpandRegisteredBy GetAttendanceEventsParamsExpand = "registeredBy"
)

// Defines values for PostAttendanceEventsLookupParamsExpand.
const (
	PostAttendanceEventsLookupParamsExpandGroup        PostAttendanceEventsLookupParamsExpand = "group"
	PostAttendanceEventsLookupParamsExpandPerson       PostAttendanceEventsLookupParamsExpand = "person"
	PostAttendanceEventsLookupParamsExpandRegisteredBy PostAttendanceEventsLookupParamsExpand = "registeredBy"
)

// Defines values for GetAttendanceEventsIdParamsExpand.
const (
	GetAttendanceEventsIdParamsExpandGroup        GetAttendanceEventsIdParamsExpand = "group"
	GetAttendanceEventsIdParamsExpandPerson       GetAttendanceEventsIdParamsExpand = "person"
	GetAttendanceEventsIdParamsExpandRegisteredBy GetAttendanceEventsIdParamsExpand = "registeredBy"
)

// Defines values for GetCalendarEventsParamsExpand.
const (
	GetCalendarEventsParamsExpandActivity   GetCalendarEventsParamsExpand = "activity"
	GetCalendarEventsParamsExpandAttendance GetCalendarEventsParamsExpand = "attendance"
)

// Defines values for GetCalendarEventsParamsSortkey.
const (
	GetCalendarEventsParamsSortkeyModifiedDesc  GetCalendarEventsParamsSortkey = "ModifiedDesc"
	GetCalendarEventsParamsSortkeyStartTimeAsc  GetCalendarEventsParamsSortkey = "StartTimeAsc"
	GetCalendarEventsParamsSortkeyStartTimeDesc GetCalendarEventsParamsSortkey = "StartTimeDesc"
)

// Defines values for GetCalendarEventsIdParamsExpand.
const (
	GetCalendarEventsIdParamsExpandActivity   GetCalendarEventsIdParamsExpand = "activity"
	GetCalendarEventsIdParamsExpandAttendance GetCalendarEventsIdParamsExpand = "attendance"
)

// Defines values for GetDutiesParamsExpand.
const (
	GetDutiesParamsExpandPerson GetDutiesParamsExpand = "person"
)

// Defines values for GetDutiesParamsSortkey.
const (
	GetDutiesParamsSortkeyModifiedDesc  GetDutiesParamsSortkey = "ModifiedDesc"
	GetDutiesParamsSortkeyStartDateAsc  GetDutiesParamsSortkey = "StartDateAsc"
	GetDutiesParamsSortkeyStartDateDesc GetDutiesParamsSortkey = "StartDateDesc"
)

// Defines values for PostDutiesLookupParamsExpand.
const (
	PostDutiesLookupParamsExpandPerson PostDutiesLookupParamsExpand = "person"
)

// Defines values for GetDutiesIdParamsExpand.
const (
	GetDutiesIdParamsExpandPerson GetDutiesIdParamsExpand = "person"
)

// Defines values for GetGradesParamsSortkey.
const (
	GetGradesParamsSortkeyModifiedDesc       GetGradesParamsSortkey = "ModifiedDesc"
	GetGradesParamsSortkeyRegisteredDateAsc  GetGradesParamsSortkey = "registeredDateAsc"
	GetGradesParamsSortkeyRegisteredDateDesc GetGradesParamsSortkey = "registeredDateDesc"
)

// Defines values for GetGroupsParamsExpand.
const (
	GetGroupsParamsExpandAssignmentRoles GetGroupsParamsExpand = "assignmentRoles"
)

// Defines values for GetGroupsParamsSortkey.
const (
	GetGroupsParamsSortkeyDisplayNameAsc GetGroupsParamsSortkey = "DisplayNameAsc"
	GetGroupsParamsSortkeyEndDateAsc     GetGroupsParamsSortkey = "EndDateAsc"
	GetGroupsParamsSortkeyEndDateDesc    GetGroupsParamsSortkey = "EndDateDesc"
	GetGroupsParamsSortkeyModifiedDesc   GetGroupsParamsSortkey = "ModifiedDesc"
	GetGroupsParamsSortkeyStartDateAsc   GetGroupsParamsSortkey = "StartDateAsc"
	GetGroupsParamsSortkeyStartDateDesc  GetGroupsParamsSortkey = "StartDateDesc"
)

// Defines values for PostGroupsLookupParamsExpand.
const (
	PostGroupsLookupParamsExpandAssignmentRoles PostGroupsLookupParamsExpand = "assignmentRoles"
)

// Defines values for GetGroupsIdParamsExpand.
const (
	AssignmentRoles GetGroupsIdParamsExpand = "assignmentRoles"
)

// Defines values for GetOrganisationsParamsSortkey.
const (
	GetOrganisationsParamsSortkeyDisplayNameAsc GetOrganisationsParamsSortkey = "DisplayNameAsc"
	GetOrganisationsParamsSortkeyModifiedDesc   GetOrganisationsParamsSortkey = "ModifiedDesc"
)

// Defines values for GetPersonsParamsRelationshipEntityType.
const (
	GetPersonsParamsRelationshipEntityTypeDuty                    GetPersonsParamsRelationshipEntityType = "duty"
	GetPersonsParamsRelationshipEntityTypeEnrolment               GetPersonsParamsRelationshipEntityType = "enrolment"
	GetPersonsParamsRelationshipEntityTypeGroupMembership         GetPersonsParamsRelationshipEntityType = "groupMembership"
	GetPersonsParamsRelationshipEntityTypePlacementChild          GetPersonsParamsRelationshipEntityType = "placement.child"
	GetPersonsParamsRelationshipEntityTypePlacementOwner          GetPersonsParamsRelationshipEntityType = "placement.owner"
	GetPersonsParamsRelationshipEntityTypeResponsibleForEnrolment GetPersonsParamsRelationshipEntityType = "responsibleFor.enrolment"
	GetPersonsParamsRelationshipEntityTypeResponsibleForPlacement GetPersonsParamsRelationshipEntityType = "responsibleFor.placement"
)

// Defines values for GetPersonsParamsExpand.
const (
	GetPersonsParamsExpandDuties           GetPersonsParamsExpand = "duties"
	GetPersonsParamsExpandGroupMemberships GetPersonsParamsExpand = "groupMemberships"
	GetPersonsParamsExpandOwnedPlacements  GetPersonsParamsExpand = "ownedPlacements"
	GetPersonsParamsExpandPlacements       GetPersonsParamsExpand = "placements"
	GetPersonsParamsExpandResponsibleFor   GetPersonsParamsExpand = "responsibleFor"
)

// Defines values for GetPersonsParamsSortkey.
const (
	GetPersonsParamsSortkeyCivicNoAsc     GetPersonsParamsSortkey = "CivicNoAsc"
	GetPersonsParamsSortkeyCivicNoDesc    GetPersonsParamsSortkey = "CivicNoDesc"
	GetPersonsParamsSortkeyDisplayNameAsc GetPersonsParamsSortkey = "DisplayNameAsc"
	GetPersonsParamsSortkeyFamilyNameAsc  GetPersonsParamsSortkey = "FamilyNameAsc"
	GetPersonsParamsSortkeyFamilyNameDesc GetPersonsParamsSortkey = "FamilyNameDesc"
	GetPersonsParamsSortkeyGivenNameAsc   GetPersonsParamsSortkey = "GivenNameAsc"
	GetPersonsParamsSortkeyGivenNameDesc  GetPersonsParamsSortkey = "GivenNameDesc"
	GetPersonsParamsSortkeyModifiedDesc   GetPersonsParamsSortkey = "ModifiedDesc"
)

// Defines values for PostPersonsLookupParamsExpand.
const (
	PostPersonsLookupParamsExpandDuties           PostPersonsLookupParamsExpand = "duties"
	PostPersonsLookupParamsExpandGroupMemberships PostPersonsLookupParamsExpand = "groupMemberships"
	PostPersonsLookupParamsExpandOwnedPlacements  PostPersonsLookupParamsExpand = "ownedPlacements"
	PostPersonsLookupParamsExpandPlacements       PostPersonsLookupParamsExpand = "placements"
	PostPersonsLookupParamsExpandResponsibleFor   PostPersonsLookupParamsExpand = "responsibleFor"
)

// Defines values for GetPersonsIdParamsExpand.
const (
	GetPersonsIdParamsExpandDuties           GetPersonsIdParamsExpand = "duties"
	GetPersonsIdParamsExpandGroupMemberships GetPersonsIdParamsExpand = "groupMemberships"
	GetPersonsIdParamsExpandOwnedPlacements  GetPersonsIdParamsExpand = "ownedPlacements"
	GetPersonsIdParamsExpandPlacements       GetPersonsIdParamsExpand = "placements"
	GetPersonsIdParamsExpandResponsibleFor   GetPersonsIdParamsExpand = "responsibleFor"
)

// Defines values for GetPlacementsParamsExpand.
const (
	GetPlacementsParamsExpandChild  GetPlacementsParamsExpand = "child"
	GetPlacementsParamsExpandOwners GetPlacementsParamsExpand = "owners"
)

// Defines values for GetPlacementsParamsSortkey.
const (
	GetPlacementsParamsSortkeyEndDateAsc    GetPlacementsParamsSortkey = "EndDateAsc"
	GetPlacementsParamsSortkeyEndDateDesc   GetPlacementsParamsSortkey = "EndDateDesc"
	GetPlacementsParamsSortkeyModifiedDesc  GetPlacementsParamsSortkey = "ModifiedDesc"
	GetPlacementsParamsSortkeyStartDateAsc  GetPlacementsParamsSortkey = "StartDateAsc"
	GetPlacementsParamsSortkeyStartDateDesc GetPlacementsParamsSortkey = "StartDateDesc"
)

// Defines values for PostPlacementsLookupParamsExpand.
const (
	PostPlacementsLookupParamsExpandChild  PostPlacementsLookupParamsExpand = "child"
	PostPlacementsLookupParamsExpandOwners PostPlacementsLookupParamsExpand = "owners"
)

// Defines values for GetPlacementsIdParamsExpand.
const (
	Child  GetPlacementsIdParamsExpand = "child"
	Owners GetPlacementsIdParamsExpand = "owners"
)

// Defines values for GetProgrammesParamsSortkey.
const (
	GetProgrammesParamsSortkeyCodeAsc      GetProgrammesParamsSortkey = "CodeAsc"
	GetProgrammesParamsSortkeyModifiedDesc GetProgrammesParamsSortkey = "ModifiedDesc"
	GetProgrammesParamsSortkeyNameAsc      GetProgrammesParamsSortkey = "NameAsc"
)

// Defines values for GetResourcesParamsSortkey.
const (
	GetResourcesParamsSortkeyDisplayNameAsc GetResourcesParamsSortkey = "DisplayNameAsc"
	GetResourcesParamsSortkeyModifiedDesc   GetResourcesParamsSortkey = "ModifiedDesc"
)

// Defines values for GetRoomsParamsSortkey.
const (
	GetRoomsParamsSortkeyDisplayNameAsc GetRoomsParamsSortkey = "DisplayNameAsc"
	GetRoomsParamsSortkeyModifiedDesc   GetRoomsParamsSortkey = "ModifiedDesc"
)

// Defines values for GetSchoolUnitOfferingsParamsSortkey.
const (
	GetSchoolUnitOfferingsParamsSortkeyEndDateAsc    GetSchoolUnitOfferingsParamsSortkey = "EndDateAsc"
	GetSchoolUnitOfferingsParamsSortkeyEndDateDesc   GetSchoolUnitOfferingsParamsSortkey = "EndDateDesc"
	GetSchoolUnitOfferingsParamsSortkeyModifiedDesc  GetSchoolUnitOfferingsParamsSortkey = "ModifiedDesc"
	GetSchoolUnitOfferingsParamsSortkeyStartDateAsc  GetSchoolUnitOfferingsParamsSortkey = "StartDateAsc"
	GetSchoolUnitOfferingsParamsSortkeyStartDateDesc GetSchoolUnitOfferingsParamsSortkey = "StartDateDesc"
)

// Defines values for GetStudyplansParamsSortkey.
const (
	GetStudyplansParamsSortkeyEndDateAsc    GetStudyplansParamsSortkey = "EndDateAsc"
	GetStudyplansParamsSortkeyEndDateDesc   GetStudyplansParamsSortkey = "EndDateDesc"
	GetStudyplansParamsSortkeyModifiedDesc  GetStudyplansParamsSortkey = "ModifiedDesc"
	GetStudyplansParamsSortkeyStartDateAsc  GetStudyplansParamsSortkey = "StartDateAsc"
	GetStudyplansParamsSortkeyStartDateDesc GetStudyplansParamsSortkey = "StartDateDesc"
)

// Defines values for GetSyllabusesParamsSortkey.
const (
	CourseCodeAsc          GetSyllabusesParamsSortkey = "CourseCodeAsc"
	CourseCodeDesc         GetSyllabusesParamsSortkey = "CourseCodeDesc"
	CourseNameAsc          GetSyllabusesParamsSortkey = "CourseNameAsc"
	CourseNameDesc         GetSyllabusesParamsSortkey = "CourseNameDesc"
	ModifiedDesc           GetSyllabusesParamsSortkey = "ModifiedDesc"
	SubjectCodeAsc         GetSyllabusesParamsSortkey = "SubjectCodeAsc"
	SubjectCodeDesc        GetSyllabusesParamsSortkey = "SubjectCodeDesc"
	SubjectDesignationAsc  GetSyllabusesParamsSortkey = "SubjectDesignationAsc"
	SubjectDesignationDesc GetSyllabusesParamsSortkey = "SubjectDesignationDesc"
	SubjectNameAsc         GetSyllabusesParamsSortkey = "SubjectNameAsc"
	SubjectNameDesc        GetSyllabusesParamsSortkey = "SubjectNameDesc"
)

// Absence Absence ska användas för att beskriva anmäld frånvaro för en elev. Den anmälda frånvaron kan avse en av skolan beviljad ledighet eller en frånvaro av annan art som anmäls av eleven själv eller elevens vårdnadshavare.
type Absence struct {
	// EndTime Sluttid för den anmälda frånvaron (RFC 3339, format tex "2015-12-12T10:30:00+01:00").
	EndTime time.Time `json:"endTime"`

	// Id Identifierare för den anmälda frånvaron.
	Id           *openapi_types.UUID  `json:"id,omitempty"`
	Meta         *Meta                `json:"meta,omitempty"`
	Organisation *AbsenceOrganisation `json:"organisation,omitempty"`
	RegisteredBy *AbsenceRegisteredBy `json:"registeredBy,omitempty"`

	// StartTime Starttid för den anmälda frånvaron (RFC 3339 format, tex "2015-12-12T10:30:00+01:00").
	StartTime time.Time         `json:"startTime"`
	Student   AttendanceStudent `json:"student"`

	// Type Anger om frånvaron är en beviljad ledighet eller en annan typ av anmäld frånvaro.
	Type AbsenceEnum `json:"type"`
}

// AbsenceEnum Anger om frånvaron är en beviljad ledighet eller en annan typ av anmäld frånvaro.
type AbsenceEnum string

// AbsenceOrganisation defines model for Absence_organisation.
type AbsenceOrganisation struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// AbsenceRegisteredBy defines model for Absence_registeredBy.
type AbsenceRegisteredBy struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`

	// SecurityMarking Återspeglar värdet från folkbokföringsregistret.
	SecurityMarking *AbsenceRegisteredBySecurityMarking `json:"securityMarking,omitempty"`
}

// AbsenceRegisteredBySecurityMarking Återspeglar värdet från folkbokföringsregistret.
type AbsenceRegisteredBySecurityMarking string

// Absences defines model for Absences.
type Absences struct {
	Data []Absence `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// AbsencesArray defines model for AbsencesArray.
type AbsencesArray = []Absence

// Activities defines model for Activities.
type Activities struct {
	Data []ActivityExpanded `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// ActivitiesArray defines model for ActivitiesArray.
type ActivitiesArray = []ActivityExpanded

// Activity defines model for Activity.
type Activity struct {
	// ActivityType Beskriver vilken typ av aktivitet som avses.
	// * _Undervisning_ - Schemalagd tid med koppling till timplan, som ska närvarorapporteras.
	// * _Elevaktivitet_ - Schemalagd tid för elever som inte är undervisning enligt timplan, och som ska närvarorapporteras, exempelvis mentorstid, klassråd eller friluftsdag
	// * _Provaktivitet_ - En aktivitet som är avsedd för att definiera ett eller flera provtillfällen
	// * _Läraraktivitet_ - Tid för lärare som inte är undervisning och som ingår i lärarens arbetstid, kan vara schemalagd, men ska inte närvarorapporteras, exempelvis konferenstid.
	// * _Övrigt_ - Läxhjälp, lunch, bokning och annat som finns på schemat, men inte är undervisning och inte ska närvarorapporteras
	ActivityType *ActivityActivityType `json:"activityType,omitempty"`

	// CalendarEventsRequired Detta ska uttrycka huruvida aktiviteten ska vara underlag för generering av lektion eller inte.
	CalendarEventsRequired bool `json:"calendarEventsRequired"`

	// Comment En text med kompletterande information.
	Comment *string `json:"comment,omitempty"`

	// DisplayName Namn på aktiviteten, i presentationssyfte.
	DisplayName string `json:"displayName"`

	// EndDate Datum för när aktiviteten slutar (RFC 3339-format, t.ex. "2016-10-15").
	EndDate *openapi_types.Date `json:"endDate,omitempty"`

	// Groups De grupper som är kopplade till aktiviteten.
	Groups []GroupReference `json:"groups"`

	// Id Identifierare för aktiviteten.
	Id   openapi_types.UUID `json:"id"`
	Meta *Meta              `json:"meta,omitempty"`

	// MinutesPlanned Den totalt planerade tiden i minuter.
	MinutesPlanned *int                    `json:"minutesPlanned,omitempty"`
	Organisation   ActivityOrganisation    `json:"organisation"`
	ParentActivity *ActivityParentActivity `json:"parentActivity,omitempty"`

	// StartDate Datum för när aktiviteten startar (RFC 3339-format, t.ex. "2016-10-15").
	StartDate openapi_types.Date `json:"startDate"`
	Syllabus  *ActivitySyllabus  `json:"syllabus,omitempty"`

	// Teachers De lärare (Duty-objekt) som är kopplade till aktiviteten.
	Teachers *[]DutyAssignment `json:"teachers,omitempty"`
}

// ActivityActivityType Beskriver vilken typ av aktivitet som avses.
// * _Undervisning_ - Schemalagd tid med koppling till timplan, som ska närvarorapporteras.
// * _Elevaktivitet_ - Schemalagd tid för elever som inte är undervisning enligt timplan, och som ska närvarorapporteras, exempelvis mentorstid, klassråd eller friluftsdag
// * _Provaktivitet_ - En aktivitet som är avsedd för att definiera ett eller flera provtillfällen
// * _Läraraktivitet_ - Tid för lärare som inte är undervisning och som ingår i lärarens arbetstid, kan vara schemalagd, men ska inte närvarorapporteras, exempelvis konferenstid.
// * _Övrigt_ - Läxhjälp, lunch, bokning och annat som finns på schemat, men inte är undervisning och inte ska närvarorapporteras
type ActivityActivityType string

// ActivityExpanded defines model for ActivityExpanded.
type ActivityExpanded struct {
	Embedded *ActivityExpandedAllOfEmbedded `json:"_embedded,omitempty"`

	// ActivityType Beskriver vilken typ av aktivitet som avses.
	// * _Undervisning_ - Schemalagd tid med koppling till timplan, som ska närvarorapporteras.
	// * _Elevaktivitet_ - Schemalagd tid för elever som inte är undervisning enligt timplan, och som ska närvarorapporteras, exempelvis mentorstid, klassråd eller friluftsdag
	// * _Provaktivitet_ - En aktivitet som är avsedd för att definiera ett eller flera provtillfällen
	// * _Läraraktivitet_ - Tid för lärare som inte är undervisning och som ingår i lärarens arbetstid, kan vara schemalagd, men ska inte närvarorapporteras, exempelvis konferenstid.
	// * _Övrigt_ - Läxhjälp, lunch, bokning och annat som finns på schemat, men inte är undervisning och inte ska närvarorapporteras
	ActivityType *ActivityExpandedActivityType `json:"activityType,omitempty"`

	// CalendarEventsRequired Detta ska uttrycka huruvida aktiviteten ska vara underlag för generering av lektion eller inte.
	CalendarEventsRequired bool `json:"calendarEventsRequired"`

	// Comment En text med kompletterande information.
	Comment *string `json:"comment,omitempty"`

	// DisplayName Namn på aktiviteten, i presentationssyfte.
	DisplayName string `json:"displayName"`

	// EndDate Datum för när aktiviteten slutar (RFC 3339-format, t.ex. "2016-10-15").
	EndDate *openapi_types.Date `json:"endDate,omitempty"`

	// Groups De grupper som är kopplade till aktiviteten.
	Groups []GroupReference `json:"groups"`

	// Id Identifierare för aktiviteten.
	Id   openapi_types.UUID `json:"id"`
	Meta *Meta              `json:"meta,omitempty"`

	// MinutesPlanned Den totalt planerade tiden i minuter.
	MinutesPlanned *int                    `json:"minutesPlanned,omitempty"`
	Organisation   ActivityOrganisation    `json:"organisation"`
	ParentActivity *ActivityParentActivity `json:"parentActivity,omitempty"`

	// StartDate Datum för när aktiviteten startar (RFC 3339-format, t.ex. "2016-10-15").
	StartDate openapi_types.Date `json:"startDate"`
	Syllabus  *ActivitySyllabus  `json:"syllabus,omitempty"`

	// Teachers De lärare (Duty-objekt) som är kopplade till aktiviteten.
	Teachers *[]DutyAssignment `json:"teachers,omitempty"`
}

// ActivityExpandedActivityType Beskriver vilken typ av aktivitet som avses.
// * _Undervisning_ - Schemalagd tid med koppling till timplan, som ska närvarorapporteras.
// * _Elevaktivitet_ - Schemalagd tid för elever som inte är undervisning enligt timplan, och som ska närvarorapporteras, exempelvis mentorstid, klassråd eller friluftsdag
// * _Provaktivitet_ - En aktivitet som är avsedd för att definiera ett eller flera provtillfällen
// * _Läraraktivitet_ - Tid för lärare som inte är undervisning och som ingår i lärarens arbetstid, kan vara schemalagd, men ska inte närvarorapporteras, exempelvis konferenstid.
// * _Övrigt_ - Läxhjälp, lunch, bokning och annat som finns på schemat, men inte är undervisning och inte ska närvarorapporteras
type ActivityExpandedActivityType string

// ActivityExpandedAllOf defines model for ActivityExpanded_allOf.
type ActivityExpandedAllOf struct {
	Embedded *ActivityExpandedAllOfEmbedded `json:"_embedded,omitempty"`
}

// ActivityExpandedAllOfEmbedded defines model for ActivityExpanded_allOf__embedded.
type ActivityExpandedAllOfEmbedded struct {
	Groups *[]Group `json:"groups,omitempty"`

	// Syllabus Används för att referera till en specifik kurskod eller ett ämne med information om årskurs och skolform som avses med undervisningen. För officiella ämnen/kurser anges läroplan.
	Syllabus *Syllabus `json:"syllabus,omitempty"`
	Teachers *[]Duty   `json:"teachers,omitempty"`
}

// ActivityReference defines model for ActivityReference.
type ActivityReference struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// ActivityOrganisation defines model for Activity_organisation.
type ActivityOrganisation struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// ActivityParentActivity defines model for Activity_parentActivity.
type ActivityParentActivity struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// ActivitySyllabus defines model for Activity_syllabus.
type ActivitySyllabus struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// AggregatedAttendance defines model for AggregatedAttendance.
type AggregatedAttendance struct {
	Embedded *AggregatedAttendanceEmbedded `json:"_embedded,omitempty"`
	Activity ActivityReference             `json:"activity"`

	// AttendanceSum Summerad tid i minuter för elevens närvaro på kalenderhändelser.
	AttendanceSum int `json:"attendanceSum"`

	// EndDate Slutdatum för den aggregerade närvaron (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	EndDate openapi_types.Date `json:"endDate"`

	// InvalidAbsenceSum Summerad tid i minuter för elevens ogiltiga frånvaro på kalenderhändelser.
	InvalidAbsenceSum *int `json:"invalidAbsenceSum,omitempty"`

	// OfferedSum Summerad tid i minuter för alla kalenderhändelser där eleven har erbjudits möjlighet att närvara.
	OfferedSum *int `json:"offeredSum,omitempty"`

	// OtherAttendanceSum Summerad tid i minuter för elevens deltagande i annan skolaktivitet, såsom elevråd, i stället för deltagande på kalenderhändelser.
	OtherAttendanceSum *int `json:"otherAttendanceSum,omitempty"`

	// ReportedSum Summerad tid i minuter för alla elevens kalenderhändelser där läraren eller annan personal har markerat lektionen som färdigrapporterad.
	ReportedSum *int `json:"reportedSum,omitempty"`

	// StartDate Startdatum för den aggregerade närvaron (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	StartDate openapi_types.Date          `json:"startDate"`
	Student   AggregatedAttendanceStudent `json:"student"`

	// ValidAbsenceSum Summerad tid i minuter för elevens giltiga frånvaro på kalenderhändelser.
	ValidAbsenceSum *int `json:"validAbsenceSum,omitempty"`
}

// AggregatedAttendanceEmbedded defines model for AggregatedAttendance__embedded.
type AggregatedAttendanceEmbedded struct {
	Activity *Activity `json:"activity,omitempty"`
	Student  *Person   `json:"student,omitempty"`
}

// AggregatedAttendanceStudent defines model for AggregatedAttendance_student.
type AggregatedAttendanceStudent struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`

	// SecurityMarking Återspeglar värdet från folkbokföringsregistret.
	SecurityMarking *AggregatedAttendanceStudentSecurityMarking `json:"securityMarking,omitempty"`
}

// AggregatedAttendanceStudentSecurityMarking Återspeglar värdet från folkbokföringsregistret.
type AggregatedAttendanceStudentSecurityMarking string

// AggregatedAttendances defines model for AggregatedAttendances.
type AggregatedAttendances struct {
	Data []AggregatedAttendance `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// AssignmentRoleTypeEnum defines model for AssignmentRoleTypeEnum.
type AssignmentRoleTypeEnum string

// Attendance defines model for Attendance.
type Attendance struct {
	// AbsenceReason Angiven anledning till frånvaro.
	AbsenceReason *string `json:"absenceReason,omitempty"`

	// AttendanceMinutes Längd i minuter för elevens närvaro på kalenderhändelsen.
	AttendanceMinutes *int                   `json:"attendanceMinutes,omitempty"`
	CalendarEvent     CalendarEventReference `json:"calendarEvent"`

	// Id Identifierare för närvaroposten.
	Id *openapi_types.UUID `json:"id,omitempty"`

	// InvalidAbsenceMinutes Längd i minuter för elevens ogiltiga frånvaro på kalenderhändelsen.
	InvalidAbsenceMinutes *int `json:"invalidAbsenceMinutes,omitempty"`

	// IsReported Anger om lektionen är rapporterad.
	IsReported bool  `json:"isReported"`
	Meta       *Meta `json:"meta,omitempty"`

	// OtherAttendanceMinutes Tid i  minuter för elevens deltagande i annan skolaktivitet, såsom elevråd, i stället för deltagande på kalenderhändelsen.
	OtherAttendanceMinutes *int `json:"otherAttendanceMinutes,omitempty"`

	// ReportedTimestamp Tidpunkt för rapportering av kalenderhändelsen (RFC 3339 format, tex "2015-12-12T10:30:00+01:00").
	ReportedTimestamp *time.Time          `json:"reportedTimestamp,omitempty"`
	Reporter          *AttendanceReporter `json:"reporter,omitempty"`
	Student           AttendanceStudent   `json:"student"`

	// ValidAbsenceMinutes Längd i minuter för elevens giltiga frånvaro på kalenderhändelsen.
	ValidAbsenceMinutes *int `json:"validAbsenceMinutes,omitempty"`
}

// AttendanceEvent defines model for AttendanceEvent.
type AttendanceEvent struct {
	Embedded  *AttendanceEventEmbedded `json:"_embedded,omitempty"`
	EventType AttendanceEventEventType `json:"eventType"`
	Group     AttendanceEventGroup     `json:"group"`

	// Id Identifierare för den anmälda närvaron.
	Id           *openapi_types.UUID          `json:"id,omitempty"`
	Meta         *Meta                        `json:"meta,omitempty"`
	Person       AttendanceEventPerson        `json:"person"`
	RegisteredBy *AttendanceEventRegisteredBy `json:"registeredBy,omitempty"`
	Time         time.Time                    `json:"time"`
}

// AttendanceEventEventType defines model for AttendanceEvent.EventType.
type AttendanceEventEventType string

// AttendanceEventEmbedded defines model for AttendanceEvent__embedded.
type AttendanceEventEmbedded struct {
	// Group Group kan innehålla personer eller bara vara en tom "platshållare" utan medlemmar, som kan populeras vid ett senare tillfälle. Notera att gruppens koppling till ämnen/kurser och lärare görs via Aktivitet. Grupper har olika egenskaper baserat på grupptyp. Individer kan ha olika roller i relation till en viss grupp. Grupper har specifika egenskaper.
	Group        *GroupFragment `json:"group,omitempty"`
	Person       *Person        `json:"person,omitempty"`
	RegisteredBy *Person        `json:"registeredBy,omitempty"`
}

// AttendanceEventGroup defines model for AttendanceEvent_group.
type AttendanceEventGroup struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// AttendanceEventPerson defines model for AttendanceEvent_person.
type AttendanceEventPerson struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`

	// SecurityMarking Återspeglar värdet från folkbokföringsregistret.
	SecurityMarking *AttendanceEventPersonSecurityMarking `json:"securityMarking,omitempty"`
}

// AttendanceEventPersonSecurityMarking Återspeglar värdet från folkbokföringsregistret.
type AttendanceEventPersonSecurityMarking string

// AttendanceEventRegisteredBy defines model for AttendanceEvent_registeredBy.
type AttendanceEventRegisteredBy struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`

	// SecurityMarking Återspeglar värdet från folkbokföringsregistret.
	SecurityMarking *AttendanceEventRegisteredBySecurityMarking `json:"securityMarking,omitempty"`
}

// AttendanceEventRegisteredBySecurityMarking Återspeglar värdet från folkbokföringsregistret.
type AttendanceEventRegisteredBySecurityMarking string

// AttendanceEvents defines model for AttendanceEvents.
type AttendanceEvents struct {
	Data []AttendanceEvent `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// AttendanceSchedule defines model for AttendanceSchedule.
type AttendanceSchedule struct {
	// EndDate Anger datum då schemat slutar (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	EndDate *openapi_types.Date `json:"endDate,omitempty"`

	// Id Identifierare för vistelseschemat.
	Id   *openapi_types.UUID `json:"id,omitempty"`
	Meta *Meta               `json:"meta,omitempty"`

	// NumberOfWeeks Hur många veckor schemat gäller för innan det "börjar om".
	NumberOfWeeks   int                         `json:"numberOfWeeks"`
	Placement       AttendanceSchedulePlacement `json:"placement"`
	ScheduleEntries *[]AttendanceScheduleEntry  `json:"scheduleEntries,omitempty"`

	// StartDate Anger datum då schemat startar (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	StartDate openapi_types.Date        `json:"startDate"`
	State     []AttendanceScheduleState `json:"state"`

	// Temporary Anger om detta är ett undantag som gäller i stället för normalschemat under en begränsad tid. Slutdatum måste anges.
	Temporary *bool `json:"temporary,omitempty"`
}

// AttendanceScheduleEntry defines model for AttendanceScheduleEntry.
type AttendanceScheduleEntry struct {
	// DayOfWeek Anger veckodag.
	DayOfWeek AttendanceScheduleEntryDayOfWeek `json:"dayOfWeek"`

	// EndTime Sluttid på dagen för schemat (IS08601 format, t.ex. "15:30").
	EndTime int `json:"endTime"`

	// StartTime Starttid på dagen för schemat (IS08601 format, t.ex. "08:30").
	StartTime string `json:"startTime"`

	// WeekOffset Anger vecka för alternerande schema, exempelvis 0, 1, eller 2 beroende på hur många olika veckor som är specificerade i schemat.
	WeekOffset int `json:"weekOffset"`
}

// AttendanceScheduleEntryDayOfWeek Anger veckodag.
type AttendanceScheduleEntryDayOfWeek string

// AttendanceScheduleState defines model for AttendanceScheduleState.
type AttendanceScheduleState struct {
	// Comment En kommentar angående tillståndet.
	Comment *string `json:"comment,omitempty"`

	// RegisteredAt Tid och datum för tillstånd (RFC 3339 format, tex "2015-12-12T10:30:00+01:00").
	RegisteredAt time.Time                            `json:"registeredAt"`
	RegisteredBy *AttendanceScheduleStateRegisteredBy `json:"registeredBy,omitempty"`

	// State Beskriver schemats tillstånd.
	State AttendanceScheduleStateState `json:"state"`
}

// AttendanceScheduleStateState Beskriver schemats tillstånd.
type AttendanceScheduleStateState string

// AttendanceScheduleStateRegisteredBy defines model for AttendanceScheduleState_registeredBy.
type AttendanceScheduleStateRegisteredBy struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`

	// SecurityMarking Återspeglar värdet från folkbokföringsregistret.
	SecurityMarking *AttendanceScheduleStateRegisteredBySecurityMarking `json:"securityMarking,omitempty"`
}

// AttendanceScheduleStateRegisteredBySecurityMarking Återspeglar värdet från folkbokföringsregistret.
type AttendanceScheduleStateRegisteredBySecurityMarking string

// AttendanceSchedulePlacement defines model for AttendanceSchedule_placement.
type AttendanceSchedulePlacement struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// AttendanceSchedules defines model for AttendanceSchedules.
type AttendanceSchedules struct {
	Data []AttendanceSchedule `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// AttendanceReporter defines model for Attendance_reporter.
type AttendanceReporter struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`

	// SecurityMarking Återspeglar värdet från folkbokföringsregistret.
	SecurityMarking *AttendanceReporterSecurityMarking `json:"securityMarking,omitempty"`
}

// AttendanceReporterSecurityMarking Återspeglar värdet från folkbokföringsregistret.
type AttendanceReporterSecurityMarking string

// AttendanceStudent defines model for Attendance_student.
type AttendanceStudent struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`

	// SecurityMarking Återspeglar värdet från folkbokföringsregistret.
	SecurityMarking *AttendanceStudentSecurityMarking `json:"securityMarking,omitempty"`
}

// AttendanceStudentSecurityMarking Återspeglar värdet från folkbokföringsregistret.
type AttendanceStudentSecurityMarking string

// Attendances defines model for Attendances.
type Attendances struct {
	Data []Attendance `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// AttendancesArray defines model for AttendancesArray.
type AttendancesArray = []Attendance

// CalendarEvent defines model for CalendarEvent.
type CalendarEvent struct {
	Embedded *CalendarEventEmbedded `json:"_embedded,omitempty"`
	Activity CalendarEventActivity  `json:"activity"`

	// Cancelled Inställd används för att ange att en planerad kalenderhändelse inte ska äga rum till följd av en avbokning eller annan tillfällig avvikelse. Förvalt värde är False.
	Cancelled *bool `json:"cancelled,omitempty"`

	// Comment En text med kompletterande information.
	Comment *string `json:"comment,omitempty"`

	// EndTime Kalenderhändelsens sluttid med datum och tid (RFC 3339 format tex "2015-12-12T10:30:00+01:00").
	EndTime time.Time `json:"endTime"`

	// Id Identifierare för kalenderhändelsen.
	Id        openapi_types.UUID             `json:"id"`
	Meta      *Meta                          `json:"meta,omitempty"`
	Resources *[]CalendarEventResourcesInner `json:"resources,omitempty"`
	Rooms     *[]CalendarEventRoomsInner     `json:"rooms,omitempty"`

	// StartTime Kalenderhändelsens starttid med datum och tid (RFC 3339 format tex "2015-12-12T10:30:00+01:00").
	StartTime         time.Time           `json:"startTime"`
	StudentExceptions *[]StudentException `json:"studentExceptions,omitempty"`
	TeacherExceptions *[]TeacherException `json:"teacherExceptions,omitempty"`

	// TeachingLengthStudent Faktisk undervisningstid för elever (och elever ingående i grupper). Anges i minuter. Tiden kan vara kortare eller längre än tiden för kalenderhändelsen, till exempel då en rast ingår i tiden.
	TeachingLengthStudent *int `json:"teachingLengthStudent,omitempty"`

	// TeachingLengthTeacher Faktisk undervisningstid för lärare anges i minuter. Lärartiden kan vara kortare eller längre än tiden för kalenderhändelsen.
	TeachingLengthTeacher *int `json:"teachingLengthTeacher,omitempty"`
}

// CalendarEventReference defines model for CalendarEventReference.
type CalendarEventReference struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// CalendarEventEmbedded defines model for CalendarEvent__embedded.
type CalendarEventEmbedded struct {
	Activity   *Activity     `json:"activity,omitempty"`
	Attendance *[]Attendance `json:"attendance,omitempty"`
}

// CalendarEventActivity defines model for CalendarEvent_activity.
type CalendarEventActivity struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// CalendarEventResourcesInner defines model for CalendarEvent_resources_inner.
type CalendarEventResourcesInner struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// CalendarEventRoomsInner defines model for CalendarEvent_rooms_inner.
type CalendarEventRoomsInner struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// CalendarEvents defines model for CalendarEvents.
type CalendarEvents struct {
	Data []CalendarEvent `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// ContactInfo Kontaktuppgifter till skolan eller organisationselementet. Kan användas för supportkontakt och andra publika kontaktuppgifter.
type ContactInfo struct {
	// Info Beskrivning i fritext av kontaktuppgifter till skolan eller organisationsenheten.
	Info *string `json:"info,omitempty"`

	// InfoType Typ av kontaktuppgift. Publika uppgifter avser uppgifter som kan visas för allmänheten, såsom adress och telefonnummer till skolan.
	InfoType *ContactInfoInfoType `json:"infoType,omitempty"`
}

// ContactInfoInfoType Typ av kontaktuppgift. Publika uppgifter avser uppgifter som kan visas för allmänheten, såsom adress och telefonnummer till skolan.
type ContactInfoInfoType string

// CreateSubscription Skapas en prenumeration på ändringar av angivna objekt. Vid ändringar i informationsmängden hos informationsägaren ska det konsumerande systemet notifieras via den URL som anges i `target`. Det konsumerande systemet gör därefter anrop för att inhämta ändrad eller borttagen information. Informationsägaren ska skicka en notis för varje registrerad prenumeration så fort en förändring identifieras. Informationsägaren kan välja att skicka en notis för multipla förändringar.
type CreateSubscription struct {
	// Name Ett beskrivande namn på webhook:en.
	Name          string                                 `json:"name"`
	ResourceTypes []CreateSubscriptionResourceTypesInner `json:"resourceTypes"`

	// Target URL:en som webhook:en ska posta till.
	Target string `json:"target"`
}

// CreateSubscriptionResourceTypesInner defines model for CreateSubscription_resourceTypes_inner.
type CreateSubscriptionResourceTypesInner struct {
	Resource *EndPointsEnum `json:"resource,omitempty"`
}

// CurriculumEnum Anger vilken läroplan aktiviteten avser. För vissa skolformer saknas läroplan.
type CurriculumEnum string

// DeletedEntities defines model for DeletedEntities.
type DeletedEntities struct {
	Data DeletedEntitiesData `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// DeletedEntitiesData defines model for DeletedEntities_data.
type DeletedEntitiesData struct {
	Absences            *[]openapi_types.UUID `json:"absences,omitempty"`
	Activitites         *[]openapi_types.UUID `json:"activitites,omitempty"`
	AttendanceEvents    *[]openapi_types.UUID `json:"attendanceEvents,omitempty"`
	AttendanceSchedules *[]openapi_types.UUID `json:"attendanceSchedules,omitempty"`
	Attendances         *[]openapi_types.UUID `json:"attendances,omitempty"`
	CalendarEvents      *[]openapi_types.UUID `json:"calendarEvents,omitempty"`
	Duties              *[]openapi_types.UUID `json:"duties,omitempty"`
	Grades              *[]openapi_types.UUID `json:"grades,omitempty"`
	Groups              *[]openapi_types.UUID `json:"groups,omitempty"`
	Organisations       *[]openapi_types.UUID `json:"organisations,omitempty"`
	Persons             *[]openapi_types.UUID `json:"persons,omitempty"`
	Placements          *[]openapi_types.UUID `json:"placements,omitempty"`
	Programmes          *[]openapi_types.UUID `json:"programmes,omitempty"`
	Resources           *[]openapi_types.UUID `json:"resources,omitempty"`
	Rooms               *[]openapi_types.UUID `json:"rooms,omitempty"`
	SchoolUnitOfferings *[]openapi_types.UUID `json:"schoolUnitOfferings,omitempty"`
	StudyPlans          *[]openapi_types.UUID `json:"studyPlans,omitempty"`
	Syllabuses          *[]openapi_types.UUID `json:"syllabuses,omitempty"`
}

// Duties defines model for Duties.
type Duties struct {
	Data []DutyExpanded `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// DutiesArray defines model for DutiesArray.
type DutiesArray = []DutyExpanded

// Duty referens till ett Dutyobjekt
type Duty struct {
	// AssignmentRole Datatyp som ska användas för att beskriva arbetsuppgifter för en person i relation till elevgrupp. Lärares undervisning ska inte uttryckas som en arbetsuppgift, för detta syfte används i stället Aktivitet.
	AssignmentRole *[]DutyAssignmentRoleInner `json:"assignmentRole,omitempty"`

	// Description Arbetsområde. Kompletterande information till personalkategori, exempelvis Bibliotekarie.
	Description *string               `json:"description,omitempty"`
	DutyAt      OrganisationReference `json:"dutyAt"`

	// DutyPercent Tjänstgöringsgrad i procent
	DutyPercent *int         `json:"dutyPercent,omitempty"`
	DutyRole    DutyDutyRole `json:"dutyRole"`

	// EndDate Slutdatum för personens anställning på en viss skolenhet eller skola (RFC 3339-format, e.g. "2016-10-15"). Inkluderande.
	EndDate *openapi_types.Date `json:"endDate,omitempty"`

	// HoursPerYear Antalet timmar tjänstgöringen omfattar under ett år.
	HoursPerYear *int `json:"hoursPerYear,omitempty"`

	// Id Ett ID för tjänsten.
	Id     openapi_types.UUID `json:"id"`
	Meta   *Meta              `json:"meta,omitempty"`
	Person *DutyPerson        `json:"person,omitempty"`

	// Signature En signatur för tjänstgöringen exempelvis NJN, JOAN.
	Signature *string `json:"signature,omitempty"`

	// StartDate Startdatum för personens anställning på en viss skolenhet eller skola (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	StartDate openapi_types.Date `json:"startDate"`
}

// DutyDutyRole defines model for Duty.DutyRole.
type DutyDutyRole string

// DutyAssignment defines model for DutyAssignment.
type DutyAssignment struct {
	Duty DutyReference `json:"duty"`

	// EndDate Datum för när lärarens deltagande i aktiviteten slutar (RFC 3339-format, t.ex. "2016-10-15").
	EndDate *openapi_types.Date `json:"endDate,omitempty"`

	// Grader Markerar att läraren har rollen som betygsättande lärare för aktiviteten
	Grader *bool `json:"grader,omitempty"`

	// MinutesPlanned Det antal minuter läraren är kopplad till aktiviteten
	MinutesPlanned *int `json:"minutesPlanned,omitempty"`

	// StartDate Datum för när lärarens deltagande i aktiviteten startar (RFC 3339-format, t.ex. "2016-10-15").
	StartDate *openapi_types.Date `json:"startDate,omitempty"`
}

// DutyExpanded defines model for DutyExpanded.
type DutyExpanded struct {
	Embedded *DutyExpandedAllOfEmbedded `json:"_embedded,omitempty"`

	// AssignmentRole Datatyp som ska användas för att beskriva arbetsuppgifter för en person i relation till elevgrupp. Lärares undervisning ska inte uttryckas som en arbetsuppgift, för detta syfte används i stället Aktivitet.
	AssignmentRole *[]DutyAssignmentRoleInner `json:"assignmentRole,omitempty"`

	// Description Arbetsområde. Kompletterande information till personalkategori, exempelvis Bibliotekarie.
	Description *string               `json:"description,omitempty"`
	DutyAt      OrganisationReference `json:"dutyAt"`

	// DutyPercent Tjänstgöringsgrad i procent
	DutyPercent *int                 `json:"dutyPercent,omitempty"`
	DutyRole    DutyExpandedDutyRole `json:"dutyRole"`

	// EndDate Slutdatum för personens anställning på en viss skolenhet eller skola (RFC 3339-format, e.g. "2016-10-15"). Inkluderande.
	EndDate *openapi_types.Date `json:"endDate,omitempty"`

	// HoursPerYear Antalet timmar tjänstgöringen omfattar under ett år.
	HoursPerYear *int `json:"hoursPerYear,omitempty"`

	// Id Ett ID för tjänsten.
	Id     openapi_types.UUID `json:"id"`
	Meta   *Meta              `json:"meta,omitempty"`
	Person *DutyPerson        `json:"person,omitempty"`

	// Signature En signatur för tjänstgöringen exempelvis NJN, JOAN.
	Signature *string `json:"signature,omitempty"`

	// StartDate Startdatum för personens anställning på en viss skolenhet eller skola (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	StartDate openapi_types.Date `json:"startDate"`
}

// DutyExpandedDutyRole defines model for DutyExpanded.DutyRole.
type DutyExpandedDutyRole string

// DutyExpandedAllOf defines model for DutyExpanded_allOf.
type DutyExpandedAllOf struct {
	Embedded *DutyExpandedAllOfEmbedded `json:"_embedded,omitempty"`
}

// DutyExpandedAllOfEmbedded defines model for DutyExpanded_allOf__embedded.
type DutyExpandedAllOfEmbedded struct {
	Person *Person `json:"person,omitempty"`
}

// DutyReference defines model for DutyReference.
type DutyReference struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// DutyRole Roller för en Duty. Förskolechef och Övriga pedagogisk personal är deprekerade och kommer tas bort till nästa version.
type DutyRole string

// DutyAssignmentRoleInner defines model for Duty_assignmentRole_inner.
type DutyAssignmentRoleInner struct {
	AssignmentRoleType AssignmentRoleTypeEnum `json:"assignmentRoleType"`

	// EndDate Slutdatum för tjänstens relation till gruppen (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	EndDate *openapi_types.Date `json:"endDate,omitempty"`
	Group   GroupReference      `json:"group"`

	// StartDate Startdatum för tjänstens relation till gruppen (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	StartDate *openapi_types.Date `json:"startDate,omitempty"`
}

// DutyPerson defines model for Duty_person.
type DutyPerson struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`

	// SecurityMarking Återspeglar värdet från folkbokföringsregistret.
	SecurityMarking *DutyPersonSecurityMarking `json:"securityMarking,omitempty"`
}

// DutyPersonSecurityMarking Återspeglar värdet från folkbokföringsregistret.
type DutyPersonSecurityMarking string

// Email defines model for Email.
type Email struct {
	Type  EmailType           `json:"type"`
	Value openapi_types.Email `json:"value"`
}

// EmailType defines model for Email.Type.
type EmailType string

// EndPointsEnum defines model for EndPointsEnum.
type EndPointsEnum string

// Enrolment defines model for Enrolment.
type Enrolment struct {
	// Cancelled Inskrivningen har avbrutits i förväg.
	Cancelled *bool `json:"cancelled,omitempty"`

	// EducationCode Studievägskod för den aktuella inskrivningen.
	EducationCode *string `json:"educationCode,omitempty"`

	// EndDate Slutdatum för inskrivningen (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	EndDate   *openapi_types.Date `json:"endDate,omitempty"`
	EnroledAt SchoolUnitReference `json:"enroledAt"`
	Programme *EnrolmentProgramme `json:"programme,omitempty"`

	// SchoolType Följande värden används för att beskriva skolform:
	//   - _FS_ - Förskola
	//   - _FKLASS_ - Förskoleklass
	//   - _FTH_ - Fritidshem
	//   - _OPPFTH_ - Öppen fritidsverksamhet
	//   - _GR_ - Grundskola
	//   - _GRS_ - Grundsärskola
	//   - _TR_ - Träningsskolan
	//   - _SP_ - Specialskola
	//   - _SAM_ - Sameskola
	//   - _GY_ - Gymnasieskola
	//   - _GYS_ - Gymnasiesärskola
	//   - _VUX_ - Kommunal vuxenutbildning
	//   - _VUXSFI_ - Kommunal vuxenutbildning i svenska för invandrare
	//   - _VUXGR_ - Kommunal vuxenutbildning på grundläggande nivå
	//   - _VUXGY_ - Kommunal vuxenutbildning på gymnasial nivå
	//   - _VUXSARGR_ - Kommunal vuxenutbildning som särskild utbildning på grundläggande nivå
	//   - _VUXSARTR_ - Kommunal vuxenutbildning som särskild utbildning som motsvarar träningsskolan
	//   - _VUXSARGY_ - Kommunal vuxenutbildning som särskild utbildning på gymnasial nivå
	//   - _SFI_ - Utbildning i svenska för invandrare
	//   - _SARVUX_ - Särskild utbildning för vuxna
	//   - _SARVUXGR_ - Särskild utbildning för vuxna på grundläggande nivå
	//   - _SARVUXGY_ - Särskild utbildning för vuxna på gymnasial nivå
	//   - _SFI_ - Kommunal vuxenutbildning i svenska för invandrare
	//   - _KU_ - Kulturskola
	//   - _YH_ - Yrkeshögskola
	//   - _FHS_ - Folkhögskola
	//   - _STF_ - Studieförbund
	//   - _KKU_ - Konst- och kulturutbildning
	//   - _HS_ - Högskola
	//   - _ABU_ - Arbetsmarknadsutbildning
	//   - _AU_ - Annan undervisning
	SchoolType SchoolTypesEnum `json:"schoolType"`

	// SchoolYear Värdet årskurs anger det år efter skolstarten för vilket en student följer undervisningen.
	SchoolYear *int `json:"schoolYear,omitempty"`

	// Specification Kompletterande information angående innehåll i elevens utbildning, används som avgränsning av ett visst utbildningsalternativ för exempelvis lärlingsutbildning.
	Specification *string `json:"specification,omitempty"`

	// StartDate Startdatum för inskrivningen (RFC 3339-format, t.ex. "2016-10-15").Inkluderande.
	StartDate openapi_types.Date `json:"startDate"`
}

// EnrolmentProgramme defines model for Enrolment_programme.
type EnrolmentProgramme struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// Error defines model for Error.
type Error struct {
	// Code Teknisk kod för att beskriva fel, varje källa bestämmer själv över möjliga felkoder.
	Code string `json:"code"`

	// Message Text för att beskriva felet.
	Message string `json:"message"`
}

// Grade Avser ett registrerat betyg för en elev i ett ämne eller en kurs.
type Grade struct {
	// AdaptedStudyPlan Om en specialinriktad ämnesplan (GY) eller anpassad studiegång (GR) har använts för kursen så beskrivs här på vilket sätt studiegången anpassats.
	AdaptedStudyPlan string `json:"adaptedStudyPlan"`

	// Converted Anger om betyget är omvandlat. Förvalt värde är "false".
	Converted *bool `json:"converted,omitempty"`

	// CorrectionType Ändringstyp för betyget, om det är ändrat.
	CorrectionType *GradeCorrectionType `json:"correctionType,omitempty"`
	DiplomaProject *GradeDiplomaProject `json:"diplomaProject,omitempty"`

	// FinalGrade Anger om det registrerade betyget är ett slutbetyg för ämnet eller kursen.
	FinalGrade bool `json:"finalGrade"`

	// GradeValue Anger vilket betyg eleven har tilldelats.
	GradeValue     string               `json:"gradeValue"`
	GradingTeacher *GradeGradingTeacher `json:"gradingTeacher,omitempty"`
	Group          *GradeGroup          `json:"group,omitempty"`

	// Id ID för betyget.
	Id           openapi_types.UUID `json:"id"`
	Meta         *Meta              `json:"meta,omitempty"`
	Organisation *GradeOrganisation `json:"organisation,omitempty"`
	RegisteredBy GradeRegisteredBy  `json:"registeredBy"`

	// RegisteredDate Det datum då betyget registrerades (RFC 3339-format, t.ex. "2016-10-15").
	RegisteredDate openapi_types.Date `json:"registeredDate"`

	// Remark Andra anmärkningar för betygsraden.
	Remark *string `json:"remark,omitempty"`

	// Semester Om betyget avser höst- eller vårtermin.
	Semester *GradeSemester    `json:"semester,omitempty"`
	Student  AttendanceStudent `json:"student"`
	Syllabus SyllabusReference `json:"syllabus"`

	// Trial Anger om betyget satts vid en prövning. Förvalt värde är "false".
	Trial *bool `json:"trial,omitempty"`

	// Year Året som betyget gäller, exempelvis 2019.
	Year *int `json:"year,omitempty"`
}

// GradeCorrectionType Ändringstyp för betyget, om det är ändrat.
type GradeCorrectionType string

// GradeSemester Om betyget avser höst- eller vårtermin.
type GradeSemester string

// GradeDiplomaProject defines model for Grade_diplomaProject.
type GradeDiplomaProject struct {
	// Description Beskrivning av gymnasiearbete.
	Description string `json:"description"`

	// DescriptionEnglish Eventuell engelsk beskrivning av gymnasiearbete.
	DescriptionEnglish *string `json:"descriptionEnglish,omitempty"`

	// Title Titel på gymnasiearbete.
	Title string `json:"title"`

	// TitleEnglish Eventuell engelsk titel på gymnasiearbete.
	TitleEnglish *string `json:"titleEnglish,omitempty"`
}

// GradeGradingTeacher defines model for Grade_gradingTeacher.
type GradeGradingTeacher struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`

	// SecurityMarking Återspeglar värdet från folkbokföringsregistret.
	SecurityMarking *GradeGradingTeacherSecurityMarking `json:"securityMarking,omitempty"`
}

// GradeGradingTeacherSecurityMarking Återspeglar värdet från folkbokföringsregistret.
type GradeGradingTeacherSecurityMarking string

// GradeGroup defines model for Grade_group.
type GradeGroup struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// GradeOrganisation defines model for Grade_organisation.
type GradeOrganisation struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// GradeRegisteredBy defines model for Grade_registeredBy.
type GradeRegisteredBy struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`

	// SecurityMarking Återspeglar värdet från folkbokföringsregistret.
	SecurityMarking *GradeRegisteredBySecurityMarking `json:"securityMarking,omitempty"`
}

// GradeRegisteredBySecurityMarking Återspeglar värdet från folkbokföringsregistret.
type GradeRegisteredBySecurityMarking string

// Grades defines model for Grades.
type Grades struct {
	Data []Grade `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// GradesArray defines model for GradesArray.
type GradesArray = []Grade

// Group defines model for Group.
type Group struct {
	// DisplayName Gruppens benämning.
	DisplayName string `json:"displayName"`

	// EndDate Slutdatum för gruppens giltighetstid (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	EndDate *openapi_types.Date `json:"endDate,omitempty"`

	// GroupMemberships Gruppmedlemskap anger att en person är medlem i en grupp och vilken tidsperiod medlemskapet omfattar.
	GroupMemberships *[]GroupMembership `json:"groupMemberships,omitempty"`

	// GroupType Grupptyp anger vad en grupp ska användas till.
	// Ett värdeförråd för att indikera anger vilka grupptyper som finns.
	// * _Undervisning_ - Undervisningsgruppen är en grupp som har koppling
	//   till ett ämne eller en kurs, och som ska schemaläggas med undervisningstid
	//   ihop med en lärare.
	// * _Klass_ - Klassen är en organisatorisk grupp med elever som är skolplacerade
	//   på en skola med skolform FSK, GR, GRS, SP, SAM, GY eller GYS.
	//   Varje elev ska vara placerad i endast en klass. Klassen kan schemaläggas
	//   med undervisning enligt timplan. "Klassföreståndare" kan beskrivas genom att
	//   koppla en _AssignmentRole_ av typen _Mentor_.
	// * _Mentor_ - Grupp med elever vilka delar samma mentor/mentorer.
	//   Mentor kopplas till gruppen genom en _AssignmentRole_.
	// * _Provgrupp_ - Grupp med elever vilka ska genomföra ett eller flera prov.
	// * _Schema_ - Schemagrupper är grupper som utgör ett komplement till
	//   grupper av typen Undervisning. Schemagrupper ska schemaläggas för att
	//   åstadkomma anpassningar av schemat för enskilda elever eller grupper
	//   av elever. Exempel på schemagrupper är delgrupper och grupper som
	//   används för stödundervisning eller läxhjälp.
	// * _Avdelning_ - Avdelningen är en grupp för placering inom skolformerna
	//   förskola eller fritidshem.
	// * _Personalgrupp_ - En grupp vars medlemmar utgörs av personal.
	// * _Övrigt_ - Övriga grupper är andra grupper som inte är något av ovanstående.
	GroupType GroupTypesEnum `json:"groupType"`

	// Id Identifierare för gruppen
	Id           openapi_types.UUID    `json:"id"`
	Meta         *Meta                 `json:"meta,omitempty"`
	Organisation OrganisationReference `json:"organisation"`

	// SchoolType Följande värden används för att beskriva skolform:
	//   - _FS_ - Förskola
	//   - _FKLASS_ - Förskoleklass
	//   - _FTH_ - Fritidshem
	//   - _OPPFTH_ - Öppen fritidsverksamhet
	//   - _GR_ - Grundskola
	//   - _GRS_ - Grundsärskola
	//   - _TR_ - Träningsskolan
	//   - _SP_ - Specialskola
	//   - _SAM_ - Sameskola
	//   - _GY_ - Gymnasieskola
	//   - _GYS_ - Gymnasiesärskola
	//   - _VUX_ - Kommunal vuxenutbildning
	//   - _VUXSFI_ - Kommunal vuxenutbildning i svenska för invandrare
	//   - _VUXGR_ - Kommunal vuxenutbildning på grundläggande nivå
	//   - _VUXGY_ - Kommunal vuxenutbildning på gymnasial nivå
	//   - _VUXSARGR_ - Kommunal vuxenutbildning som särskild utbildning på grundläggande nivå
	//   - _VUXSARTR_ - Kommunal vuxenutbildning som särskild utbildning som motsvarar träningsskolan
	//   - _VUXSARGY_ - Kommunal vuxenutbildning som särskild utbildning på gymnasial nivå
	//   - _SFI_ - Utbildning i svenska för invandrare
	//   - _SARVUX_ - Särskild utbildning för vuxna
	//   - _SARVUXGR_ - Särskild utbildning för vuxna på grundläggande nivå
	//   - _SARVUXGY_ - Särskild utbildning för vuxna på gymnasial nivå
	//   - _SFI_ - Kommunal vuxenutbildning i svenska för invandrare
	//   - _KU_ - Kulturskola
	//   - _YH_ - Yrkeshögskola
	//   - _FHS_ - Folkhögskola
	//   - _STF_ - Studieförbund
	//   - _KKU_ - Konst- och kulturutbildning
	//   - _HS_ - Högskola
	//   - _ABU_ - Arbetsmarknadsutbildning
	//   - _AU_ - Annan undervisning
	SchoolType *SchoolTypesEnum `json:"schoolType,omitempty"`

	// StartDate Startdatum för gruppens giltighetstid (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	StartDate openapi_types.Date `json:"startDate"`
}

// GroupExpanded defines model for GroupExpanded.
type GroupExpanded struct {
	Embedded *GroupExpandedAllOfEmbedded `json:"_embedded,omitempty"`

	// DisplayName Gruppens benämning.
	DisplayName string `json:"displayName"`

	// EndDate Slutdatum för gruppens giltighetstid (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	EndDate *openapi_types.Date `json:"endDate,omitempty"`

	// GroupMemberships Gruppmedlemskap anger att en person är medlem i en grupp och vilken tidsperiod medlemskapet omfattar.
	GroupMemberships *[]GroupMembership `json:"groupMemberships,omitempty"`

	// GroupType Grupptyp anger vad en grupp ska användas till.
	// Ett värdeförråd för att indikera anger vilka grupptyper som finns.
	// * _Undervisning_ - Undervisningsgruppen är en grupp som har koppling
	//   till ett ämne eller en kurs, och som ska schemaläggas med undervisningstid
	//   ihop med en lärare.
	// * _Klass_ - Klassen är en organisatorisk grupp med elever som är skolplacerade
	//   på en skola med skolform FSK, GR, GRS, SP, SAM, GY eller GYS.
	//   Varje elev ska vara placerad i endast en klass. Klassen kan schemaläggas
	//   med undervisning enligt timplan. "Klassföreståndare" kan beskrivas genom att
	//   koppla en _AssignmentRole_ av typen _Mentor_.
	// * _Mentor_ - Grupp med elever vilka delar samma mentor/mentorer.
	//   Mentor kopplas till gruppen genom en _AssignmentRole_.
	// * _Provgrupp_ - Grupp med elever vilka ska genomföra ett eller flera prov.
	// * _Schema_ - Schemagrupper är grupper som utgör ett komplement till
	//   grupper av typen Undervisning. Schemagrupper ska schemaläggas för att
	//   åstadkomma anpassningar av schemat för enskilda elever eller grupper
	//   av elever. Exempel på schemagrupper är delgrupper och grupper som
	//   används för stödundervisning eller läxhjälp.
	// * _Avdelning_ - Avdelningen är en grupp för placering inom skolformerna
	//   förskola eller fritidshem.
	// * _Personalgrupp_ - En grupp vars medlemmar utgörs av personal.
	// * _Övrigt_ - Övriga grupper är andra grupper som inte är något av ovanstående.
	GroupType GroupTypesEnum `json:"groupType"`

	// Id Identifierare för gruppen
	Id           openapi_types.UUID    `json:"id"`
	Meta         *Meta                 `json:"meta,omitempty"`
	Organisation OrganisationReference `json:"organisation"`

	// SchoolType Följande värden används för att beskriva skolform:
	//   - _FS_ - Förskola
	//   - _FKLASS_ - Förskoleklass
	//   - _FTH_ - Fritidshem
	//   - _OPPFTH_ - Öppen fritidsverksamhet
	//   - _GR_ - Grundskola
	//   - _GRS_ - Grundsärskola
	//   - _TR_ - Träningsskolan
	//   - _SP_ - Specialskola
	//   - _SAM_ - Sameskola
	//   - _GY_ - Gymnasieskola
	//   - _GYS_ - Gymnasiesärskola
	//   - _VUX_ - Kommunal vuxenutbildning
	//   - _VUXSFI_ - Kommunal vuxenutbildning i svenska för invandrare
	//   - _VUXGR_ - Kommunal vuxenutbildning på grundläggande nivå
	//   - _VUXGY_ - Kommunal vuxenutbildning på gymnasial nivå
	//   - _VUXSARGR_ - Kommunal vuxenutbildning som särskild utbildning på grundläggande nivå
	//   - _VUXSARTR_ - Kommunal vuxenutbildning som särskild utbildning som motsvarar träningsskolan
	//   - _VUXSARGY_ - Kommunal vuxenutbildning som särskild utbildning på gymnasial nivå
	//   - _SFI_ - Utbildning i svenska för invandrare
	//   - _SARVUX_ - Särskild utbildning för vuxna
	//   - _SARVUXGR_ - Särskild utbildning för vuxna på grundläggande nivå
	//   - _SARVUXGY_ - Särskild utbildning för vuxna på gymnasial nivå
	//   - _SFI_ - Kommunal vuxenutbildning i svenska för invandrare
	//   - _KU_ - Kulturskola
	//   - _YH_ - Yrkeshögskola
	//   - _FHS_ - Folkhögskola
	//   - _STF_ - Studieförbund
	//   - _KKU_ - Konst- och kulturutbildning
	//   - _HS_ - Högskola
	//   - _ABU_ - Arbetsmarknadsutbildning
	//   - _AU_ - Annan undervisning
	SchoolType *SchoolTypesEnum `json:"schoolType,omitempty"`

	// StartDate Startdatum för gruppens giltighetstid (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	StartDate openapi_types.Date `json:"startDate"`
}

// GroupExpandedAllOf defines model for GroupExpanded_allOf.
type GroupExpandedAllOf struct {
	Embedded *GroupExpandedAllOfEmbedded `json:"_embedded,omitempty"`
}

// GroupExpandedAllOfEmbedded defines model for GroupExpanded_allOf__embedded.
type GroupExpandedAllOfEmbedded struct {
	AssignmentRoles *[]GroupExpandedAllOfEmbeddedAssignmentRoles `json:"assignmentRoles,omitempty"`
}

// GroupExpandedAllOfEmbeddedAssignmentRoles defines model for GroupExpanded_allOf__embedded_assignmentRoles.
type GroupExpandedAllOfEmbeddedAssignmentRoles struct {
	AssignmentRoleType *AssignmentRoleTypeEnum `json:"assignmentRoleType,omitempty"`
	Duty               *DutyReference          `json:"duty,omitempty"`

	// EndDate Slutdatum för tjänstens relation till gruppen (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	EndDate *openapi_types.Date `json:"endDate,omitempty"`

	// StartDate Startdatum för tjänstens relation till gruppen (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	StartDate *openapi_types.Date `json:"startDate,omitempty"`
}

// GroupFragment Group kan innehålla personer eller bara vara en tom "platshållare" utan medlemmar, som kan populeras vid ett senare tillfälle. Notera att gruppens koppling till ämnen/kurser och lärare görs via Aktivitet. Grupper har olika egenskaper baserat på grupptyp. Individer kan ha olika roller i relation till en viss grupp. Grupper har specifika egenskaper.
type GroupFragment struct {
	// DisplayName Gruppens benämning.
	DisplayName string `json:"displayName"`

	// EndDate Slutdatum för gruppens giltighetstid (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	EndDate *openapi_types.Date `json:"endDate,omitempty"`

	// GroupType Grupptyp anger vad en grupp ska användas till.
	// Ett värdeförråd för att indikera anger vilka grupptyper som finns.
	// * _Undervisning_ - Undervisningsgruppen är en grupp som har koppling
	//   till ett ämne eller en kurs, och som ska schemaläggas med undervisningstid
	//   ihop med en lärare.
	// * _Klass_ - Klassen är en organisatorisk grupp med elever som är skolplacerade
	//   på en skola med skolform FSK, GR, GRS, SP, SAM, GY eller GYS.
	//   Varje elev ska vara placerad i endast en klass. Klassen kan schemaläggas
	//   med undervisning enligt timplan. "Klassföreståndare" kan beskrivas genom att
	//   koppla en _AssignmentRole_ av typen _Mentor_.
	// * _Mentor_ - Grupp med elever vilka delar samma mentor/mentorer.
	//   Mentor kopplas till gruppen genom en _AssignmentRole_.
	// * _Provgrupp_ - Grupp med elever vilka ska genomföra ett eller flera prov.
	// * _Schema_ - Schemagrupper är grupper som utgör ett komplement till
	//   grupper av typen Undervisning. Schemagrupper ska schemaläggas för att
	//   åstadkomma anpassningar av schemat för enskilda elever eller grupper
	//   av elever. Exempel på schemagrupper är delgrupper och grupper som
	//   används för stödundervisning eller läxhjälp.
	// * _Avdelning_ - Avdelningen är en grupp för placering inom skolformerna
	//   förskola eller fritidshem.
	// * _Personalgrupp_ - En grupp vars medlemmar utgörs av personal.
	// * _Övrigt_ - Övriga grupper är andra grupper som inte är något av ovanstående.
	GroupType GroupTypesEnum `json:"groupType"`

	// Id Identifierare för gruppen
	Id           openapi_types.UUID    `json:"id"`
	Meta         *Meta                 `json:"meta,omitempty"`
	Organisation OrganisationReference `json:"organisation"`

	// SchoolType Följande värden används för att beskriva skolform:
	//   - _FS_ - Förskola
	//   - _FKLASS_ - Förskoleklass
	//   - _FTH_ - Fritidshem
	//   - _OPPFTH_ - Öppen fritidsverksamhet
	//   - _GR_ - Grundskola
	//   - _GRS_ - Grundsärskola
	//   - _TR_ - Träningsskolan
	//   - _SP_ - Specialskola
	//   - _SAM_ - Sameskola
	//   - _GY_ - Gymnasieskola
	//   - _GYS_ - Gymnasiesärskola
	//   - _VUX_ - Kommunal vuxenutbildning
	//   - _VUXSFI_ - Kommunal vuxenutbildning i svenska för invandrare
	//   - _VUXGR_ - Kommunal vuxenutbildning på grundläggande nivå
	//   - _VUXGY_ - Kommunal vuxenutbildning på gymnasial nivå
	//   - _VUXSARGR_ - Kommunal vuxenutbildning som särskild utbildning på grundläggande nivå
	//   - _VUXSARTR_ - Kommunal vuxenutbildning som särskild utbildning som motsvarar träningsskolan
	//   - _VUXSARGY_ - Kommunal vuxenutbildning som särskild utbildning på gymnasial nivå
	//   - _SFI_ - Utbildning i svenska för invandrare
	//   - _SARVUX_ - Särskild utbildning för vuxna
	//   - _SARVUXGR_ - Särskild utbildning för vuxna på grundläggande nivå
	//   - _SARVUXGY_ - Särskild utbildning för vuxna på gymnasial nivå
	//   - _SFI_ - Kommunal vuxenutbildning i svenska för invandrare
	//   - _KU_ - Kulturskola
	//   - _YH_ - Yrkeshögskola
	//   - _FHS_ - Folkhögskola
	//   - _STF_ - Studieförbund
	//   - _KKU_ - Konst- och kulturutbildning
	//   - _HS_ - Högskola
	//   - _ABU_ - Arbetsmarknadsutbildning
	//   - _AU_ - Annan undervisning
	SchoolType *SchoolTypesEnum `json:"schoolType,omitempty"`

	// StartDate Startdatum för gruppens giltighetstid (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	StartDate openapi_types.Date `json:"startDate"`
}

// GroupMembership defines model for GroupMembership.
type GroupMembership struct {
	// EndDate Slutdatum för personens medlemskap i gruppen (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	EndDate *openapi_types.Date `json:"endDate,omitempty"`
	Person  PersonReference     `json:"person"`

	// StartDate Startdatum för personens medlemskap i gruppen (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	StartDate *openapi_types.Date `json:"startDate,omitempty"`
}

// GroupReference defines model for GroupReference.
type GroupReference struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// GroupTypesEnum Grupptyp anger vad en grupp ska användas till.
// Ett värdeförråd för att indikera anger vilka grupptyper som finns.
// * _Undervisning_ - Undervisningsgruppen är en grupp som har koppling
//   till ett ämne eller en kurs, och som ska schemaläggas med undervisningstid
//   ihop med en lärare.
// * _Klass_ - Klassen är en organisatorisk grupp med elever som är skolplacerade
//   på en skola med skolform FSK, GR, GRS, SP, SAM, GY eller GYS.
//   Varje elev ska vara placerad i endast en klass. Klassen kan schemaläggas
//   med undervisning enligt timplan. "Klassföreståndare" kan beskrivas genom att
//   koppla en _AssignmentRole_ av typen _Mentor_.
// * _Mentor_ - Grupp med elever vilka delar samma mentor/mentorer.
//   Mentor kopplas till gruppen genom en _AssignmentRole_.
// * _Provgrupp_ - Grupp med elever vilka ska genomföra ett eller flera prov.
// * _Schema_ - Schemagrupper är grupper som utgör ett komplement till
//   grupper av typen Undervisning. Schemagrupper ska schemaläggas för att
//   åstadkomma anpassningar av schemat för enskilda elever eller grupper
//   av elever. Exempel på schemagrupper är delgrupper och grupper som
//   används för stödundervisning eller läxhjälp.
// * _Avdelning_ - Avdelningen är en grupp för placering inom skolformerna
//   förskola eller fritidshem.
// * _Personalgrupp_ - En grupp vars medlemmar utgörs av personal.
// * _Övrigt_ - Övriga grupper är andra grupper som inte är något av ovanstående.
type GroupTypesEnum string

// GroupAllOf defines model for Group_allOf.
type GroupAllOf struct {
	// GroupMemberships Gruppmedlemskap anger att en person är medlem i en grupp och vilken tidsperiod medlemskapet omfattar.
	GroupMemberships *[]GroupMembership `json:"groupMemberships,omitempty"`
}

// GroupsExpanded defines model for GroupsExpanded.
type GroupsExpanded struct {
	Data []GroupExpanded `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// GroupsExpandedArray defines model for GroupsExpandedArray.
type GroupsExpandedArray = []GroupExpanded

// IdLookup defines model for IdLookup.
type IdLookup struct {
	Ids *[]openapi_types.UUID `json:"ids,omitempty"`
}

// LogEntry Information runt en händelse, används för att återsända information för att avhjälpa vid olika typer av felsökning.
type LogEntry struct {
	// Message Situationssepcifik text rörande loggad händelse.
	Message string `json:"message"`

	// MessageType Hos klienten unikt ID på meddelandetypen
	MessageType *string `json:"messageType,omitempty"`

	// ResourceId Eventuellt id relaterat till loggad händelse.
	ResourceId   *openapi_types.UUID `json:"resourceId,omitempty"`
	ResourceType *EndPointsEnum      `json:"resourceType,omitempty"`

	// ResourceUrl Eventuell url till relaterad fråga som låg till grund till loggad händelse.
	ResourceUrl *string `json:"resourceUrl,omitempty"`

	// SeverityLevel Loggad händelses allvarlighetsgrad.
	// * _Info_ - Händelse som ej är ett problem men kan vara bra att veta vid felsökning.
	// * _Warning_ - Behöver uppmärksammas, eventuellt problem.
	// * _Error_ - Problem som kärver någon typ av åtgärd.
	SeverityLevel LogEntrySeverityLevel `json:"severityLevel"`

	// TimeOfOccurance Tidpunkt för loggad händelse.
	TimeOfOccurance *time.Time `json:"timeOfOccurance,omitempty"`
}

// LogEntrySeverityLevel Loggad händelses allvarlighetsgrad.
// * _Info_ - Händelse som ej är ett problem men kan vara bra att veta vid felsökning.
// * _Warning_ - Behöver uppmärksammas, eventuellt problem.
// * _Error_ - Problem som kärver någon typ av åtgärd.
type LogEntrySeverityLevel string

// Meta defines model for Meta.
type Meta struct {
	// Created Datum och tid för när entiteten skapades (RFC 3339 format tex "2015-12-12T10:30:00+01:00").
	Created time.Time `json:"created"`

	// Modified Datum och tid för när entiteten senast uppdaterades (RFC 3339 format tex "2015-12-12T10:30:00+01:00"). Tidpunkten avser den senaste tidpunkt när något av de attribut som direkt tillhör entiteten har ändrats. Attribut som kan tas fram med parametrarna expand eller expandReferenceNames räknas **inte** som ett attribut till entiteten, och ska således **inte** påverka detta värde.
	Modified time.Time `json:"modified"`
}

// ObjectReference defines model for ObjectReference.
type ObjectReference struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// Organisation En skolhuvudman eller annan slags organisatorisk enhet.
type Organisation struct {
	// Address Organisationens postadress
	Address     *OrganisationAddress `json:"address,omitempty"`
	ContactInfo *[]ContactInfo       `json:"contactInfo,omitempty"`

	// DisplayName Namn på organisationen
	DisplayName string `json:"displayName"`

	// Email Epost-adress till skolan eller organisationselementet.
	Email *openapi_types.Email `json:"email,omitempty"`

	// EndDate Slutdatum för organisationensdelens giltighetstid (RFC 3339-format, t.ex. "2016-10-15"). Gäller för alla underliggande element som inte har ett mer restrektivt värde. Inkluderande.
	EndDate *openapi_types.Date `json:"endDate,omitempty"`
	Id      openapi_types.UUID  `json:"id"`
	Meta    *Meta               `json:"meta,omitempty"`

	// MunicipalityCode Kommunkod. Län och kommunkod för den kommun där skolan är belägen, exempelvis 0180 där 01 anger länet och 80 anger kommunen.
	MunicipalityCode *string `json:"municipalityCode,omitempty"`

	// OrganisationCode En kod för att identifiera organisationselementet inom organisationen.
	OrganisationCode *string `json:"organisationCode,omitempty"`

	// OrganisationNumber Identitetsbeteckning för juridiska personer såsom kommun eller bolag
	OrganisationNumber *string `json:"organisationNumber,omitempty"`

	// OrganisationType Typ av organisation. Notera att Stadsdel är deprekerad och kommer tas bort i nästa version. Rimlig synonym är Förvaltning.
	OrganisationType   OrganisationTypeEnum            `json:"organisationType"`
	ParentOrganisation *OrganisationParentOrganisation `json:"parentOrganisation,omitempty"`

	// PhoneNumber Telefonnummer till en skolan eller organisationselementet.
	PhoneNumber *string `json:"phoneNumber,omitempty"`

	// SchoolTypes Anges endas för organisationselement typen Skolenhet.
	SchoolTypes *[]SchoolTypesEnum `json:"schoolTypes,omitempty"`

	// SchoolUnitCode Skolenhetskod. Identifierare för skolenheten enligt Skolverket. Används för de skolformer där skolverket bestämmer en skolenhetskod för varje enhet.
	SchoolUnitCode *string `json:"schoolUnitCode,omitempty"`

	// StartDate Startdatum för organisationensdelens giltighetstid (RFC 3339-format, t.ex. "2016-10-15"). Gäller för alla underliggande element som inte har ett mer restrektivt värde. Inkluderande.
	StartDate *openapi_types.Date `json:"startDate,omitempty"`

	// Url Länk till en websida med information om skolan eller organisationselementet.
	Url *string `json:"url,omitempty"`
}

// OrganisationReference defines model for OrganisationReference.
type OrganisationReference struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// OrganisationTypeEnum Typ av organisation. Notera att Stadsdel är deprekerad och kommer tas bort i nästa version. Rimlig synonym är Förvaltning.
type OrganisationTypeEnum string

// OrganisationAddress Organisationens postadress
type OrganisationAddress struct {
	// Country Land.
	Country *string `json:"country,omitempty"`

	// CountyCode Län, kod
	CountyCode *int `json:"countyCode,omitempty"`

	// Locality Postort.
	Locality string `json:"locality"`

	// MunicipalityCode Kommun, kod
	MunicipalityCode *int `json:"municipalityCode,omitempty"`

	// PostalCode Postadress.
	PostalCode string `json:"postalCode"`

	// RealEstateDesignation Fastighetsbeteckning
	RealEstateDesignation *string `json:"realEstateDesignation,omitempty"`

	// StreetAddress Gatuadress.
	StreetAddress string                   `json:"streetAddress"`
	Type          *OrganisationAddressType `json:"type,omitempty"`
}

// OrganisationAddressType defines model for OrganisationAddress.Type.
type OrganisationAddressType string

// OrganisationParentOrganisation defines model for Organisation_parentOrganisation.
type OrganisationParentOrganisation struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// Organisations defines model for Organisations.
type Organisations struct {
	Data []Organisation `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// OrganisationsArray defines model for OrganisationsArray.
type OrganisationsArray = []Organisation

// Person defines model for Person.
type Person struct {
	// Addresses En lista med personens postadresser
	Addresses *[]PersonAddressesInner `json:"addresses,omitempty"`

	// BirthDate Födelsedatum (RFC 3339-format, t.ex. "2016-10-15")
	BirthDate *openapi_types.Date `json:"birthDate,omitempty"`

	// CivicNo Personnummer.
	CivicNo *PersonCivicNo `json:"civicNo,omitempty"`

	// EduPersonPrincipalNames De identifierare som ska användas för att identifiera användaren i skilda e-tjänster. Identifieraren ska vara en spårbar, persistent och globalt unik sträng. Den ska bestå av en lokalt unik användaridentifierare, ett ’@’ och en domän. En domän är ofta, men inte nödvändigtvis, samma som organisationens internet-domännamn. _Exempel: kalko@edu.goteborg.se_
	EduPersonPrincipalNames *[]string `json:"eduPersonPrincipalNames,omitempty"`

	// Emails En lista med personens epostadresser
	Emails *[]Email `json:"emails,omitempty"`

	// Enrolments En lista med inskrivningar för personen
	Enrolments          *[]Enrolment          `json:"enrolments,omitempty"`
	ExternalIdentifiers *[]ExternalIdentifier `json:"externalIdentifiers,omitempty"`

	// FamilyName Efternamn.
	FamilyName string `json:"familyName"`

	// GivenName Förnamn.
	GivenName string `json:"givenName"`

	// Id Ett objekt ska ha samma överförings-ID mellan samtliga ingående system och således är det ett enda namespace för de gemensamma ID:na. Objektidentifikatorn är den nyckel som skall vara persistent mellan olika processer (enl figur 1).
	Id   openapi_types.UUID `json:"id"`
	Meta *Meta              `json:"meta,omitempty"`

	// MiddleName Mellannamn.
	MiddleName *string `json:"middleName,omitempty"`

	// PersonStatus Anger ifall en person har en aktiv status eller en annan status, såsom utvandrad eller avliden.
	PersonStatus *PersonPersonStatus `json:"personStatus,omitempty"`

	// PhoneNumbers En lista med telefonnummer till personen.
	PhoneNumbers *[]Phonenumber `json:"phoneNumbers,omitempty"`

	// Photo Pekar ut en resurs med en bild på personen, specificeras som en URI enligt RFC 3986.
	Photo *string `json:"photo,omitempty"`

	// Responsibles Personens vårdnadshavare eller motsvarande relationer så som familjehemsförälder. Denna relation beskriver ett officiellt ansvarsförhållande.
	Responsibles *[]PersonResponsiblesInner `json:"responsibles,omitempty"`

	// SecurityMarking Återspeglar värdet från folkbokföringsregistret.
	SecurityMarking *PersonSecurityMarking `json:"securityMarking,omitempty"`

	// Sex Biologiskt kön
	Sex *PersonSex `json:"sex,omitempty"`
}

// PersonPersonStatus Anger ifall en person har en aktiv status eller en annan status, såsom utvandrad eller avliden.
type PersonPersonStatus string

// PersonSecurityMarking Återspeglar värdet från folkbokföringsregistret.
type PersonSecurityMarking string

// PersonSex Biologiskt kön
type PersonSex string

// PersonExpanded defines model for PersonExpanded.
type PersonExpanded struct {
	Embedded *PersonExpandedAllOfEmbedded `json:"_embedded,omitempty"`

	// Addresses En lista med personens postadresser
	Addresses *[]PersonAddressesInner `json:"addresses,omitempty"`

	// BirthDate Födelsedatum (RFC 3339-format, t.ex. "2016-10-15")
	BirthDate *openapi_types.Date `json:"birthDate,omitempty"`

	// CivicNo Personnummer.
	CivicNo *PersonCivicNo `json:"civicNo,omitempty"`

	// EduPersonPrincipalNames De identifierare som ska användas för att identifiera användaren i skilda e-tjänster. Identifieraren ska vara en spårbar, persistent och globalt unik sträng. Den ska bestå av en lokalt unik användaridentifierare, ett ’@’ och en domän. En domän är ofta, men inte nödvändigtvis, samma som organisationens internet-domännamn. _Exempel: kalko@edu.goteborg.se_
	EduPersonPrincipalNames *[]string `json:"eduPersonPrincipalNames,omitempty"`

	// Emails En lista med personens epostadresser
	Emails *[]Email `json:"emails,omitempty"`

	// Enrolments En lista med inskrivningar för personen
	Enrolments          *[]Enrolment          `json:"enrolments,omitempty"`
	ExternalIdentifiers *[]ExternalIdentifier `json:"externalIdentifiers,omitempty"`

	// FamilyName Efternamn.
	FamilyName string `json:"familyName"`

	// GivenName Förnamn.
	GivenName string `json:"givenName"`

	// Id Ett objekt ska ha samma överförings-ID mellan samtliga ingående system och således är det ett enda namespace för de gemensamma ID:na. Objektidentifikatorn är den nyckel som skall vara persistent mellan olika processer (enl figur 1).
	Id   openapi_types.UUID `json:"id"`
	Meta *Meta              `json:"meta,omitempty"`

	// MiddleName Mellannamn.
	MiddleName *string `json:"middleName,omitempty"`

	// PersonStatus Anger ifall en person har en aktiv status eller en annan status, såsom utvandrad eller avliden.
	PersonStatus *PersonExpandedPersonStatus `json:"personStatus,omitempty"`

	// PhoneNumbers En lista med telefonnummer till personen.
	PhoneNumbers *[]Phonenumber `json:"phoneNumbers,omitempty"`

	// Photo Pekar ut en resurs med en bild på personen, specificeras som en URI enligt RFC 3986.
	Photo *string `json:"photo,omitempty"`

	// Responsibles Personens vårdnadshavare eller motsvarande relationer så som familjehemsförälder. Denna relation beskriver ett officiellt ansvarsförhållande.
	Responsibles *[]PersonResponsiblesInner `json:"responsibles,omitempty"`

	// SecurityMarking Återspeglar värdet från folkbokföringsregistret.
	SecurityMarking *PersonExpandedSecurityMarking `json:"securityMarking,omitempty"`

	// Sex Biologiskt kön
	Sex *PersonExpandedSex `json:"sex,omitempty"`
}

// PersonExpandedPersonStatus Anger ifall en person har en aktiv status eller en annan status, såsom utvandrad eller avliden.
type PersonExpandedPersonStatus string

// PersonExpandedSecurityMarking Återspeglar värdet från folkbokföringsregistret.
type PersonExpandedSecurityMarking string

// PersonExpandedSex Biologiskt kön
type PersonExpandedSex string

// PersonExpandedAllOf defines model for PersonExpanded_allOf.
type PersonExpandedAllOf struct {
	Embedded *PersonExpandedAllOfEmbedded `json:"_embedded,omitempty"`
}

// PersonExpandedAllOfEmbedded defines model for PersonExpanded_allOf__embedded.
type PersonExpandedAllOfEmbedded struct {
	// Duties Personens aktuella tjänstgöring
	Duties *[]Duty `json:"duties,omitempty"`

	// GroupMemberships En lista med grupper där personen är medlem i
	GroupMemberships *[]PersonExpandedAllOfEmbeddedGroupMemberships `json:"groupMemberships,omitempty"`

	// OwnedPlacements En lista med placeringar där personen är satt som ägare.
	OwnedPlacements *[]Placement `json:"ownedPlacements,omitempty"`

	// Placements En lista med placeringar för personen.
	Placements *[]Placement `json:"placements,omitempty"`

	// ResponsibleFor De barn/barnen vilka personen har ansvar för.
	ResponsibleFor *[]PersonResponsiblesInner `json:"responsibleFor,omitempty"`
}

// PersonExpandedAllOfEmbeddedGroupMemberships defines model for PersonExpanded_allOf__embedded_groupMemberships.
type PersonExpandedAllOfEmbeddedGroupMemberships struct {
	// EndDate Slutdatum för personens medlemskap i gruppen (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	EndDate *openapi_types.Date `json:"endDate,omitempty"`

	// Group Group kan innehålla personer eller bara vara en tom "platshållare" utan medlemmar, som kan populeras vid ett senare tillfälle. Notera att gruppens koppling till ämnen/kurser och lärare görs via Aktivitet. Grupper har olika egenskaper baserat på grupptyp. Individer kan ha olika roller i relation till en viss grupp. Grupper har specifika egenskaper.
	Group *GroupFragment `json:"group,omitempty"`

	// StartDate Startdatum för personens medlemskap i gruppen (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	StartDate *openapi_types.Date `json:"startDate,omitempty"`
}

// PersonReference defines model for PersonReference.
type PersonReference struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`

	// SecurityMarking Återspeglar värdet från folkbokföringsregistret.
	SecurityMarking *PersonReferenceSecurityMarking `json:"securityMarking,omitempty"`
}

// PersonReferenceSecurityMarking Återspeglar värdet från folkbokföringsregistret.
type PersonReferenceSecurityMarking string

// PersonReference1 Referens till en person
type PersonReference1 struct {
	// SecurityMarking Återspeglar värdet från folkbokföringsregistret.
	SecurityMarking *PersonReference1SecurityMarking `json:"securityMarking,omitempty"`
}

// PersonReference1SecurityMarking Återspeglar värdet från folkbokföringsregistret.
type PersonReference1SecurityMarking string

// PersonAddressesInner defines model for Person_addresses_inner.
type PersonAddressesInner struct {
	// Country Land.
	Country string `json:"country"`

	// CountyCode Län, kod
	CountyCode *int `json:"countyCode,omitempty"`

	// Locality Postort.
	Locality string `json:"locality"`

	// MunicipalityCode Kommun, kod
	MunicipalityCode *int `json:"municipalityCode,omitempty"`

	// PostalCode Postadress.
	PostalCode string `json:"postalCode"`

	// RealEstateDesignation Fastighetsbeteckning
	RealEstateDesignation *string `json:"realEstateDesignation,omitempty"`

	// StreetAddress Gatuadress.
	StreetAddress string                    `json:"streetAddress"`
	Type          *PersonAddressesInnerType `json:"type,omitempty"`
}

// PersonAddressesInnerType defines model for PersonAddressesInner.Type.
type PersonAddressesInnerType string

// PersonCivicNo Personnummer.
type PersonCivicNo struct {
	// Nationality Landskod för det land som personnumret härstammar från, enligt ISO 3166-1 alpha-2.
	Nationality *string `json:"nationality,omitempty"`

	// Value Svenskt personnummer, tilldelat personnummer eller Skatteverkets
	// samordningsnummer för personen. **Ska** anges med 12 siffror utan
	// separatorer. _Exempel: 200112240123_
	//
	// Samordningsnummer ska anges med 12 siffror utan separator.
	// Födelsedagen adderas med talet 60, det vill säga någon född den 24
	// i en månad får talet 84 som dag. _Exempel: 200112840123_
	//
	// Saknas både personnummer och samordningsnummer så förekommer det att
	// "tillfälligt personnummer" definieras i elevregistret. Dessa är möjliga
	// att beskriva i detta fält och i så fall tillåts de två första positionerna
	// efter datumdelen att vara bokstäver. _Exempel: 20130101TF01_
	Value string `json:"value"`
}

// PersonResponsiblesInner defines model for Person_responsibles_inner.
type PersonResponsiblesInner struct {
	Person *PersonReference `json:"person,omitempty"`

	// RelationType Värdeförråd som skall användas för olika typer av relationer till ett barn eller en elev.
	RelationType *RelationTypesEnum `json:"relationType,omitempty"`
}

// PersonsExpanded defines model for PersonsExpanded.
type PersonsExpanded struct {
	Data []PersonExpanded `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// PersonsExpandedArray defines model for PersonsExpandedArray.
type PersonsExpandedArray = []PersonExpanded

// Phonenumber defines model for Phonenumber.
type Phonenumber struct {
	Mobile bool            `json:"mobile"`
	Type   PhonenumberType `json:"type"`

	// Value Telefonnumret.
	Value string `json:"value"`
}

// PhonenumberType defines model for Phonenumber.Type.
type PhonenumberType string

// Placement defines model for Placement.
type Placement struct {
	Child PlacementChild `json:"child"`

	// EndDate Slutdatum för placeringen (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	EndDate *openapi_types.Date `json:"endDate,omitempty"`
	Group   *PlacementGroup     `json:"group,omitempty"`
	Id      openapi_types.UUID  `json:"id"`

	// MaxWeeklyScheduleHours Anger maximal schematid per vecka för barnets placering.
	MaxWeeklyScheduleHours *int  `json:"maxWeeklyScheduleHours,omitempty"`
	Meta                   *Meta `json:"meta,omitempty"`

	// Owners En lista med identifierare för de personer som äger placeringen. Används primärt för att styra vilka som skall kunna se och lägga schema.
	Owners   *[]PersonReference `json:"owners,omitempty"`
	PlacedAt PlacementPlacedAt  `json:"placedAt"`

	// Reason En kod för att beskriva orsak för placeringen.
	Reason *PlacementReason `json:"reason,omitempty"`

	// SchoolType Skolform för placeringen, förskola eller fritidshem
	SchoolType PlacementSchoolType `json:"schoolType"`

	// StartDate Startdatum för placeringen (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	StartDate openapi_types.Date `json:"startDate"`
}

// PlacementReason En kod för att beskriva orsak för placeringen.
type PlacementReason string

// PlacementSchoolType Skolform för placeringen, förskola eller fritidshem
type PlacementSchoolType string

// PlacementExpanded defines model for PlacementExpanded.
type PlacementExpanded struct {
	Embedded *PlacementExpandedAllOfEmbedded `json:"_embedded,omitempty"`
	Child    PlacementChild                  `json:"child"`

	// EndDate Slutdatum för placeringen (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	EndDate *openapi_types.Date `json:"endDate,omitempty"`
	Group   *PlacementGroup     `json:"group,omitempty"`
	Id      openapi_types.UUID  `json:"id"`

	// MaxWeeklyScheduleHours Anger maximal schematid per vecka för barnets placering.
	MaxWeeklyScheduleHours *int  `json:"maxWeeklyScheduleHours,omitempty"`
	Meta                   *Meta `json:"meta,omitempty"`

	// Owners En lista med identifierare för de personer som äger placeringen. Används primärt för att styra vilka som skall kunna se och lägga schema.
	Owners   *[]PersonReference `json:"owners,omitempty"`
	PlacedAt PlacementPlacedAt  `json:"placedAt"`

	// Reason En kod för att beskriva orsak för placeringen.
	Reason *PlacementExpandedReason `json:"reason,omitempty"`

	// SchoolType Skolform för placeringen, förskola eller fritidshem
	SchoolType PlacementExpandedSchoolType `json:"schoolType"`

	// StartDate Startdatum för placeringen (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	StartDate openapi_types.Date `json:"startDate"`
}

// PlacementExpandedReason En kod för att beskriva orsak för placeringen.
type PlacementExpandedReason string

// PlacementExpandedSchoolType Skolform för placeringen, förskola eller fritidshem
type PlacementExpandedSchoolType string

// PlacementExpandedAllOf defines model for PlacementExpanded_allOf.
type PlacementExpandedAllOf struct {
	Embedded *PlacementExpandedAllOfEmbedded `json:"_embedded,omitempty"`
}

// PlacementExpandedAllOfEmbedded defines model for PlacementExpanded_allOf__embedded.
type PlacementExpandedAllOfEmbedded struct {
	Child  *Person   `json:"child,omitempty"`
	Owners *[]Person `json:"owners,omitempty"`
}

// PlacementReference defines model for PlacementReference.
type PlacementReference struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// PlacementChild defines model for Placement_child.
type PlacementChild struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`

	// SecurityMarking Återspeglar värdet från folkbokföringsregistret.
	SecurityMarking *PlacementChildSecurityMarking `json:"securityMarking,omitempty"`
}

// PlacementChildSecurityMarking Återspeglar värdet från folkbokföringsregistret.
type PlacementChildSecurityMarking string

// PlacementGroup defines model for Placement_group.
type PlacementGroup struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// PlacementPlacedAt defines model for Placement_placedAt.
type PlacementPlacedAt struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// Placements defines model for Placements.
type Placements struct {
	Data []PlacementExpanded `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// PlacementsArray defines model for PlacementsArray.
type PlacementsArray = []PlacementExpanded

// Programme Ett program av kurser.
type Programme struct {
	// Code Program-/inriktningskod(studievägskod). För gymnasieskolans program/inriktningar måste denna finnas och vara enligt Skolverkets definition.
	Code *string `json:"code,omitempty"`

	// Content Kurser/ämnen som ingår i utbildningen.
	Content *[]ProgrammeContentInner `json:"content,omitempty"`

	// Id Identifierare för programmet.
	Id   openapi_types.UUID `json:"id"`
	Meta *Meta              `json:"meta,omitempty"`

	// Name Program-/inriktningens namn.
	Name            string                    `json:"name"`
	ParentProgramme *ProgrammeParentProgramme `json:"parentProgramme,omitempty"`

	// SchoolType Följande värden används för att beskriva skolform:
	//   - _FS_ - Förskola
	//   - _FKLASS_ - Förskoleklass
	//   - _FTH_ - Fritidshem
	//   - _OPPFTH_ - Öppen fritidsverksamhet
	//   - _GR_ - Grundskola
	//   - _GRS_ - Grundsärskola
	//   - _TR_ - Träningsskolan
	//   - _SP_ - Specialskola
	//   - _SAM_ - Sameskola
	//   - _GY_ - Gymnasieskola
	//   - _GYS_ - Gymnasiesärskola
	//   - _VUX_ - Kommunal vuxenutbildning
	//   - _VUXSFI_ - Kommunal vuxenutbildning i svenska för invandrare
	//   - _VUXGR_ - Kommunal vuxenutbildning på grundläggande nivå
	//   - _VUXGY_ - Kommunal vuxenutbildning på gymnasial nivå
	//   - _VUXSARGR_ - Kommunal vuxenutbildning som särskild utbildning på grundläggande nivå
	//   - _VUXSARTR_ - Kommunal vuxenutbildning som särskild utbildning som motsvarar träningsskolan
	//   - _VUXSARGY_ - Kommunal vuxenutbildning som särskild utbildning på gymnasial nivå
	//   - _SFI_ - Utbildning i svenska för invandrare
	//   - _SARVUX_ - Särskild utbildning för vuxna
	//   - _SARVUXGR_ - Särskild utbildning för vuxna på grundläggande nivå
	//   - _SARVUXGY_ - Särskild utbildning för vuxna på gymnasial nivå
	//   - _SFI_ - Kommunal vuxenutbildning i svenska för invandrare
	//   - _KU_ - Kulturskola
	//   - _YH_ - Yrkeshögskola
	//   - _FHS_ - Folkhögskola
	//   - _STF_ - Studieförbund
	//   - _KKU_ - Konst- och kulturutbildning
	//   - _HS_ - Högskola
	//   - _ABU_ - Arbetsmarknadsutbildning
	//   - _AU_ - Annan undervisning
	SchoolType SchoolTypesEnum `json:"schoolType"`

	// Type Typ av program.
	Type ProgrammeType `json:"type"`
}

// ProgrammeType Typ av program.
type ProgrammeType string

// ProgrammeReference defines model for ProgrammeReference.
type ProgrammeReference struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// ProgrammeContentInner defines model for Programme_content_inner.
type ProgrammeContentInner struct {
	Content *[]ProgrammeContentInnerContentInner `json:"content,omitempty"`

	// Points Poäng för innehållstypen i förekommande fall.
	Points *int `json:"points,omitempty"`

	// Type Anger ingående kursers relation till programmet, såsom Programgemensamma. Typen _Inriktning_ kan endast anges för program av typen _Programinriktning_.
	Type ProgrammeContentInnerType `json:"type"`
}

// ProgrammeContentInnerType Anger ingående kursers relation till programmet, såsom Programgemensamma. Typen _Inriktning_ kan endast anges för program av typen _Programinriktning_.
type ProgrammeContentInnerType string

// ProgrammeContentInnerContentInner defines model for Programme_content_inner_content_inner.
type ProgrammeContentInnerContentInner struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// ProgrammeParentProgramme defines model for Programme_parentProgramme.
type ProgrammeParentProgramme struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// Programmes defines model for Programmes.
type Programmes struct {
	Data []Programme `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// ProgrammesArray defines model for ProgrammesArray.
type ProgrammesArray = []Programme

// RelationTypesEnum Värdeförråd som skall användas för olika typer av relationer till ett barn eller en elev.
type RelationTypesEnum string

// Resource defines model for Resource.
type Resource struct {
	// Description Beskrivning av resursen.
	Description *string `json:"description,omitempty"`

	// DisplayName Namn på resursen.
	DisplayName string                `json:"displayName"`
	Id          openapi_types.UUID    `json:"id"`
	Meta        *Meta                 `json:"meta,omitempty"`
	Owner       OrganisationReference `json:"owner"`
}

// Resources defines model for Resources.
type Resources struct {
	Data []Resource `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// ResourcesArray defines model for ResourcesArray.
type ResourcesArray = []Resource

// Room Ett rum eller en plats som kan bokas i ett skolschema.
type Room struct {
	// DisplayName Namn på rum/lokal/plats.
	DisplayName string                `json:"displayName"`
	Id          openapi_types.UUID    `json:"id"`
	Meta        *Meta                 `json:"meta,omitempty"`
	Owner       OrganisationReference `json:"owner"`

	// Seats Antal platser i lokalen.
	Seats *int `json:"seats,omitempty"`
}

// Rooms defines model for Rooms.
type Rooms struct {
	Data []Room `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// RoomsArray defines model for RoomsArray.
type RoomsArray = []Room

// SchoolTypesEnum Följande värden används för att beskriva skolform:
//   - _FS_ - Förskola
//   - _FKLASS_ - Förskoleklass
//   - _FTH_ - Fritidshem
//   - _OPPFTH_ - Öppen fritidsverksamhet
//   - _GR_ - Grundskola
//   - _GRS_ - Grundsärskola
//   - _TR_ - Träningsskolan
//   - _SP_ - Specialskola
//   - _SAM_ - Sameskola
//   - _GY_ - Gymnasieskola
//   - _GYS_ - Gymnasiesärskola
//   - _VUX_ - Kommunal vuxenutbildning
//   - _VUXSFI_ - Kommunal vuxenutbildning i svenska för invandrare
//   - _VUXGR_ - Kommunal vuxenutbildning på grundläggande nivå
//   - _VUXGY_ - Kommunal vuxenutbildning på gymnasial nivå
//   - _VUXSARGR_ - Kommunal vuxenutbildning som särskild utbildning på grundläggande nivå
//   - _VUXSARTR_ - Kommunal vuxenutbildning som särskild utbildning som motsvarar träningsskolan
//   - _VUXSARGY_ - Kommunal vuxenutbildning som särskild utbildning på gymnasial nivå
//   - _SFI_ - Utbildning i svenska för invandrare
//   - _SARVUX_ - Särskild utbildning för vuxna
//   - _SARVUXGR_ - Särskild utbildning för vuxna på grundläggande nivå
//   - _SARVUXGY_ - Särskild utbildning för vuxna på gymnasial nivå
//   - _SFI_ - Kommunal vuxenutbildning i svenska för invandrare
//   - _KU_ - Kulturskola
//   - _YH_ - Yrkeshögskola
//   - _FHS_ - Folkhögskola
//   - _STF_ - Studieförbund
//   - _KKU_ - Konst- och kulturutbildning
//   - _HS_ - Högskola
//   - _ABU_ - Arbetsmarknadsutbildning
//   - _AU_ - Annan undervisning
type SchoolTypesEnum string

// SchoolUnitOffering Används för att beskriva vilka program, ämnen och kurser en skolenhet erbjuder under ett visst tidsintervall.
type SchoolUnitOffering struct {
	// EndDate Slutdatum för när uppsättningen av program/kurser erbjuds vid skolan. Ett angivet datum innebär att utbudet inte längre är giltigt efter angivet datum. (RFC 3339-format, t.ex. "2016-10-15").
	EndDate           *openapi_types.Date                        `json:"endDate,omitempty"`
	OfferedAt         SchoolUnitOfferingOfferedAt                `json:"offeredAt"`
	OfferedProgrammes *[]ProgrammeReference                      `json:"offeredProgrammes,omitempty"`
	OfferedSyllabuses []SchoolUnitOfferingOfferedSyllabusesInner `json:"offeredSyllabuses"`

	// StartDate Startdatum för när uppsättningen av program/kurser erbjuds vid skolan. (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	StartDate *openapi_types.Date `json:"startDate,omitempty"`
}

// SchoolUnitOfferingOfferedAt defines model for SchoolUnitOffering_offeredAt.
type SchoolUnitOfferingOfferedAt struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// SchoolUnitOfferingOfferedSyllabusesInner defines model for SchoolUnitOffering_offeredSyllabuses_inner.
type SchoolUnitOfferingOfferedSyllabusesInner struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// SchoolUnitOfferings defines model for SchoolUnitOfferings.
type SchoolUnitOfferings struct {
	Data []SchoolUnitOffering `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// SchoolUnitOfferingsArray defines model for SchoolUnitOfferingsArray.
type SchoolUnitOfferingsArray = []SchoolUnitOffering

// SchoolUnitReference defines model for SchoolUnitReference.
type SchoolUnitReference struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// SpecialisationCourseContent Beskrivning av innehållet i en specialiseringskurs på gymnasiet.
type SpecialisationCourseContent struct {
	// Description Beskrivning av specialiseringskurs.
	Description string `json:"description"`

	// DescriptionEnglish Eventuell engelsk beskrivning av specialiseringskurs.
	DescriptionEnglish *string `json:"descriptionEnglish,omitempty"`

	// Title Titel på specialiseringskurs.
	Title string `json:"title"`

	// TitleEnglish Eventuell engelsk titel på specialiseringskurs.
	TitleEnglish *string `json:"titleEnglish,omitempty"`
}

// StatisticsEntry Statistik rörande objekt synkronisering.
type StatisticsEntry struct {
	// DeletedCount Antalet raderade objekt hos klienten.
	DeletedCount int `json:"deletedCount"`

	// NewCount Antalet nya objekt skapade hos klienten.
	NewCount     int           `json:"newCount"`
	ResourceType EndPointsEnum `json:"resourceType"`

	// ResourceUrl Eventuell url för relaterad fråga som låg till grund för synkroniserade objekt.
	ResourceUrl *string `json:"resourceUrl,omitempty"`

	// TimeOfOccurance Tidpunkt för loggad händelse.
	TimeOfOccurance *time.Time `json:"timeOfOccurance,omitempty"`

	// UpdatedCount Antalet uppdaterade objekt hos klienten.
	UpdatedCount int `json:"updatedCount"`
}

// StudentException Anger avvikelser beträffande elevs deltagande, tid och längd för ett enstaka kalendertillfälle.
type StudentException struct {
	// EndTime Sluttid för undantaget (RFC 3339 format tex "2015-12-12T11:00:00+01:00").
	EndTime *time.Time `json:"endTime,omitempty"`

	// Participates Används för att ange om en elev deltar på ett visst kalendertillfälle.
	Participates bool `json:"participates"`

	// StartTime Starttid för undantaget (RFC 3339 format tex "2015-12-12T10:30:00+01:00").
	StartTime *time.Time      `json:"startTime,omitempty"`
	Student   PersonReference `json:"student"`

	// TeachingLength Undervisningstid i minuter för eleven. Om den ej anges så gäller det som är angivet i, i första hand, CalendarEvent, och annars i Activity.
	TeachingLength *int `json:"teachingLength,omitempty"`
}

// StudyPlan En elevs studieplan
type StudyPlan struct {
	Content *[]StudyPlanContent `json:"content,omitempty"`

	// EndDate Slutdatum för studieplanen  (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	EndDate *openapi_types.Date `json:"endDate,omitempty"`
	Id      openapi_types.UUID  `json:"id"`
	Meta    *Meta               `json:"meta,omitempty"`
	Notes   *[]StudyPlanNotes   `json:"notes,omitempty"`

	// StartDate Startdatum för studieplanen (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	StartDate openapi_types.Date `json:"startDate"`
	Student   StudyPlanStudent   `json:"student"`
}

// StudyPlanContent defines model for StudyPlanContent.
type StudyPlanContent struct {
	// Points Anger poängtalet för den aktuella kategorin av kurser
	Points     *int                `json:"points,omitempty"`
	Syllabuses []StudyPlanSyllabus `json:"syllabuses"`

	// Title Anger rubriken i elevens studieplan
	Title *string               `json:"title,omitempty"`
	Type  *StudyPlanContentType `json:"type,omitempty"`
}

// StudyPlanContentType defines model for StudyPlanContent.Type.
type StudyPlanContentType string

// StudyPlanNotes defines model for StudyPlanNotes.
type StudyPlanNotes struct {
	Note string             `json:"note"`
	Type StudyPlanNotesType `json:"type"`
}

// StudyPlanNotesType defines model for StudyPlanNotes.Type.
type StudyPlanNotesType string

// StudyPlanSyllabus defines model for StudyPlanSyllabus.
type StudyPlanSyllabus struct {
	// EndDate Slutdatum för när eleven läser kursen (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	EndDate *openapi_types.Date `json:"endDate,omitempty"`

	// Hours Planlagda timmar för elevens deltagande i kursen. Främst avsedd för studieplaner till vuxenutbildning.
	Hours *int `json:"hours,omitempty"`

	// Note Notering angående kursens status i elevens studieplan
	Note *string `json:"note,omitempty"`

	// StartDate Startdatum när eleven läser kursen (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	StartDate *openapi_types.Date `json:"startDate,omitempty"`
	Syllabus  SyllabusReference   `json:"syllabus"`
}

// StudyPlanStudent defines model for StudyPlan_student.
type StudyPlanStudent struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`

	// SecurityMarking Återspeglar värdet från folkbokföringsregistret.
	SecurityMarking *StudyPlanStudentSecurityMarking `json:"securityMarking,omitempty"`
}

// StudyPlanStudentSecurityMarking Återspeglar värdet från folkbokföringsregistret.
type StudyPlanStudentSecurityMarking string

// StudyPlans defines model for StudyPlans.
type StudyPlans struct {
	Data []StudyPlan `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// Subscription defines model for Subscription.
type Subscription struct {
	Expires time.Time          `json:"expires"`
	Id      openapi_types.UUID `json:"id"`

	// Name Ett beskrivande namn på webhook:en.
	Name          string                                 `json:"name"`
	ResourceTypes []CreateSubscriptionResourceTypesInner `json:"resourceTypes"`

	// Target URL:en som webhook:en ska posta till.
	Target string `json:"target"`
}

// SubscriptionAllOf defines model for Subscription_allOf.
type SubscriptionAllOf struct {
	Expires time.Time          `json:"expires"`
	Id      openapi_types.UUID `json:"id"`
}

// Subscriptions defines model for Subscriptions.
type Subscriptions struct {
	Data []Subscription `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// Syllabus Används för att referera till en specifik kurskod eller ett ämne med information om årskurs och skolform som avses med undervisningen. För officiella ämnen/kurser anges läroplan.
type Syllabus struct {
	// CourseCode Kurskod enligt Skolverket, om det är en officiell kurs, eller annars efter eget val.
	CourseCode *string `json:"courseCode,omitempty"`

	// CourseName Kursens namn, exempelvis Matematik 1a.
	CourseName *string `json:"courseName,omitempty"`

	// Curriculum Anger vilken läroplan aktiviteten avser. För vissa skolformer saknas läroplan.
	Curriculum *CurriculumEnum `json:"curriculum,omitempty"`

	// EndSchoolYear Slut för årskursintervall för undervisningens innehåll.
	EndSchoolYear *int               `json:"endSchoolYear,omitempty"`
	Id            openapi_types.UUID `json:"id"`

	// LanguageCode Språkkod för moderna språk och modersmål. Enligt ISO 639-3.
	LanguageCode *string `json:"languageCode,omitempty"`
	Meta         *Meta   `json:"meta,omitempty"`

	// Official Attributet anger om ämnet är ett officiellt ämne från Skolverket eller annan myndighet. Icke officiella ämnen kan skapas för andra ändamål än undervisning.
	Official bool `json:"official"`

	// Points Antalet poäng för en specifik kurs. Exempelvis 100 poäng.
	Points *int `json:"points,omitempty"`

	// SchoolType Följande värden används för att beskriva skolform:
	//   - _FS_ - Förskola
	//   - _FKLASS_ - Förskoleklass
	//   - _FTH_ - Fritidshem
	//   - _OPPFTH_ - Öppen fritidsverksamhet
	//   - _GR_ - Grundskola
	//   - _GRS_ - Grundsärskola
	//   - _TR_ - Träningsskolan
	//   - _SP_ - Specialskola
	//   - _SAM_ - Sameskola
	//   - _GY_ - Gymnasieskola
	//   - _GYS_ - Gymnasiesärskola
	//   - _VUX_ - Kommunal vuxenutbildning
	//   - _VUXSFI_ - Kommunal vuxenutbildning i svenska för invandrare
	//   - _VUXGR_ - Kommunal vuxenutbildning på grundläggande nivå
	//   - _VUXGY_ - Kommunal vuxenutbildning på gymnasial nivå
	//   - _VUXSARGR_ - Kommunal vuxenutbildning som särskild utbildning på grundläggande nivå
	//   - _VUXSARTR_ - Kommunal vuxenutbildning som särskild utbildning som motsvarar träningsskolan
	//   - _VUXSARGY_ - Kommunal vuxenutbildning som särskild utbildning på gymnasial nivå
	//   - _SFI_ - Utbildning i svenska för invandrare
	//   - _SARVUX_ - Särskild utbildning för vuxna
	//   - _SARVUXGR_ - Särskild utbildning för vuxna på grundläggande nivå
	//   - _SARVUXGY_ - Särskild utbildning för vuxna på gymnasial nivå
	//   - _SFI_ - Kommunal vuxenutbildning i svenska för invandrare
	//   - _KU_ - Kulturskola
	//   - _YH_ - Yrkeshögskola
	//   - _FHS_ - Folkhögskola
	//   - _STF_ - Studieförbund
	//   - _KKU_ - Konst- och kulturutbildning
	//   - _HS_ - Högskola
	//   - _ABU_ - Arbetsmarknadsutbildning
	//   - _AU_ - Annan undervisning
	SchoolType SchoolTypesEnum `json:"schoolType"`

	// SpecialisationCourseContent Beskrivning av innehållet i en specialiseringskurs på gymnasiet.
	SpecialisationCourseContent *SpecialisationCourseContent `json:"specialisationCourseContent,omitempty"`

	// StartSchoolYear Start för årskursintervall för undervisningens innehåll.
	StartSchoolYear *int `json:"startSchoolYear,omitempty"`

	// SubjectCode En kod för ämnet som används bland annat i lärarlegitimation och i Skolverkets kurs- och läroplaner, till exempel GRGRMAT01. Notera att detta värde *ej* är den kortare ämndesbeteckningen, exempelvis _MA_, utan indikerar inte bara ämne utan även vilken läroplan som avses, såsom i exemplet ovan Grundskolan. För ämnen som inte definieras av Skolverket används valfri kod.
	SubjectCode *string `json:"subjectCode,omitempty"`

	// SubjectDesignation Ämnets beteckning, exempelvis MA, MLARA.
	SubjectDesignation *string `json:"subjectDesignation,omitempty"`

	// SubjectName Ämnets namn, exempelvis Matematik.
	SubjectName string `json:"subjectName"`
}

// SyllabusReference defines model for SyllabusReference.
type SyllabusReference struct {
	// DisplayName Namn för visningsyfte för det refererade objektet. Skall endast returneras när query parametern `expandReferenceNames` är satt till "true".
	DisplayName *string            `json:"displayName,omitempty"`
	Id          openapi_types.UUID `json:"id"`
}

// Syllabuses defines model for Syllabuses.
type Syllabuses struct {
	Data []Syllabus `json:"data"`

	// PageToken Om värdet är null finns inget mer att hämta på det token som skickades in som query parameter.
	PageToken *string `json:"pageToken"`
}

// SyllabusesArray defines model for SyllabusesArray.
type SyllabusesArray = []Syllabus

// TeacherException Anger avvikelser beträffande lärares ansvar, tid och längd för ett enstaka kalendertillfälle.
type TeacherException struct {
	Duty DutyReference `json:"duty"`

	// EndTime Sluttid för undantaget (RFC 3339 format tex "2015-12-12T10:30:00+01:00").
	EndTime *time.Time `json:"endTime,omitempty"`

	// Participates Används för att ange om en lärare ska delta på ett visst kalendertillfälle.
	Participates bool `json:"participates"`

	// StartTime Starttid för undantaget (RFC 3339 format tex "2015-12-12T10:30:00+01:00").
	StartTime *time.Time `json:"startTime,omitempty"`

	// TeachingLength Undervisningstid i minuter för läraren. Om den ej anges så gäller det som är angivet i, i första hand, CalendarEvent, och annars i Activity.
	TeachingLength *int `json:"teachingLength,omitempty"`
}

// ActivitiesLookupPostRequest defines model for _activities_lookup_post_request.
type ActivitiesLookupPostRequest struct {
	Ids *[]openapi_types.UUID `json:"ids,omitempty"`

	// Members Hämta aktiviteter där attributet `groups` inkluderar en grupp som matchar ett av angivna idn utifrån `groupMemberships.person.id`.
	Members *[]openapi_types.UUID `json:"members,omitempty"`

	// Teachers Hämta aktiviteter där attributet `teachers` inkluderar något av de angivna idn i `duty.id`.
	Teachers *[]openapi_types.UUID `json:"teachers,omitempty"`
}

// AttendanceEventsLookupPostRequest defines model for _attendanceEvents_lookup_post_request.
type AttendanceEventsLookupPostRequest struct {
	Group  *[]openapi_types.UUID `json:"group,omitempty"`
	Ids    *[]openapi_types.UUID `json:"ids,omitempty"`
	Person *[]openapi_types.UUID `json:"person,omitempty"`
}

// AttendanceScheduleLookupPostRequest defines model for _attendanceSchedule_lookup_post_request.
type AttendanceScheduleLookupPostRequest struct {
	Ids       *[]openapi_types.UUID `json:"ids,omitempty"`
	Placement *[]openapi_types.UUID `json:"placement,omitempty"`
}

// AttendancesLookupPostRequest defines model for _attendances_lookup_post_request.
type AttendancesLookupPostRequest struct {
	Activities      *[]openapi_types.UUID `json:"activities,omitempty"`
	CalendareEvents *[]openapi_types.UUID `json:"calendareEvents,omitempty"`
	Ids             *[]openapi_types.UUID `json:"ids,omitempty"`
	Students        *[]openapi_types.UUID `json:"students,omitempty"`
}

// CalendarEventsLookupPostRequest defines model for _calendarEvents_lookup_post_request.
type CalendarEventsLookupPostRequest struct {
	Activities *[]openapi_types.UUID `json:"activities,omitempty"`
	Ids        *[]openapi_types.UUID `json:"ids,omitempty"`
	Student    *[]openapi_types.UUID `json:"student,omitempty"`
	Teacher    *[]openapi_types.UUID `json:"teacher,omitempty"`
}

// OrganisationsLookupPostRequest defines model for _organisations_lookup_post_request.
type OrganisationsLookupPostRequest struct {
	Ids               *[]openapi_types.UUID `json:"ids,omitempty"`
	OrganisationCodes *[]string             `json:"organisationCodes,omitempty"`
	SchoolUnitCodes   *[]string             `json:"schoolUnitCodes,omitempty"`
}

// PersonsLookupPostRequest defines model for _persons_lookup_post_request.
type PersonsLookupPostRequest struct {
	CivicNos *[]string             `json:"civicNos,omitempty"`
	Ids      *[]openapi_types.UUID `json:"ids,omitempty"`
}

// PlacementsLookupPostRequest defines model for _placements_lookup_post_request.
type PlacementsLookupPostRequest struct {
	Ids       *[]openapi_types.UUID `json:"ids,omitempty"`
	PersonIds *[]openapi_types.UUID `json:"personIds,omitempty"`
}

// SubscriptionsGetRequest defines model for _subscriptions_get_request.
type SubscriptionsGetRequest struct {
	// DeletedEntities True indikerar att det finns information om borttagna entiteter att hämta från ändpunkten `deletedEntitites`.
	DeletedEntities *bool `json:"deletedEntities,omitempty"`

	// ModifiedEntites En lista med datatyper där det finns uppdaterad eller ny information att hämta på respektive ändpunkt.
	ModifiedEntites *[]EndPointsEnum `json:"modifiedEntites,omitempty"`
}

// ExternalIdentifier defines model for externalIdentifier.
type ExternalIdentifier struct {
	// Context Anger för vilket sammanhang användaridentifieraren ska användas. Beskriv med en URI. Värdet kan överenskommas bilateralt mellan två integrerande parter.
	Context string `json:"context"`

	// GloballyUnique Anger om identifieraren är så utformad att den kan anses vara globalt unik.
	GloballyUnique bool `json:"globallyUnique"`

	// Value Identifierare för användaren.
	Value string `json:"value"`
}

// N400InvalidFilter defines model for 400_invalid_filter.
type N400InvalidFilter = Error

// N400InvalidId defines model for 400_invalid_id.
type N400InvalidId = Error

// N403NotAuthorised defines model for 403_not_authorised.
type N403NotAuthorised = Error

// N503Overload defines model for 503_overload.
type N503Overload = Error

// DefaultError defines model for default_error.
type DefaultError = Error

// GetAbsencesParams defines parameters for GetAbsences.
type GetAbsencesParams struct {
	// Organisation Begränsa urvalet till den frånvaro/ledighet som är kopplad till organisationen.
	Organisation *openapi_types.UUID `form:"organisation,omitempty" json:"organisation,omitempty"`

	// Student Begränsa urvalet till den frånvaro/ledighet som är kopplad till eleven
	Student *openapi_types.UUID `form:"student,omitempty" json:"student,omitempty"`

	// RegisteredBy Begränsa urvalet till den frånvaro/ledighet som är registrerad av personen
	RegisteredBy *openapi_types.UUID `form:"registeredBy,omitempty" json:"registeredBy,omitempty"`

	// Type Begränsa urvalet till den frånvaro/ledighet som är av angiven typ
	Type *AbsenceEnum `form:"type,omitempty" json:"type,omitempty"`

	// StartTimeOnOrBefore Endast anmälda frånvaro som startar innan eller på denna tidpunkt (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	StartTimeOnOrBefore *time.Time `form:"startTime.onOrBefore,omitempty" json:"startTime.onOrBefore,omitempty"`

	// StartTimeOnOrAfter Endast anmälda frånvaro/ledighet som startar efter denna tidpunkt (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	StartTimeOnOrAfter *time.Time `form:"startTime.onOrAfter,omitempty" json:"startTime.onOrAfter,omitempty"`

	// EndTimeOnOrBefore Endast anmälda frånvaro som slutar innan eller på denna tidpunkt (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	EndTimeOnOrBefore *time.Time `form:"endTime.onOrBefore,omitempty" json:"endTime.onOrBefore,omitempty"`

	// EndTimeOnOrAfter Endast anmälda frånvaro/ledighet som slutar efter denna tidpunkt (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	EndTimeOnOrAfter *time.Time `form:"endTime.onOrAfter,omitempty" json:"endTime.onOrAfter,omitempty"`

	// MetaCreatedBefore Endast poster skapade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaCreatedBefore *time.Time `form:"meta.created.before,omitempty" json:"meta.created.before,omitempty"`

	// MetaCreatedAfter Endast poster skapade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaCreatedAfter *time.Time `form:"meta.created.after,omitempty" json:"meta.created.after,omitempty"`

	// MetaModifiedBefore Endast poster modifierade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaModifiedBefore *time.Time `form:"meta.modified.before,omitempty" json:"meta.modified.before,omitempty"`

	// MetaModifiedAfter Endast poster modifierade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaModifiedAfter *time.Time `form:"meta.modified.after,omitempty" json:"meta.modified.after,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`

	// Sortkey Anger hur resultatet ska sorteras.
	Sortkey *GetAbsencesParamsSortkey `form:"sortkey,omitempty" json:"sortkey,omitempty"`

	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetAbsencesParamsSortkey defines parameters for GetAbsences.
type GetAbsencesParamsSortkey string

// PostAbsencesLookupParams defines parameters for PostAbsencesLookup.
type PostAbsencesLookupParams struct {
	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetActivitiesParams defines parameters for GetActivities.
type GetActivitiesParams struct {
	// Member Begränsa urvalet till aktiviteter vars grupper `groups` inkluderar denna person. Tidsbegräninsgar (`startDate`, `endDate`) appliceras inte för detta filter.
	Member *openapi_types.UUID `form:"member,omitempty" json:"member,omitempty"`

	// Teacher Begränsa urvalet till aktiviteter vars lärare `teachers` inkluderar detta id i attributet `duty.id`. Tidsbegräninsgar (`startDate`, `endDate`) appliceras inte för detta filter.
	Teacher *openapi_types.UUID `form:"teacher,omitempty" json:"teacher,omitempty"`

	// Organisation Begränsa urvalet till utpekat organisationselement och dess underliggande element.
	Organisation *openapi_types.UUID `form:"organisation,omitempty" json:"organisation,omitempty"`

	// Group Begränsa urvalet till utpekad grupp.
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`

	// StartDateOnOrBefore Begränsa urvalet till aktiviteter som har ett startDate värde innan eller på det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	StartDateOnOrBefore *openapi_types.Date `form:"startDate.onOrBefore,omitempty" json:"startDate.onOrBefore,omitempty"`

	// StartDateOnOrAfter Begränsa urvalet till aktiviteter som har ett startDate värde på eller efter det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	StartDateOnOrAfter *openapi_types.Date `form:"startDate.onOrAfter,omitempty" json:"startDate.onOrAfter,omitempty"`

	// EndDateOnOrBefore Begränsa urvalet till aktiviteter som har ett endDate värde innan eller på det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett endDate som ej är satt, tas alltid med.
	EndDateOnOrBefore *openapi_types.Date `form:"endDate.onOrBefore,omitempty" json:"endDate.onOrBefore,omitempty"`

	// EndDateOnOrAfter Begränsa urvalet till aktiviteter som har ett endDate värde på eller efter det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett endDate som ej är satt, tas alltid med.
	EndDateOnOrAfter *openapi_types.Date `form:"endDate.onOrAfter,omitempty" json:"endDate.onOrAfter,omitempty"`

	// MetaCreatedBefore Endast poster skapade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaCreatedBefore *time.Time `form:"meta.created.before,omitempty" json:"meta.created.before,omitempty"`

	// MetaCreatedAfter Endast poster skapade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaCreatedAfter *time.Time `form:"meta.created.after,omitempty" json:"meta.created.after,omitempty"`

	// MetaModifiedBefore Endast poster modifierade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaModifiedBefore *time.Time `form:"meta.modified.before,omitempty" json:"meta.modified.before,omitempty"`

	// MetaModifiedAfter Endast poster modifierade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaModifiedAfter *time.Time `form:"meta.modified.after,omitempty" json:"meta.modified.after,omitempty"`

	// Expand Beskriver om expanderade data ska hämtas
	Expand *[]GetActivitiesParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool                       `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
	Sortkey              *GetActivitiesParamsSortkey `form:"sortkey,omitempty" json:"sortkey,omitempty"`

	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetActivitiesParamsExpand defines parameters for GetActivities.
type GetActivitiesParamsExpand string

// GetActivitiesParamsSortkey defines parameters for GetActivities.
type GetActivitiesParamsSortkey string

// PostActivitiesLookupParams defines parameters for PostActivitiesLookup.
type PostActivitiesLookupParams struct {
	// Expand Beskriver om expanderade data ska hämtas
	Expand *[]PostActivitiesLookupParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// PostActivitiesLookupParamsExpand defines parameters for PostActivitiesLookup.
type PostActivitiesLookupParamsExpand string

// GetActivitiesIdParams defines parameters for GetActivitiesId.
type GetActivitiesIdParams struct {
	// Expand Beskriver om expanderade data ska hämtas
	Expand *[]GetActivitiesIdParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetActivitiesIdParamsExpand defines parameters for GetActivitiesId.
type GetActivitiesIdParamsExpand string

// GetAggregatedAttendanceParams defines parameters for GetAggregatedAttendance.
type GetAggregatedAttendanceParams struct {
	// StartDate Hämta aggregerad närvaro från och med detta datum (RFC 3339-format, e.g. "2016-10-15")
	StartDate openapi_types.Date `form:"startDate" json:"startDate"`

	// EndDate Hämta aggregerad närvaro till och med detta datum (RFC 3339-format, e.g. "2016-10-15")
	EndDate openapi_types.Date `form:"endDate" json:"endDate"`

	// Organisation Inkludera endast närvaro från aktiviteter vilka ägs av angivet organisationselement.
	Organisation *openapi_types.UUID `form:"organisation,omitempty" json:"organisation,omitempty"`

	// SchoolType Hämta endast närvaro information från aktiviteter vilka är kopplade mot angiven skolform.
	SchoolType *[]SchoolTypesEnum `form:"schoolType,omitempty" json:"schoolType,omitempty"`

	// Student Filtrera på elev (person).
	Student *[]openapi_types.UUID `form:"student,omitempty" json:"student,omitempty"`

	// Expand Beskriver om och vilken expanderade data som returneras i samband med närvaroinformationen.
	Expand *[]GetAggregatedAttendanceParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`

	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetAggregatedAttendanceParamsExpand defines parameters for GetAggregatedAttendance.
type GetAggregatedAttendanceParamsExpand string

// GetAttendanceEventsParams defines parameters for GetAttendanceEvents.
type GetAttendanceEventsParams struct {
	// Group Begränsa urvalet till utpekade gruppers ID.
	Group *[]openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`

	// Person Begränsa urvalet till utpekad person.
	Person *openapi_types.UUID `form:"person,omitempty" json:"person,omitempty"`

	// MetaCreatedBefore Endast poster skapade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaCreatedBefore *time.Time `form:"meta.created.before,omitempty" json:"meta.created.before,omitempty"`

	// MetaCreatedAfter Endast poster skapade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaCreatedAfter *time.Time `form:"meta.created.after,omitempty" json:"meta.created.after,omitempty"`

	// MetaModifiedBefore Endast poster modifierade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaModifiedBefore *time.Time `form:"meta.modified.before,omitempty" json:"meta.modified.before,omitempty"`

	// MetaModifiedAfter Endast poster modifierade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaModifiedAfter *time.Time `form:"meta.modified.after,omitempty" json:"meta.modified.after,omitempty"`

	// Expand Beskriver om expanderade data ska hämtas för aktiviteten.
	Expand *[]GetAttendanceEventsParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`

	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetAttendanceEventsParamsExpand defines parameters for GetAttendanceEvents.
type GetAttendanceEventsParamsExpand string

// PostAttendanceEventsLookupParams defines parameters for PostAttendanceEventsLookup.
type PostAttendanceEventsLookupParams struct {
	// Expand Beskriver om expanderade data ska hämtas för aktiviteten.
	Expand *[]PostAttendanceEventsLookupParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// PostAttendanceEventsLookupParamsExpand defines parameters for PostAttendanceEventsLookup.
type PostAttendanceEventsLookupParamsExpand string

// GetAttendanceEventsIdParams defines parameters for GetAttendanceEventsId.
type GetAttendanceEventsIdParams struct {
	// Expand Beskriver om expanderade data ska hämtas för aktiviteten.
	Expand *[]GetAttendanceEventsIdParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetAttendanceEventsIdParamsExpand defines parameters for GetAttendanceEventsId.
type GetAttendanceEventsIdParamsExpand string

// GetAttendanceScheduleParams defines parameters for GetAttendanceSchedule.
type GetAttendanceScheduleParams struct {
	// Placement Begränsa urvalet till scheman för utpekad placering.
	Placement *openapi_types.UUID `form:"placement,omitempty" json:"placement,omitempty"`

	// Group Begränsa urvalet till scheman vars placeringar är kopplad till utpekad grupp.
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`

	// StartDateOnOrBefore Begränsa urvalet till vistelseschema som har ett startDate värde innan eller på det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	StartDateOnOrBefore *openapi_types.Date `form:"startDate.onOrBefore,omitempty" json:"startDate.onOrBefore,omitempty"`

	// StartDateOnOrAfter Begränsa urvalet till vistelseschema som har ett startDate värde på eller efter det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	StartDateOnOrAfter *openapi_types.Date `form:"startDate.onOrAfter,omitempty" json:"startDate.onOrAfter,omitempty"`

	// EndDateOnOrBefore Begränsa urvalet till vistelseschema som har ett endDate värde innan eller på det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett endDate som ej är satt, tas alltid med.
	EndDateOnOrBefore *openapi_types.Date `form:"endDate.onOrBefore,omitempty" json:"endDate.onOrBefore,omitempty"`

	// EndDateOnOrAfter Begränsa urvalet till vistelseschema som har ett endDate värde på eller efter det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett endDate som ej är satt, tas alltid med.
	EndDateOnOrAfter *openapi_types.Date `form:"endDate.onOrAfter,omitempty" json:"endDate.onOrAfter,omitempty"`

	// MetaCreatedBefore Endast poster skapade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaCreatedBefore *time.Time `form:"meta.created.before,omitempty" json:"meta.created.before,omitempty"`

	// MetaCreatedAfter Endast poster skapade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaCreatedAfter *time.Time `form:"meta.created.after,omitempty" json:"meta.created.after,omitempty"`

	// MetaModifiedBefore Endast poster modifierade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaModifiedBefore *time.Time `form:"meta.modified.before,omitempty" json:"meta.modified.before,omitempty"`

	// MetaModifiedAfter Endast poster modifierade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaModifiedAfter *time.Time `form:"meta.modified.after,omitempty" json:"meta.modified.after,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`

	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// PostAttendanceScheduleLookupParams defines parameters for PostAttendanceScheduleLookup.
type PostAttendanceScheduleLookupParams struct {
	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetAttendanceScheduleIdParams defines parameters for GetAttendanceScheduleId.
type GetAttendanceScheduleIdParams struct {
	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetAttendancesParams defines parameters for GetAttendances.
type GetAttendancesParams struct {
	// Student Begränsa urvalet till utpekad person.
	Student *openapi_types.UUID `form:"student,omitempty" json:"student,omitempty"`

	// Organisation Begränsa urvalet till utpekat organisationselement och dess underliggande element.
	Organisation *openapi_types.UUID `form:"organisation,omitempty" json:"organisation,omitempty"`

	// CalendarEvent Begränsa urvalet till utpekad kalenderpost.
	CalendarEvent *openapi_types.UUID `form:"calendarEvent,omitempty" json:"calendarEvent,omitempty"`

	// MetaCreatedBefore Endast poster skapade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaCreatedBefore *time.Time `form:"meta.created.before,omitempty" json:"meta.created.before,omitempty"`

	// MetaCreatedAfter Endast poster skapade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaCreatedAfter *time.Time `form:"meta.created.after,omitempty" json:"meta.created.after,omitempty"`

	// MetaModifiedBefore Endast poster modifierade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaModifiedBefore *time.Time `form:"meta.modified.before,omitempty" json:"meta.modified.before,omitempty"`

	// MetaModifiedAfter Endast poster modifierade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaModifiedAfter *time.Time `form:"meta.modified.after,omitempty" json:"meta.modified.after,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`

	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// PostAttendancesLookupParams defines parameters for PostAttendancesLookup.
type PostAttendancesLookupParams struct {
	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetCalendarEventsParams defines parameters for GetCalendarEvents.
type GetCalendarEventsParams struct {
	// StartTimeOnOrAfter Hämta kalenderhändelser från och med denna tidpunkt (RFC 3339 format, t.ex. "2016-10-15T09:00:00+02:00").
	StartTimeOnOrAfter time.Time `form:"startTime.onOrAfter" json:"startTime.onOrAfter"`

	// StartTimeOnOrBefore Hämta kalenderhändelser till och med denna tidpunkt (RFC 3339 format, t.ex. "2016-10-15T09:00:00+02:00").
	StartTimeOnOrBefore time.Time `form:"startTime.onOrBefore" json:"startTime.onOrBefore"`

	// EndTimeOnOrBefore Hämta kalenderhändelser till och med denna tidpunkt (RFC 3339 format, t.ex. "2016-10-15T11:00:00+02:00").
	EndTimeOnOrBefore *time.Time `form:"endTime.onOrBefore,omitempty" json:"endTime.onOrBefore,omitempty"`

	// EndTimeOnOrAfter Hämta kalenderhändelser från och med denna tidpunkt (RFC 3339 format, t.ex. "2016-10-15T11:00:00+02:00").
	EndTimeOnOrAfter *time.Time `form:"endTime.onOrAfter,omitempty" json:"endTime.onOrAfter,omitempty"`

	// Activity Begränsa urvalet till utpekad aktivitet.
	Activity *openapi_types.UUID `form:"activity,omitempty" json:"activity,omitempty"`

	// Student Begränsa urvalet till kalenderhändelser vars aktivitet `activity.group` => `group.groupMemberships.person.id` eller `studentExceptions.student.id` inkluderar denna person. Tidsbegräninsgar (`startDate`, `endDate`) appliceras inte för detta filter.
	Student *openapi_types.UUID `form:"student,omitempty" json:"student,omitempty"`

	// Teacher Begränsa urvalet till kalenderhändelser vars aktiviteter `activity.teachers.duty.id` samt `teacherExceptions.duty.id` inkluderar denna tjänst `duty.id`. Tidsbegräninsgar (`startDate`, `endDate`) appliceras inte för detta filter.
	Teacher *openapi_types.UUID `form:"teacher,omitempty" json:"teacher,omitempty"`

	// Organisation Begränsa urvalet till utpekat organisationselement och dess underliggande element.
	Organisation *openapi_types.UUID `form:"organisation,omitempty" json:"organisation,omitempty"`

	// Group Begränsa urvalet till utpekad grupp relaterat genom kopplade aktiviteter.
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`

	// MetaCreatedBefore Endast poster skapade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaCreatedBefore *time.Time `form:"meta.created.before,omitempty" json:"meta.created.before,omitempty"`

	// MetaCreatedAfter Endast poster skapade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaCreatedAfter *time.Time `form:"meta.created.after,omitempty" json:"meta.created.after,omitempty"`

	// MetaModifiedBefore Endast poster modifierade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaModifiedBefore *time.Time `form:"meta.modified.before,omitempty" json:"meta.modified.before,omitempty"`

	// MetaModifiedAfter Endast poster modifierade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaModifiedAfter *time.Time `form:"meta.modified.after,omitempty" json:"meta.modified.after,omitempty"`

	// Expand Beskriver om expanderade data ska hämtas för aktiviteten.
	Expand *[]GetCalendarEventsParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`

	// Sortkey Anger hur resultatet ska sorteras.
	Sortkey *GetCalendarEventsParamsSortkey `form:"sortkey,omitempty" json:"sortkey,omitempty"`

	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetCalendarEventsParamsExpand defines parameters for GetCalendarEvents.
type GetCalendarEventsParamsExpand string

// GetCalendarEventsParamsSortkey defines parameters for GetCalendarEvents.
type GetCalendarEventsParamsSortkey string

// PostCalendarEventsLookupParams defines parameters for PostCalendarEventsLookup.
type PostCalendarEventsLookupParams struct {
	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetCalendarEventsIdParams defines parameters for GetCalendarEventsId.
type GetCalendarEventsIdParams struct {
	// Expand Beskriver om expanderade data ska hämtas för aktiviteten.
	Expand *[]GetCalendarEventsIdParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetCalendarEventsIdParamsExpand defines parameters for GetCalendarEventsId.
type GetCalendarEventsIdParamsExpand string

// GetDeletedEntitiesParams defines parameters for GetDeletedEntities.
type GetDeletedEntitiesParams struct {
	// After Hämta borttag som inträffat efter specificerad tidpunkt (RFC 3339 format, tex "2015-12-12T10:30:00+01:00").
	After *time.Time `form:"after,omitempty" json:"after,omitempty"`

	// Entities En lista med de entitetstyper vars borttag ska hämtas
	Entities *[]EndPointsEnum `form:"entities,omitempty" json:"entities,omitempty"`

	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetDutiesParams defines parameters for GetDuties.
type GetDutiesParams struct {
	// Organisation Begränsa urvalet till de tjänstgöringar som är kopplade till ett organisationselement eller underliggande element.
	Organisation *openapi_types.UUID `form:"organisation,omitempty" json:"organisation,omitempty"`

	// DutyRole Begränsta urvalet till de tjänstgöringar som matchar roll
	DutyRole *DutyRole `form:"dutyRole,omitempty" json:"dutyRole,omitempty"`

	// Person Begränsa urvalet till de tjänstgöringar som är kopplade till person ID
	Person *openapi_types.UUID `form:"person,omitempty" json:"person,omitempty"`

	// StartDateOnOrBefore Begränsa urvalet till tjänstgöringar som har ett startDate värde innan eller på det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	StartDateOnOrBefore *openapi_types.Date `form:"startDate.onOrBefore,omitempty" json:"startDate.onOrBefore,omitempty"`

	// StartDateOnOrAfter Begränsa urvalet till tjänstgöringar som har ett startDate värde på eller efter det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	StartDateOnOrAfter *openapi_types.Date `form:"startDate.onOrAfter,omitempty" json:"startDate.onOrAfter,omitempty"`

	// EndDateOnOrBefore Begränsa urvalet till tjänstgöringar som har ett endDate värde innan eller på det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett endDate som ej är satt, tas alltid med.
	EndDateOnOrBefore *openapi_types.Date `form:"endDate.onOrBefore,omitempty" json:"endDate.onOrBefore,omitempty"`

	// EndDateOnOrAfter Begränsa urvalet till tjänstgöringar som har ett endDate värde på eller efter det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett endDate som ej är satt, tas alltid med.
	EndDateOnOrAfter *openapi_types.Date `form:"endDate.onOrAfter,omitempty" json:"endDate.onOrAfter,omitempty"`

	// MetaCreatedBefore Endast poster skapade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaCreatedBefore *time.Time `form:"meta.created.before,omitempty" json:"meta.created.before,omitempty"`

	// MetaCreatedAfter Endast poster skapade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaCreatedAfter *time.Time `form:"meta.created.after,omitempty" json:"meta.created.after,omitempty"`

	// MetaModifiedBefore Endast poster modifierade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaModifiedBefore *time.Time `form:"meta.modified.before,omitempty" json:"meta.modified.before,omitempty"`

	// MetaModifiedAfter Endast poster modifierade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaModifiedAfter *time.Time `form:"meta.modified.after,omitempty" json:"meta.modified.after,omitempty"`

	// Expand Beskriver om expanderade data ska hämtas
	Expand *[]GetDutiesParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`

	// Sortkey Anger hur resultatet ska sorteras.
	Sortkey *GetDutiesParamsSortkey `form:"sortkey,omitempty" json:"sortkey,omitempty"`

	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetDutiesParamsExpand defines parameters for GetDuties.
type GetDutiesParamsExpand string

// GetDutiesParamsSortkey defines parameters for GetDuties.
type GetDutiesParamsSortkey string

// PostDutiesLookupParams defines parameters for PostDutiesLookup.
type PostDutiesLookupParams struct {
	// Expand Beskriver om expanderade data ska hämtas
	Expand *[]PostDutiesLookupParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// PostDutiesLookupParamsExpand defines parameters for PostDutiesLookup.
type PostDutiesLookupParamsExpand string

// GetDutiesIdParams defines parameters for GetDutiesId.
type GetDutiesIdParams struct {
	// Expand Beskriver om expanderade data ska hämtas
	Expand *[]GetDutiesIdParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetDutiesIdParamsExpand defines parameters for GetDutiesId.
type GetDutiesIdParamsExpand string

// GetGradesParams defines parameters for GetGrades.
type GetGradesParams struct {
	// Organisation Begränsa urvalet till de betyg som är kopplade till skolenhet.
	Organisation *openapi_types.UUID `form:"organisation,omitempty" json:"organisation,omitempty"`

	// Student Begränsa urvalet till de betyg som tillhör eleven
	Student *openapi_types.UUID `form:"student,omitempty" json:"student,omitempty"`

	// RegisteredBy Begränsa urvalet till de betyg som är registrerade av personen
	RegisteredBy *openapi_types.UUID `form:"registeredBy,omitempty" json:"registeredBy,omitempty"`

	// GradingTeacher Begränsa urvalet till de betyg som är utfärdade av ansvarig lärare
	GradingTeacher *openapi_types.UUID `form:"gradingTeacher,omitempty" json:"gradingTeacher,omitempty"`

	// RegisteredDateOnOrAfter Begränsa urvalet av betyg till de som är registerade inom det intervall som startar på angivet datum (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	RegisteredDateOnOrAfter *openapi_types.Date `form:"registeredDate.onOrAfter,omitempty" json:"registeredDate.onOrAfter,omitempty"`

	// RegisteredDateOnOrBefore Begränsa urvalet av betyg till de som är registerade inom det intervall som slutar på angivet datum (RFC 3339-format, t.ex. "2016-10-15"). Inkluderande.
	RegisteredDateOnOrBefore *openapi_types.Date `form:"registeredDate.onOrBefore,omitempty" json:"registeredDate.onOrBefore,omitempty"`

	// MetaCreatedBefore Endast poster skapade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaCreatedBefore *time.Time `form:"meta.created.before,omitempty" json:"meta.created.before,omitempty"`

	// MetaCreatedAfter Endast poster skapade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaCreatedAfter *time.Time `form:"meta.created.after,omitempty" json:"meta.created.after,omitempty"`

	// MetaModifiedBefore Endast poster modifierade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaModifiedBefore *time.Time `form:"meta.modified.before,omitempty" json:"meta.modified.before,omitempty"`

	// MetaModifiedAfter Endast poster modifierade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaModifiedAfter *time.Time `form:"meta.modified.after,omitempty" json:"meta.modified.after,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`

	// Sortkey Anger hur resultatet ska sorteras.
	Sortkey *GetGradesParamsSortkey `form:"sortkey,omitempty" json:"sortkey,omitempty"`

	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetGradesParamsSortkey defines parameters for GetGrades.
type GetGradesParamsSortkey string

// PostGradesLookupParams defines parameters for PostGradesLookup.
type PostGradesLookupParams struct {
	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetGradesIdParams defines parameters for GetGradesId.
type GetGradesIdParams struct {
	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetGroupsParams defines parameters for GetGroups.
type GetGroupsParams struct {
	// GroupType Begränsa urvalet till grupper av en eller flera type.
	GroupType *[]GroupTypesEnum `form:"groupType,omitempty" json:"groupType,omitempty"`

	// SchoolTypes Begränsa urvalet av grupper till de som är har en av de angivna skolformerna.
	SchoolTypes *[]SchoolTypesEnum `form:"schoolTypes,omitempty" json:"schoolTypes,omitempty"`

	// Organisation Begränsa urvalet till de grupper som direkt kopplade till angivna organisationselement.
	Organisation *[]openapi_types.UUID `form:"organisation,omitempty" json:"organisation,omitempty"`

	// StartDateOnOrBefore Begränsa urvalet till grupper som har ett startDate värde innan eller på det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	StartDateOnOrBefore *openapi_types.Date `form:"startDate.onOrBefore,omitempty" json:"startDate.onOrBefore,omitempty"`

	// StartDateOnOrAfter Begränsa urvalet till grupper som har ett startDate värde på eller efter det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	StartDateOnOrAfter *openapi_types.Date `form:"startDate.onOrAfter,omitempty" json:"startDate.onOrAfter,omitempty"`

	// EndDateOnOrBefore Begränsa urvalet till grupper som har ett endDate värde innan eller på det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett endDate som ej är satt, tas alltid med.
	EndDateOnOrBefore *openapi_types.Date `form:"endDate.onOrBefore,omitempty" json:"endDate.onOrBefore,omitempty"`

	// EndDateOnOrAfter Begränsa urvalet till grupper som har ett endDate värde på eller efter det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett endDate som ej är satt, tas alltid med.
	EndDateOnOrAfter *openapi_types.Date `form:"endDate.onOrAfter,omitempty" json:"endDate.onOrAfter,omitempty"`

	// MetaCreatedBefore Endast poster skapade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaCreatedBefore *time.Time `form:"meta.created.before,omitempty" json:"meta.created.before,omitempty"`

	// MetaCreatedAfter Endast poster skapade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaCreatedAfter *time.Time `form:"meta.created.after,omitempty" json:"meta.created.after,omitempty"`

	// MetaModifiedBefore Endast poster modifierade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaModifiedBefore *time.Time `form:"meta.modified.before,omitempty" json:"meta.modified.before,omitempty"`

	// MetaModifiedAfter Endast poster modifierade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaModifiedAfter *time.Time `form:"meta.modified.after,omitempty" json:"meta.modified.after,omitempty"`

	// Expand Beskriver om expanderade data ska hämtas
	Expand *[]GetGroupsParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`

	// Sortkey Anger hur resultatet ska sorteras.
	Sortkey *GetGroupsParamsSortkey `form:"sortkey,omitempty" json:"sortkey,omitempty"`

	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetGroupsParamsExpand defines parameters for GetGroups.
type GetGroupsParamsExpand string

// GetGroupsParamsSortkey defines parameters for GetGroups.
type GetGroupsParamsSortkey string

// PostGroupsLookupParams defines parameters for PostGroupsLookup.
type PostGroupsLookupParams struct {
	// Expand Beskriver om expanderade data ska hämtas
	Expand *[]PostGroupsLookupParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// PostGroupsLookupParamsExpand defines parameters for PostGroupsLookup.
type PostGroupsLookupParamsExpand string

// GetGroupsIdParams defines parameters for GetGroupsId.
type GetGroupsIdParams struct {
	// Expand Beskriver om expanderade data ska hämtas
	Expand *[]GetGroupsIdParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetGroupsIdParamsExpand defines parameters for GetGroupsId.
type GetGroupsIdParamsExpand string

// GetOrganisationsParams defines parameters for GetOrganisations.
type GetOrganisationsParams struct {
	// Parent Begränsa urvalet till utpekade organisations-ID:n.
	Parent *[]openapi_types.UUID `form:"parent,omitempty" json:"parent,omitempty"`

	// SchoolUnitCode Begränsa urvalet till de skolenheter som har den angivna Skolenhetskoden. En Identifierare för skolenheten enligt Skolverket.
	SchoolUnitCode *[]string `form:"schoolUnitCode,omitempty" json:"schoolUnitCode,omitempty"`

	// OrganisationCode Begränsa urvalet till de organisationselement som har den angivna koden.
	OrganisationCode *[]string `form:"organisationCode,omitempty" json:"organisationCode,omitempty"`

	// MunicipalityCode Begränsa urvalet till de organisationselement som har angiven kommunkod.
	MunicipalityCode *string `form:"municipalityCode,omitempty" json:"municipalityCode,omitempty"`

	// Type Begränsa urvalet till utpekade typ.
	Type *[]OrganisationTypeEnum `form:"type,omitempty" json:"type,omitempty"`

	// SchoolTypes Begränsa urvalet till de organisationselement som har den angivna skolformen.
	SchoolTypes *[]SchoolTypesEnum `form:"schoolTypes,omitempty" json:"schoolTypes,omitempty"`

	// StartDateOnOrBefore Begränsa urvalet till organisationselement som har ett startDate värde innan eller på det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett endDate som ej är satt, tas alltid med.
	StartDateOnOrBefore *openapi_types.Date `form:"startDate.onOrBefore,omitempty" json:"startDate.onOrBefore,omitempty"`

	// StartDateOnOrAfter Begränsa urvalet till organisationselement som har ett startDate värde på eller efter det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett endDate som ej är satt, tas alltid med.
	StartDateOnOrAfter *openapi_types.Date `form:"startDate.onOrAfter,omitempty" json:"startDate.onOrAfter,omitempty"`

	// EndDateOnOrBefore Begränsa urvalet till organisationselement som har ett endDate värde innan eller på det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett endDate som ej är satt, tas alltid med.
	EndDateOnOrBefore *openapi_types.Date `form:"endDate.onOrBefore,omitempty" json:"endDate.onOrBefore,omitempty"`

	// EndDateOnOrAfter Begränsa urvalet till organisationselement som har ett endDate värde på eller efter det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett endDate som ej är satt, tas alltid med.
	EndDateOnOrAfter *openapi_types.Date `form:"endDate.onOrAfter,omitempty" json:"endDate.onOrAfter,omitempty"`

	// MetaCreatedBefore Endast poster skapade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaCreatedBefore *time.Time `form:"meta.created.before,omitempty" json:"meta.created.before,omitempty"`

	// MetaCreatedAfter Endast poster skapade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaCreatedAfter *time.Time `form:"meta.created.after,omitempty" json:"meta.created.after,omitempty"`

	// MetaModifiedBefore Endast poster modifierade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaModifiedBefore *time.Time `form:"meta.modified.before,omitempty" json:"meta.modified.before,omitempty"`

	// MetaModifiedAfter Endast poster modifierade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaModifiedAfter *time.Time `form:"meta.modified.after,omitempty" json:"meta.modified.after,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool                          `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
	Sortkey              *GetOrganisationsParamsSortkey `form:"sortkey,omitempty" json:"sortkey,omitempty"`

	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetOrganisationsParamsSortkey defines parameters for GetOrganisations.
type GetOrganisationsParamsSortkey string

// PostOrganisationsLookupParams defines parameters for PostOrganisationsLookup.
type PostOrganisationsLookupParams struct {
	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetOrganisationsIdParams defines parameters for GetOrganisationsId.
type GetOrganisationsIdParams struct {
	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetPersonsParams defines parameters for GetPersons.
type GetPersonsParams struct {
	// NameContains Begränsa urvalet till de personer vars namn innehåller något av parameterns värden.
	// Sökningen **ska** ske shiftlägesokänsligt och värdet kan förekomma var som helst i något av alla tre namnfälten.
	// Anges flera värden så måste samtliga värden matcha minst ett av namnfälten.
	//
	// Exempel: [ "Pa", "gens" ] kommer matcha Palle Girgensohn.
	NameContains *[]string `form:"nameContains,omitempty" json:"nameContains,omitempty"`

	// CivicNo Begränsa urvalet till den person vars civicNo matchar parameterns värde.
	CivicNo *string `form:"civicNo,omitempty" json:"civicNo,omitempty"`

	// EduPersonPrincipalName Begränsa urvalet till den person vars eduPersonPrincipalNames matchar parameterns värde.
	EduPersonPrincipalName *string `form:"eduPersonPrincipalName,omitempty" json:"eduPersonPrincipalName,omitempty"`

	// IdentifierValue Begränsa urvalet till den person vilka har ett värde i `externalIdentifiers.value` som matchar parameterns värde. Kan kombineras med parametern `identifier.context` för att begränsa matchningen till en specifik typ av indentifierare.
	IdentifierValue *string `form:"identifier.value,omitempty" json:"identifier.value,omitempty"`

	// IdentifierContext Begränsa urvalet till den person vilka har ett värde i `externalIdentifiers.context` som matchar parameterns värde. Kombineras vanligtvis med `identifier.value` parametern.
	IdentifierContext *string `form:"identifier.context,omitempty" json:"identifier.context,omitempty"`

	// RelationshipEntityType Begränsa urvalet till de personer som har en denna typ av relation till andra entititeter.
	// Denna parameter styr vilket entitetstyp som övriga relationship-parametrar filterar på.
	// Anges inga andra parametrar så returneras personer som har en relation av denna typ.
	//
	// Möjliga relationer:
	// - _enrolment_ - filtrerar utifrån elever inskrivning.
	// - _duty_ - filtrerar utifrån personer som har minst en tjänstgöring.
	// - _placement.child_ - filtrerar utifrån barn som har minst en placering.
	// - _placement.owner_ - filtrerar utifrån personer som satta som ägare av minst en placering.
	// - _responsibleFor.enrolment_ - filterar utifrån personer som har en _"responsibleFor"_-relation, dvs är en vårdnadshavare eller annan ansvarig vuxen, till en elev med minst en inskrivning.
	// - _responsibleFor.placement_ - filterar utifrån personer som har en _"responsibleFor"_-relation, dvs är en vårdnadshavare eller annan ansvarig vuxen, till ett barn med minst en placering.
	//   Notera att oftast är det bättre att använda _placement.owner_ än denna parameter.
	// - _groupMembership_ - filtrerar utifrån gruppmedlemsskap
	//
	// Detta kan kombineras med `relationship.startDate.onOrBefore` och `relationship.endDate.onOrAfter` för att begränsa till aktiva relationer.
	RelationshipEntityType *GetPersonsParamsRelationshipEntityType `form:"relationship.entity.type,omitempty" json:"relationship.entity.type,omitempty"`

	// RelationshipOrganisation Begränsa urvalet till de personer som har en relation till angivet organisationselement (vanligtvis en skolenhet).
	// För att begränsa till en viss relationtyp används parametern `relationship.entity.type`.
	//
	// Följande fält/relationer används vid filtreringen:
	// - _enrolment_ - poster matchandes `person.enrolment.enroledAt`
	// - _duty_ - person poster matchandes `duty.person` i en lista filtrerad utifrån `duty.dutyAt`.
	// - _placement.child_ - person poster matchandes `placement.child` i en lista filtrerad utifrån `placement.placedAt`.
	// - _placement.owner_ - person poster matchandes `placement.owner` i en lista filtrerad utifrån `placement.placedAt`.
	// - _responsibleFor.enrolment_ - person poster matchandes `person.responsibles` i en lista filtrerad utifrån `person.enrolment.enroledAt`.
	// - _responsibleFor.placement_ - person poster matchandes `person.responsibles` i en lista med person poster som i sin tur matchar `placement.child` i en lista filtrerad utifrån `placement.placedAt`.
	// - _groupMembership_ - person poster matchandes `person.groupMemberships`
	RelationshipOrganisation *openapi_types.UUID `form:"relationship.organisation,omitempty" json:"relationship.organisation,omitempty"`

	// RelationshipStartDateOnOrBefore Begränsa urvalet av personer till de som har relationer med startDate innan eller på det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett startDate som ej är satt, tas alltid med.
	// För att begränsa till en viss relationtyp används parametern `relationship.entity.type`.
	//
	// Följande fält/relationer används vid filtreringen:
	// - _enrolment_ - poster matchandes `person.enrolment.startDate`
	// - _duty_ - person poster matchandes `duty.person` i en lista filtrerad utifrån `duty.startDate`.
	// - _placement.child_ - person poster matchandes `placement.child` i en lista filtrerad utifrån `placement.startDate`.
	// - _placement.owner_ - person poster matchandes `placement.owner` i en lista filtrerad utifrån `placement.startDate`.
	// - _responsibleFor.enrolment_ - person poster matchandes `person.responsibles` i en lista filtrerad utifrån `person.enrolment.startDate`.
	// - _responsibleFor.placement_ - person poster matchandes `person.responsibles` i en lista med person poster som i sin tur matchar `placement.child` i en lista filtrerad utifrån `placement.startDate`.
	// - _groupMembership_ - poster matchandes `group.groupMemberships.person` eller `group.assignmentRole.duty.person` i en lista filtrerad utifrån `group.groupMemberships.startDate` eller `group.assignmentRole.startDate`.
	//
	// Detta kan kombineras med _relationship.endDate.onOrAfter_ för att begränsa till aktiva relationer.
	RelationshipStartDateOnOrBefore *openapi_types.Date `form:"relationship.startDate.onOrBefore,omitempty" json:"relationship.startDate.onOrBefore,omitempty"`

	// RelationshipStartDateOnOrAfter Begränsa urvalet av personer till de som har relationer med startDate efter eller på det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett startDate som ej är satt, tas alltid med.
	// För att begränsa till en viss relationtyp används parametern `relationship.entity.type`.
	//
	// Följande fält/relationer används vid filtreringen:
	// - _enrolment_ - poster matchandes `person.enrolment.startDate`
	// - _duty_ - person poster matchandes `duty.person` i en lista filtrerad utifrån `duty.startDate`.
	// - _placement.child_ - person poster matchandes `placement.child` i en lista filtrerad utifrån `placement.startDate`.
	// - _placement.owner_ - person poster matchandes `placement.owner` i en lista filtrerad utifrån `placement.startDate`.
	// - _responsibleFor.enrolment_ - person poster matchandes `person.responsibles` i en lista filtrerad utifrån `person.enrolment.startDate`.
	// - _responsibleFor.placement_ - person poster matchandes `person.responsibles` i en lista med person poster som i sin tur matchar `placement.child` i en lista filtrerad utifrån `placement.startDate`.
	// - _groupMembership_ - poster matchande `group.groupMemberships.person` eller `group.assignmentRole.duty.person` i en lista filtrerad utifrån `group.groupMemberships.startDate` eller `group.assignmentRole.startDate`.
	RelationshipStartDateOnOrAfter *openapi_types.Date `form:"relationship.startDate.onOrAfter,omitempty" json:"relationship.startDate.onOrAfter,omitempty"`

	// RelationshipEndDateOnOrBefore Begränsa urvalet av personer till de som har relationer med endDate innan eller på det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett endDate som ej är satt, tas alltid med.
	// För att begränsa till en viss relationtyp används parametern `relationship.entity.type`.
	//
	// Följande fält/relationer används vid filtreringen:
	// - _enrolment_ - poster matchandes `person.enrolment.endDate`
	// - _duty_ - person poster matchandes `duty.person` i en lista filtrerad utifrån `duty.endDate`.
	// - _placement.child_ - person poster matchandes `placement.child` i en lista filtrerad utifrån `placement.endDate`.
	// - _placement.owner_ - person poster matchandes `placement.owner` i en lista filtrerad utifrån `placement.endDate`.
	// - _responsibleFor.enrolment_ - person poster matchandes `person.responsibles` i en lista filtrerad utifrån `person.enrolment.endDate`.
	// - _responsibleFor.placement_ - person poster matchandes `person.responsibles` i en lista med person poster som i sin tur matchar `placement.child` i en lista filtrerad utifrån `placement.endDate`.
	// - _groupMembership_ - poster matchande `group.groupMemberships.person` eller `group.assignmentRole.duty.person` i en lista filtrerad utifrån `group.groupMemberships.endDate` eller `group.assignmentRole.endDate`.
	RelationshipEndDateOnOrBefore *openapi_types.Date `form:"relationship.endDate.onOrBefore,omitempty" json:"relationship.endDate.onOrBefore,omitempty"`

	// RelationshipEndDateOnOrAfter Begränsa urvalet av personer till de som har relationer med endDate efter eller på det angivna datumet (RFC 3339-format,t.ex. "2016-10-15").
	// Poster med ett endDate som ej är satt, tas alltid med.
	// För att begränsa till en viss relationtyp används parametern `relationship.entity.type`.
	//
	// Flöjande fält/relationer används vid filtreringen:
	//  - _enrolment_ - poster matchandes `person.enrolment.endDate`
	//  - _duty_ - person poster matchandes `duty.person` i en lista filtrerad utifrån `duty.endDate`.
	//  - _placement.child_ - person poster matchandes `placement.child` i en lista filtrerad utifrån `placement.endDate`.
	//  - _placement.owner_ - person poster matchandes `placement.owner` i en lista filtrerad utifrån `placement.endDate`.
	//  - _responsibleFor.enrolment_ - person poster matchandes `person.responsibles` i en lista filtrerad utifrån `person.enrolment.endDate`.
	//  - _responsibleFor.placement_ - person poster matchandes `person.responsibles` i en lista med person poster som i sin tur matchar `placement.child` i en lista filtrerad utifrån `placement.endDate`.
	//  - _groupMembership_ - poster matchande `group.groupMemberships.person` eller `group.assignmentRole.duty.person` i en lista filtrerad utifrån `group.groupMemberships.endDate` eller `group.assignmentRole.endDate`.
	//
	// Detta kan kombineras med _relationship.startDate.onOrBefore_ för att begränsa till aktiva relationer.
	RelationshipEndDateOnOrAfter *openapi_types.Date `form:"relationship.endDate.onOrAfter,omitempty" json:"relationship.endDate.onOrAfter,omitempty"`

	// MetaCreatedBefore Endast poster skapade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaCreatedBefore *time.Time `form:"meta.created.before,omitempty" json:"meta.created.before,omitempty"`

	// MetaCreatedAfter Endast poster skapade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaCreatedAfter *time.Time `form:"meta.created.after,omitempty" json:"meta.created.after,omitempty"`

	// MetaModifiedBefore Endast poster modifierade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaModifiedBefore *time.Time `form:"meta.modified.before,omitempty" json:"meta.modified.before,omitempty"`

	// MetaModifiedAfter Endast poster modifierade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaModifiedAfter *time.Time `form:"meta.modified.after,omitempty" json:"meta.modified.after,omitempty"`

	// Expand Beskriver om expanderade data ska hämtas
	Expand *[]GetPersonsParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`

	// Sortkey Anger hur resultatet ska sorteras.
	Sortkey *GetPersonsParamsSortkey `form:"sortkey,omitempty" json:"sortkey,omitempty"`

	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetPersonsParamsRelationshipEntityType defines parameters for GetPersons.
type GetPersonsParamsRelationshipEntityType string

// GetPersonsParamsExpand defines parameters for GetPersons.
type GetPersonsParamsExpand string

// GetPersonsParamsSortkey defines parameters for GetPersons.
type GetPersonsParamsSortkey string

// PostPersonsLookupParams defines parameters for PostPersonsLookup.
type PostPersonsLookupParams struct {
	// Expand Beskriver om expanderade data ska hämtas
	Expand *[]PostPersonsLookupParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// PostPersonsLookupParamsExpand defines parameters for PostPersonsLookup.
type PostPersonsLookupParamsExpand string

// GetPersonsIdParams defines parameters for GetPersonsId.
type GetPersonsIdParams struct {
	// Expand Beskriver om expanderade data ska hämtas
	Expand *[]GetPersonsIdParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetPersonsIdParamsExpand defines parameters for GetPersonsId.
type GetPersonsIdParamsExpand string

// GetPlacementsParams defines parameters for GetPlacements.
type GetPlacementsParams struct {
	// Organisation Begränsa urvalet till de barn som har en placering (placedAt) på angivet organisationselement.  Detta kan kombineras med startDate.onOrBefore och endDate.onOrAfter för att begränsa till aktiva placeringar.
	Organisation *openapi_types.UUID `form:"organisation,omitempty" json:"organisation,omitempty"`

	// Group Begränsa urvalet till de barn som har en placering på angiven grupp. Detta kan kombineras med startDate.onOrBefore och endDate.onOrAfter för att begränsa till aktiva placeringar.
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`

	// StartDateOnOrBefore Begränsa urvalet till placeringar som har ett startDate värde innan eller på det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	StartDateOnOrBefore *openapi_types.Date `form:"startDate.onOrBefore,omitempty" json:"startDate.onOrBefore,omitempty"`

	// StartDateOnOrAfter Begränsa urvalet till placeringar som har ett startDate värde på eller efter det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	StartDateOnOrAfter *openapi_types.Date `form:"startDate.onOrAfter,omitempty" json:"startDate.onOrAfter,omitempty"`

	// EndDateOnOrBefore Begränsa urvalet till placeringar som har ett endDate värde innan eller på det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett endDate som ej är satt, tas alltid med.
	EndDateOnOrBefore *openapi_types.Date `form:"endDate.onOrBefore,omitempty" json:"endDate.onOrBefore,omitempty"`

	// EndDateOnOrAfter Begränsa urvalet till placeringar som har ett endDate värde på eller efter det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett endDate som ej är satt, tas alltid med.
	EndDateOnOrAfter *openapi_types.Date `form:"endDate.onOrAfter,omitempty" json:"endDate.onOrAfter,omitempty"`

	// Child Begränsa urvalet till ett barn. Detta kan kombineras med startDate.onOrBefore och endDate.onOrAfter för att begränsa till aktiva placeringar.
	Child *openapi_types.UUID `form:"child,omitempty" json:"child,omitempty"`

	// Owner Begränsa urvalet till placeringar med denna ägare. Detta kan kombineras med startDate.onOrAfter och endDate.onOrBefore för att begränsa till aktiva placeringar.
	Owner *openapi_types.UUID `form:"owner,omitempty" json:"owner,omitempty"`

	// MetaCreatedBefore Endast poster skapade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaCreatedBefore *time.Time `form:"meta.created.before,omitempty" json:"meta.created.before,omitempty"`

	// MetaCreatedAfter Endast poster skapade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaCreatedAfter *time.Time `form:"meta.created.after,omitempty" json:"meta.created.after,omitempty"`

	// MetaModifiedBefore Endast poster modifierade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaModifiedBefore *time.Time `form:"meta.modified.before,omitempty" json:"meta.modified.before,omitempty"`

	// MetaModifiedAfter Endast poster modifierade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaModifiedAfter *time.Time `form:"meta.modified.after,omitempty" json:"meta.modified.after,omitempty"`

	// Expand Beskriver om expanderade data ska hämtas
	Expand *[]GetPlacementsParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`

	// Sortkey Anger hur resultatet ska sorteras.
	Sortkey *GetPlacementsParamsSortkey `form:"sortkey,omitempty" json:"sortkey,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPlacementsParamsExpand defines parameters for GetPlacements.
type GetPlacementsParamsExpand string

// GetPlacementsParamsSortkey defines parameters for GetPlacements.
type GetPlacementsParamsSortkey string

// PostPlacementsLookupParams defines parameters for PostPlacementsLookup.
type PostPlacementsLookupParams struct {
	// Expand Beskriver om expanderade data ska hämtas
	Expand *[]PostPlacementsLookupParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// PostPlacementsLookupParamsExpand defines parameters for PostPlacementsLookup.
type PostPlacementsLookupParamsExpand string

// GetPlacementsIdParams defines parameters for GetPlacementsId.
type GetPlacementsIdParams struct {
	// Expand Beskriver om expanderade data ska hämtas
	Expand *[]GetPlacementsIdParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetPlacementsIdParamsExpand defines parameters for GetPlacementsId.
type GetPlacementsIdParamsExpand string

// GetProgrammesParams defines parameters for GetProgrammes.
type GetProgrammesParams struct {
	// SchoolType Begränsa urvalet till de program som matchar skolformen.
	SchoolType *[]SchoolTypesEnum `form:"schoolType,omitempty" json:"schoolType,omitempty"`

	// Code Begränsta urvalet till de program som matchar programkod
	Code *string `form:"code,omitempty" json:"code,omitempty"`

	// ParentProgramme Begränsta urvalet till de program som matchar angivet parentProgramme.
	ParentProgramme *string `form:"parentProgramme,omitempty" json:"parentProgramme,omitempty"`

	// MetaCreatedBefore Endast poster skapade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaCreatedBefore *time.Time `form:"meta.created.before,omitempty" json:"meta.created.before,omitempty"`

	// MetaCreatedAfter Endast poster skapade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaCreatedAfter *time.Time `form:"meta.created.after,omitempty" json:"meta.created.after,omitempty"`

	// MetaModifiedBefore Endast poster modifierade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaModifiedBefore *time.Time `form:"meta.modified.before,omitempty" json:"meta.modified.before,omitempty"`

	// MetaModifiedAfter Endast poster modifierade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaModifiedAfter *time.Time `form:"meta.modified.after,omitempty" json:"meta.modified.after,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`

	// Sortkey Anger hur resultatet ska sorteras.
	Sortkey *GetProgrammesParamsSortkey `form:"sortkey,omitempty" json:"sortkey,omitempty"`

	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetProgrammesParamsSortkey defines parameters for GetProgrammes.
type GetProgrammesParamsSortkey string

// PostProgrammesLookupParams defines parameters for PostProgrammesLookup.
type PostProgrammesLookupParams struct {
	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetProgrammesIdParams defines parameters for GetProgrammesId.
type GetProgrammesIdParams struct {
	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetResourcesParams defines parameters for GetResources.
type GetResourcesParams struct {
	// Organisation Begränsa urvalet till ett visst organisationselemet (owner).
	Organisation *openapi_types.UUID `form:"organisation,omitempty" json:"organisation,omitempty"`

	// MetaCreatedBefore Endast poster skapade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaCreatedBefore *time.Time `form:"meta.created.before,omitempty" json:"meta.created.before,omitempty"`

	// MetaCreatedAfter Endast poster skapade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaCreatedAfter *time.Time `form:"meta.created.after,omitempty" json:"meta.created.after,omitempty"`

	// MetaModifiedBefore Endast poster modifierade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaModifiedBefore *time.Time `form:"meta.modified.before,omitempty" json:"meta.modified.before,omitempty"`

	// MetaModifiedAfter Endast poster modifierade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaModifiedAfter *time.Time `form:"meta.modified.after,omitempty" json:"meta.modified.after,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool                      `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
	Sortkey              *GetResourcesParamsSortkey `form:"sortkey,omitempty" json:"sortkey,omitempty"`

	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetResourcesParamsSortkey defines parameters for GetResources.
type GetResourcesParamsSortkey string

// PostResourcesLookupParams defines parameters for PostResourcesLookup.
type PostResourcesLookupParams struct {
	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetResourcesIdParams defines parameters for GetResourcesId.
type GetResourcesIdParams struct {
	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetRoomsParams defines parameters for GetRooms.
type GetRoomsParams struct {
	// Organisation Begränsa urvalet till ett visst organisationselemet (owner).
	Organisation *openapi_types.UUID `form:"organisation,omitempty" json:"organisation,omitempty"`

	// MetaCreatedBefore Endast poster skapade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaCreatedBefore *time.Time `form:"meta.created.before,omitempty" json:"meta.created.before,omitempty"`

	// MetaCreatedAfter Endast poster skapade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaCreatedAfter *time.Time `form:"meta.created.after,omitempty" json:"meta.created.after,omitempty"`

	// MetaModifiedBefore Endast poster modifierade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaModifiedBefore *time.Time `form:"meta.modified.before,omitempty" json:"meta.modified.before,omitempty"`

	// MetaModifiedAfter Endast poster modifierade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaModifiedAfter *time.Time `form:"meta.modified.after,omitempty" json:"meta.modified.after,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool                  `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
	Sortkey              *GetRoomsParamsSortkey `form:"sortkey,omitempty" json:"sortkey,omitempty"`

	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetRoomsParamsSortkey defines parameters for GetRooms.
type GetRoomsParamsSortkey string

// PostRoomsLookupParams defines parameters for PostRoomsLookup.
type PostRoomsLookupParams struct {
	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetRoomsIdParams defines parameters for GetRoomsId.
type GetRoomsIdParams struct {
	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetSchoolUnitOfferingsParams defines parameters for GetSchoolUnitOfferings.
type GetSchoolUnitOfferingsParams struct {
	// Organisation Begränsa urvalet till ett visst organisationslement (offeredAt).
	Organisation *openapi_types.UUID `form:"organisation,omitempty" json:"organisation,omitempty"`

	// MetaCreatedBefore Endast poster skapade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaCreatedBefore *time.Time `form:"meta.created.before,omitempty" json:"meta.created.before,omitempty"`

	// MetaCreatedAfter Endast poster skapade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaCreatedAfter *time.Time `form:"meta.created.after,omitempty" json:"meta.created.after,omitempty"`

	// MetaModifiedBefore Endast poster modifierade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaModifiedBefore *time.Time `form:"meta.modified.before,omitempty" json:"meta.modified.before,omitempty"`

	// MetaModifiedAfter Endast poster modifierade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaModifiedAfter *time.Time `form:"meta.modified.after,omitempty" json:"meta.modified.after,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool                                `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
	Sortkey              *GetSchoolUnitOfferingsParamsSortkey `form:"sortkey,omitempty" json:"sortkey,omitempty"`

	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetSchoolUnitOfferingsParamsSortkey defines parameters for GetSchoolUnitOfferings.
type GetSchoolUnitOfferingsParamsSortkey string

// PostSchoolUnitOfferingsLookupParams defines parameters for PostSchoolUnitOfferingsLookup.
type PostSchoolUnitOfferingsLookupParams struct {
	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetSchoolUnitOfferingsIdParams defines parameters for GetSchoolUnitOfferingsId.
type GetSchoolUnitOfferingsIdParams struct {
	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetStudyplansParams defines parameters for GetStudyplans.
type GetStudyplansParams struct {
	// Student Begränsa urvalet till utpekade elever.
	Student *[]openapi_types.UUID `form:"student,omitempty" json:"student,omitempty"`

	// StartDateOnOrBefore Begränsa urvalet till studieplaner som har ett startDate värde innan eller på det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett endDate som ej är satt, tas alltid med.
	StartDateOnOrBefore *openapi_types.Date `form:"startDate.onOrBefore,omitempty" json:"startDate.onOrBefore,omitempty"`

	// StartDateOnOrAfter Begränsa urvalet till studieplaner som har ett startDate värde på eller efter det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett endDate som ej är satt, tas alltid med.
	StartDateOnOrAfter *openapi_types.Date `form:"startDate.onOrAfter,omitempty" json:"startDate.onOrAfter,omitempty"`

	// EndDateOnOrBefore Begränsa urvalet till studieplaner som har ett endDate värde innan eller på det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett endDate som ej är satt, tas alltid med.
	EndDateOnOrBefore *openapi_types.Date `form:"endDate.onOrBefore,omitempty" json:"endDate.onOrBefore,omitempty"`

	// EndDateOnOrAfter Begränsa urvalet till studieplaner som har ett endDate värde på eller efter det angivna datumet (RFC 3339-format, t.ex. "2016-10-15").
	// Poster med ett endDate som ej är satt, tas alltid med.
	EndDateOnOrAfter *openapi_types.Date `form:"endDate.onOrAfter,omitempty" json:"endDate.onOrAfter,omitempty"`

	// MetaCreatedBefore Endast poster skapade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaCreatedBefore *time.Time `form:"meta.created.before,omitempty" json:"meta.created.before,omitempty"`

	// MetaCreatedAfter Endast poster skapade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaCreatedAfter *time.Time `form:"meta.created.after,omitempty" json:"meta.created.after,omitempty"`

	// MetaModifiedBefore Endast poster modifierade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaModifiedBefore *time.Time `form:"meta.modified.before,omitempty" json:"meta.modified.before,omitempty"`

	// MetaModifiedAfter Endast poster modifierade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaModifiedAfter *time.Time `form:"meta.modified.after,omitempty" json:"meta.modified.after,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`

	// Sortkey Anger hur resultatet ska sorteras.
	Sortkey *GetStudyplansParamsSortkey `form:"sortkey,omitempty" json:"sortkey,omitempty"`

	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetStudyplansParamsSortkey defines parameters for GetStudyplans.
type GetStudyplansParamsSortkey string

// GetStudyplansIdParams defines parameters for GetStudyplansId.
type GetStudyplansIdParams struct {
	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetSubscriptionsParams defines parameters for GetSubscriptions.
type GetSubscriptionsParams struct {
	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetSyllabusesParams defines parameters for GetSyllabuses.
type GetSyllabusesParams struct {
	// MetaCreatedBefore Endast poster skapade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaCreatedBefore *time.Time `form:"meta.created.before,omitempty" json:"meta.created.before,omitempty"`

	// MetaCreatedAfter Endast poster skapade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaCreatedAfter *time.Time `form:"meta.created.after,omitempty" json:"meta.created.after,omitempty"`

	// MetaModifiedBefore Endast poster modifierade på eller före detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Inkluderande.
	MetaModifiedBefore *time.Time `form:"meta.modified.before,omitempty" json:"meta.modified.before,omitempty"`

	// MetaModifiedAfter Endast poster modifierade efter detta timestamp (RFC 3339 format, tex "2015-12-12T10:30:00+01:00"). Exkluderande.
	MetaModifiedAfter *time.Time `form:"meta.modified.after,omitempty" json:"meta.modified.after,omitempty"`

	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`

	// Sortkey Anger hur resultatet ska sorteras.
	Sortkey *GetSyllabusesParamsSortkey `form:"sortkey,omitempty" json:"sortkey,omitempty"`

	// Limit Antal poster som ska visas i resultatet. Utelämnas det så returnas så många poster som möjligt av servern, se `pageToken`.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Ett opakt värde som servern givit som svar på en tidigare ställd fråga. Kan inte komibineras med andra filter men väl med `limit`.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetSyllabusesParamsSortkey defines parameters for GetSyllabuses.
type GetSyllabusesParamsSortkey string

// PostSyllabusesLookupParams defines parameters for PostSyllabusesLookup.
type PostSyllabusesLookupParams struct {
	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// GetSyllabusesIdParams defines parameters for GetSyllabusesId.
type GetSyllabusesIdParams struct {
	// ExpandReferenceNames Returnera `displayName` för alla refererade objekt.
	ExpandReferenceNames *bool `form:"expandReferenceNames,omitempty" json:"expandReferenceNames,omitempty"`
}

// PostAbsencesJSONRequestBody defines body for PostAbsences for application/json ContentType.
type PostAbsencesJSONRequestBody = Absence

// PostAbsencesLookupJSONRequestBody defines body for PostAbsencesLookup for application/json ContentType.
type PostAbsencesLookupJSONRequestBody = IdLookup

// PostActivitiesLookupJSONRequestBody defines body for PostActivitiesLookup for application/json ContentType.
type PostActivitiesLookupJSONRequestBody = ActivitiesLookupPostRequest

// PostAttendanceEventsJSONRequestBody defines body for PostAttendanceEvents for application/json ContentType.
type PostAttendanceEventsJSONRequestBody = AttendanceEvent

// PostAttendanceEventsLookupJSONRequestBody defines body for PostAttendanceEventsLookup for application/json ContentType.
type PostAttendanceEventsLookupJSONRequestBody = AttendanceEventsLookupPostRequest

// PostAttendanceScheduleJSONRequestBody defines body for PostAttendanceSchedule for application/json ContentType.
type PostAttendanceScheduleJSONRequestBody = AttendanceSchedule

// PostAttendanceScheduleLookupJSONRequestBody defines body for PostAttendanceScheduleLookup for application/json ContentType.
type PostAttendanceScheduleLookupJSONRequestBody = AttendanceScheduleLookupPostRequest

// PostAttendancesJSONRequestBody defines body for PostAttendances for application/json ContentType.
type PostAttendancesJSONRequestBody = Attendance

// PostAttendancesLookupJSONRequestBody defines body for PostAttendancesLookup for application/json ContentType.
type PostAttendancesLookupJSONRequestBody = AttendancesLookupPostRequest

// PostCalendarEventsLookupJSONRequestBody defines body for PostCalendarEventsLookup for application/json ContentType.
type PostCalendarEventsLookupJSONRequestBody = CalendarEventsLookupPostRequest

// PostDutiesLookupJSONRequestBody defines body for PostDutiesLookup for application/json ContentType.
type PostDutiesLookupJSONRequestBody = IdLookup

// PostGradesLookupJSONRequestBody defines body for PostGradesLookup for application/json ContentType.
type PostGradesLookupJSONRequestBody = IdLookup

// PostGroupsLookupJSONRequestBody defines body for PostGroupsLookup for application/json ContentType.
type PostGroupsLookupJSONRequestBody = IdLookup

// PostLogJSONRequestBody defines body for PostLog for application/json ContentType.
type PostLogJSONRequestBody = LogEntry

// PostOrganisationsLookupJSONRequestBody defines body for PostOrganisationsLookup for application/json ContentType.
type PostOrganisationsLookupJSONRequestBody = OrganisationsLookupPostRequest

// PostPersonsLookupJSONRequestBody defines body for PostPersonsLookup for application/json ContentType.
type PostPersonsLookupJSONRequestBody = PersonsLookupPostRequest

// PostPlacementsLookupJSONRequestBody defines body for PostPlacementsLookup for application/json ContentType.
type PostPlacementsLookupJSONRequestBody = PlacementsLookupPostRequest

// PostProgrammesLookupJSONRequestBody defines body for PostProgrammesLookup for application/json ContentType.
type PostProgrammesLookupJSONRequestBody = IdLookup

// PostResourcesLookupJSONRequestBody defines body for PostResourcesLookup for application/json ContentType.
type PostResourcesLookupJSONRequestBody = IdLookup

// PostRoomsLookupJSONRequestBody defines body for PostRoomsLookup for application/json ContentType.
type PostRoomsLookupJSONRequestBody = IdLookup

// PostSchoolUnitOfferingsLookupJSONRequestBody defines body for PostSchoolUnitOfferingsLookup for application/json ContentType.
type PostSchoolUnitOfferingsLookupJSONRequestBody = IdLookup

// PostStatisticsJSONRequestBody defines body for PostStatistics for application/json ContentType.
type PostStatisticsJSONRequestBody = StatisticsEntry

// PostSubscriptionsJSONRequestBody defines body for PostSubscriptions for application/json ContentType.
type PostSubscriptionsJSONRequestBody = CreateSubscription

// PostSyllabusesLookupJSONRequestBody defines body for PostSyllabusesLookup for application/json ContentType.
type PostSyllabusesLookupJSONRequestBody = IdLookup

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAbsences request
	GetAbsences(ctx context.Context, params *GetAbsencesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAbsences request with any body
	PostAbsencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAbsences(ctx context.Context, body PostAbsencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAbsencesLookup request with any body
	PostAbsencesLookupWithBody(ctx context.Context, params *PostAbsencesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAbsencesLookup(ctx context.Context, params *PostAbsencesLookupParams, body PostAbsencesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAbsencesId request
	GetAbsencesId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivities request
	GetActivities(ctx context.Context, params *GetActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostActivitiesLookup request with any body
	PostActivitiesLookupWithBody(ctx context.Context, params *PostActivitiesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostActivitiesLookup(ctx context.Context, params *PostActivitiesLookupParams, body PostActivitiesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivitiesId request
	GetActivitiesId(ctx context.Context, id openapi_types.UUID, params *GetActivitiesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAggregatedAttendance request
	GetAggregatedAttendance(ctx context.Context, params *GetAggregatedAttendanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttendanceEvents request
	GetAttendanceEvents(ctx context.Context, params *GetAttendanceEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAttendanceEvents request with any body
	PostAttendanceEventsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAttendanceEvents(ctx context.Context, body PostAttendanceEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAttendanceEventsLookup request with any body
	PostAttendanceEventsLookupWithBody(ctx context.Context, params *PostAttendanceEventsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAttendanceEventsLookup(ctx context.Context, params *PostAttendanceEventsLookupParams, body PostAttendanceEventsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAttendanceEventsId request
	DeleteAttendanceEventsId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttendanceEventsId request
	GetAttendanceEventsId(ctx context.Context, id openapi_types.UUID, params *GetAttendanceEventsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttendanceSchedule request
	GetAttendanceSchedule(ctx context.Context, params *GetAttendanceScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAttendanceSchedule request with any body
	PostAttendanceScheduleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAttendanceSchedule(ctx context.Context, body PostAttendanceScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAttendanceScheduleLookup request with any body
	PostAttendanceScheduleLookupWithBody(ctx context.Context, params *PostAttendanceScheduleLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAttendanceScheduleLookup(ctx context.Context, params *PostAttendanceScheduleLookupParams, body PostAttendanceScheduleLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAttendanceScheduleId request
	DeleteAttendanceScheduleId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttendanceScheduleId request
	GetAttendanceScheduleId(ctx context.Context, id openapi_types.UUID, params *GetAttendanceScheduleIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttendances request
	GetAttendances(ctx context.Context, params *GetAttendancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAttendances request with any body
	PostAttendancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAttendances(ctx context.Context, body PostAttendancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAttendancesLookup request with any body
	PostAttendancesLookupWithBody(ctx context.Context, params *PostAttendancesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAttendancesLookup(ctx context.Context, params *PostAttendancesLookupParams, body PostAttendancesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAttendancesId request
	DeleteAttendancesId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttendancesId request
	GetAttendancesId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCalendarEvents request
	GetCalendarEvents(ctx context.Context, params *GetCalendarEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCalendarEventsLookup request with any body
	PostCalendarEventsLookupWithBody(ctx context.Context, params *PostCalendarEventsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCalendarEventsLookup(ctx context.Context, params *PostCalendarEventsLookupParams, body PostCalendarEventsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCalendarEventsId request
	GetCalendarEventsId(ctx context.Context, id openapi_types.UUID, params *GetCalendarEventsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeletedEntities request
	GetDeletedEntities(ctx context.Context, params *GetDeletedEntitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDuties request
	GetDuties(ctx context.Context, params *GetDutiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDutiesLookup request with any body
	PostDutiesLookupWithBody(ctx context.Context, params *PostDutiesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDutiesLookup(ctx context.Context, params *PostDutiesLookupParams, body PostDutiesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDutiesId request
	GetDutiesId(ctx context.Context, id openapi_types.UUID, params *GetDutiesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGrades request
	GetGrades(ctx context.Context, params *GetGradesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGradesLookup request with any body
	PostGradesLookupWithBody(ctx context.Context, params *PostGradesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostGradesLookup(ctx context.Context, params *PostGradesLookupParams, body PostGradesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGradesId request
	GetGradesId(ctx context.Context, id openapi_types.UUID, params *GetGradesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroups request
	GetGroups(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGroupsLookup request with any body
	PostGroupsLookupWithBody(ctx context.Context, params *PostGroupsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostGroupsLookup(ctx context.Context, params *PostGroupsLookupParams, body PostGroupsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupsId request
	GetGroupsId(ctx context.Context, id openapi_types.UUID, params *GetGroupsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLog request with any body
	PostLogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLog(ctx context.Context, body PostLogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganisations request
	GetOrganisations(ctx context.Context, params *GetOrganisationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrganisationsLookup request with any body
	PostOrganisationsLookupWithBody(ctx context.Context, params *PostOrganisationsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrganisationsLookup(ctx context.Context, params *PostOrganisationsLookupParams, body PostOrganisationsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganisationsId request
	GetOrganisationsId(ctx context.Context, id openapi_types.UUID, params *GetOrganisationsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersons request
	GetPersons(ctx context.Context, params *GetPersonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPersonsLookup request with any body
	PostPersonsLookupWithBody(ctx context.Context, params *PostPersonsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPersonsLookup(ctx context.Context, params *PostPersonsLookupParams, body PostPersonsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonsId request
	GetPersonsId(ctx context.Context, id openapi_types.UUID, params *GetPersonsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlacements request
	GetPlacements(ctx context.Context, params *GetPlacementsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPlacementsLookup request with any body
	PostPlacementsLookupWithBody(ctx context.Context, params *PostPlacementsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPlacementsLookup(ctx context.Context, params *PostPlacementsLookupParams, body PostPlacementsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlacementsId request
	GetPlacementsId(ctx context.Context, id openapi_types.UUID, params *GetPlacementsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProgrammes request
	GetProgrammes(ctx context.Context, params *GetProgrammesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProgrammesLookup request with any body
	PostProgrammesLookupWithBody(ctx context.Context, params *PostProgrammesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProgrammesLookup(ctx context.Context, params *PostProgrammesLookupParams, body PostProgrammesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProgrammesId request
	GetProgrammesId(ctx context.Context, id openapi_types.UUID, params *GetProgrammesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResources request
	GetResources(ctx context.Context, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostResourcesLookup request with any body
	PostResourcesLookupWithBody(ctx context.Context, params *PostResourcesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostResourcesLookup(ctx context.Context, params *PostResourcesLookupParams, body PostResourcesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourcesId request
	GetResourcesId(ctx context.Context, id openapi_types.UUID, params *GetResourcesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRooms request
	GetRooms(ctx context.Context, params *GetRoomsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRoomsLookup request with any body
	PostRoomsLookupWithBody(ctx context.Context, params *PostRoomsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRoomsLookup(ctx context.Context, params *PostRoomsLookupParams, body PostRoomsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoomsId request
	GetRoomsId(ctx context.Context, id openapi_types.UUID, params *GetRoomsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchoolUnitOfferings request
	GetSchoolUnitOfferings(ctx context.Context, params *GetSchoolUnitOfferingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSchoolUnitOfferingsLookup request with any body
	PostSchoolUnitOfferingsLookupWithBody(ctx context.Context, params *PostSchoolUnitOfferingsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSchoolUnitOfferingsLookup(ctx context.Context, params *PostSchoolUnitOfferingsLookupParams, body PostSchoolUnitOfferingsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchoolUnitOfferingsId request
	GetSchoolUnitOfferingsId(ctx context.Context, id openapi_types.UUID, params *GetSchoolUnitOfferingsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStatistics request with any body
	PostStatisticsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostStatistics(ctx context.Context, body PostStatisticsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStudyplans request
	GetStudyplans(ctx context.Context, params *GetStudyplansParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStudyplansId request
	GetStudyplansId(ctx context.Context, id openapi_types.UUID, params *GetStudyplansIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptions request
	GetSubscriptions(ctx context.Context, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSubscriptions request with any body
	PostSubscriptionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSubscriptions(ctx context.Context, body PostSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubscriptionsId request
	DeleteSubscriptionsId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionsId request
	GetSubscriptionsId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSubscriptionsId request
	PatchSubscriptionsId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyllabuses request
	GetSyllabuses(ctx context.Context, params *GetSyllabusesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSyllabusesLookup request with any body
	PostSyllabusesLookupWithBody(ctx context.Context, params *PostSyllabusesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSyllabusesLookup(ctx context.Context, params *PostSyllabusesLookupParams, body PostSyllabusesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyllabusesId request
	GetSyllabusesId(ctx context.Context, id openapi_types.UUID, params *GetSyllabusesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAbsences(ctx context.Context, params *GetAbsencesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAbsencesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAbsencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAbsencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAbsences(ctx context.Context, body PostAbsencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAbsencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAbsencesLookupWithBody(ctx context.Context, params *PostAbsencesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAbsencesLookupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAbsencesLookup(ctx context.Context, params *PostAbsencesLookupParams, body PostAbsencesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAbsencesLookupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAbsencesId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAbsencesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivities(ctx context.Context, params *GetActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostActivitiesLookupWithBody(ctx context.Context, params *PostActivitiesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostActivitiesLookupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostActivitiesLookup(ctx context.Context, params *PostActivitiesLookupParams, body PostActivitiesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostActivitiesLookupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivitiesId(ctx context.Context, id openapi_types.UUID, params *GetActivitiesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivitiesIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAggregatedAttendance(ctx context.Context, params *GetAggregatedAttendanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAggregatedAttendanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttendanceEvents(ctx context.Context, params *GetAttendanceEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttendanceEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAttendanceEventsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAttendanceEventsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAttendanceEvents(ctx context.Context, body PostAttendanceEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAttendanceEventsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAttendanceEventsLookupWithBody(ctx context.Context, params *PostAttendanceEventsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAttendanceEventsLookupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAttendanceEventsLookup(ctx context.Context, params *PostAttendanceEventsLookupParams, body PostAttendanceEventsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAttendanceEventsLookupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAttendanceEventsId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAttendanceEventsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttendanceEventsId(ctx context.Context, id openapi_types.UUID, params *GetAttendanceEventsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttendanceEventsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttendanceSchedule(ctx context.Context, params *GetAttendanceScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttendanceScheduleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAttendanceScheduleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAttendanceScheduleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAttendanceSchedule(ctx context.Context, body PostAttendanceScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAttendanceScheduleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAttendanceScheduleLookupWithBody(ctx context.Context, params *PostAttendanceScheduleLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAttendanceScheduleLookupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAttendanceScheduleLookup(ctx context.Context, params *PostAttendanceScheduleLookupParams, body PostAttendanceScheduleLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAttendanceScheduleLookupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAttendanceScheduleId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAttendanceScheduleIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttendanceScheduleId(ctx context.Context, id openapi_types.UUID, params *GetAttendanceScheduleIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttendanceScheduleIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttendances(ctx context.Context, params *GetAttendancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttendancesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAttendancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAttendancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAttendances(ctx context.Context, body PostAttendancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAttendancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAttendancesLookupWithBody(ctx context.Context, params *PostAttendancesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAttendancesLookupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAttendancesLookup(ctx context.Context, params *PostAttendancesLookupParams, body PostAttendancesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAttendancesLookupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAttendancesId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAttendancesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttendancesId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttendancesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCalendarEvents(ctx context.Context, params *GetCalendarEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCalendarEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCalendarEventsLookupWithBody(ctx context.Context, params *PostCalendarEventsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCalendarEventsLookupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCalendarEventsLookup(ctx context.Context, params *PostCalendarEventsLookupParams, body PostCalendarEventsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCalendarEventsLookupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCalendarEventsId(ctx context.Context, id openapi_types.UUID, params *GetCalendarEventsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCalendarEventsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeletedEntities(ctx context.Context, params *GetDeletedEntitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeletedEntitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDuties(ctx context.Context, params *GetDutiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDutiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDutiesLookupWithBody(ctx context.Context, params *PostDutiesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDutiesLookupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDutiesLookup(ctx context.Context, params *PostDutiesLookupParams, body PostDutiesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDutiesLookupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDutiesId(ctx context.Context, id openapi_types.UUID, params *GetDutiesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDutiesIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGrades(ctx context.Context, params *GetGradesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGradesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGradesLookupWithBody(ctx context.Context, params *PostGradesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGradesLookupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGradesLookup(ctx context.Context, params *PostGradesLookupParams, body PostGradesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGradesLookupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGradesId(ctx context.Context, id openapi_types.UUID, params *GetGradesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGradesIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroups(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGroupsLookupWithBody(ctx context.Context, params *PostGroupsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGroupsLookupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGroupsLookup(ctx context.Context, params *PostGroupsLookupParams, body PostGroupsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGroupsLookupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupsId(ctx context.Context, id openapi_types.UUID, params *GetGroupsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLogRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLog(ctx context.Context, body PostLogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLogRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganisations(ctx context.Context, params *GetOrganisationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganisationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrganisationsLookupWithBody(ctx context.Context, params *PostOrganisationsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrganisationsLookupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrganisationsLookup(ctx context.Context, params *PostOrganisationsLookupParams, body PostOrganisationsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrganisationsLookupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganisationsId(ctx context.Context, id openapi_types.UUID, params *GetOrganisationsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganisationsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersons(ctx context.Context, params *GetPersonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPersonsLookupWithBody(ctx context.Context, params *PostPersonsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPersonsLookupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPersonsLookup(ctx context.Context, params *PostPersonsLookupParams, body PostPersonsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPersonsLookupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonsId(ctx context.Context, id openapi_types.UUID, params *GetPersonsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlacements(ctx context.Context, params *GetPlacementsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlacementsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPlacementsLookupWithBody(ctx context.Context, params *PostPlacementsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPlacementsLookupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPlacementsLookup(ctx context.Context, params *PostPlacementsLookupParams, body PostPlacementsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPlacementsLookupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlacementsId(ctx context.Context, id openapi_types.UUID, params *GetPlacementsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlacementsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProgrammes(ctx context.Context, params *GetProgrammesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgrammesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProgrammesLookupWithBody(ctx context.Context, params *PostProgrammesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProgrammesLookupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProgrammesLookup(ctx context.Context, params *PostProgrammesLookupParams, body PostProgrammesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProgrammesLookupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProgrammesId(ctx context.Context, id openapi_types.UUID, params *GetProgrammesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgrammesIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResources(ctx context.Context, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourcesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostResourcesLookupWithBody(ctx context.Context, params *PostResourcesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostResourcesLookupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostResourcesLookup(ctx context.Context, params *PostResourcesLookupParams, body PostResourcesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostResourcesLookupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourcesId(ctx context.Context, id openapi_types.UUID, params *GetResourcesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourcesIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRooms(ctx context.Context, params *GetRoomsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoomsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRoomsLookupWithBody(ctx context.Context, params *PostRoomsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRoomsLookupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRoomsLookup(ctx context.Context, params *PostRoomsLookupParams, body PostRoomsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRoomsLookupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoomsId(ctx context.Context, id openapi_types.UUID, params *GetRoomsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoomsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchoolUnitOfferings(ctx context.Context, params *GetSchoolUnitOfferingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchoolUnitOfferingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSchoolUnitOfferingsLookupWithBody(ctx context.Context, params *PostSchoolUnitOfferingsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSchoolUnitOfferingsLookupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSchoolUnitOfferingsLookup(ctx context.Context, params *PostSchoolUnitOfferingsLookupParams, body PostSchoolUnitOfferingsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSchoolUnitOfferingsLookupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchoolUnitOfferingsId(ctx context.Context, id openapi_types.UUID, params *GetSchoolUnitOfferingsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchoolUnitOfferingsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStatisticsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStatisticsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStatistics(ctx context.Context, body PostStatisticsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStatisticsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStudyplans(ctx context.Context, params *GetStudyplansParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStudyplansRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStudyplansId(ctx context.Context, id openapi_types.UUID, params *GetStudyplansIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStudyplansIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptions(ctx context.Context, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSubscriptionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSubscriptionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSubscriptions(ctx context.Context, body PostSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSubscriptionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubscriptionsId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubscriptionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionsId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSubscriptionsId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSubscriptionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyllabuses(ctx context.Context, params *GetSyllabusesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyllabusesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSyllabusesLookupWithBody(ctx context.Context, params *PostSyllabusesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSyllabusesLookupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSyllabusesLookup(ctx context.Context, params *PostSyllabusesLookupParams, body PostSyllabusesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSyllabusesLookupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyllabusesId(ctx context.Context, id openapi_types.UUID, params *GetSyllabusesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyllabusesIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAbsencesRequest generates requests for GetAbsences
func NewGetAbsencesRequest(server string, params *GetAbsencesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/absences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Organisation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organisation", runtime.ParamLocationQuery, *params.Organisation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Student != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "student", runtime.ParamLocationQuery, *params.Student); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RegisteredBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "registeredBy", runtime.ParamLocationQuery, *params.RegisteredBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTimeOnOrBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime.onOrBefore", runtime.ParamLocationQuery, *params.StartTimeOnOrBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTimeOnOrAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime.onOrAfter", runtime.ParamLocationQuery, *params.StartTimeOnOrAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTimeOnOrBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endTime.onOrBefore", runtime.ParamLocationQuery, *params.EndTimeOnOrBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTimeOnOrAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endTime.onOrAfter", runtime.ParamLocationQuery, *params.EndTimeOnOrAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.before", runtime.ParamLocationQuery, *params.MetaCreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.after", runtime.ParamLocationQuery, *params.MetaCreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.before", runtime.ParamLocationQuery, *params.MetaModifiedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.after", runtime.ParamLocationQuery, *params.MetaModifiedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sortkey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortkey", runtime.ParamLocationQuery, *params.Sortkey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAbsencesRequest calls the generic PostAbsences builder with application/json body
func NewPostAbsencesRequest(server string, body PostAbsencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAbsencesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAbsencesRequestWithBody generates requests for PostAbsences with any type of body
func NewPostAbsencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/absences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostAbsencesLookupRequest calls the generic PostAbsencesLookup builder with application/json body
func NewPostAbsencesLookupRequest(server string, params *PostAbsencesLookupParams, body PostAbsencesLookupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAbsencesLookupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAbsencesLookupRequestWithBody generates requests for PostAbsencesLookup with any type of body
func NewPostAbsencesLookupRequestWithBody(server string, params *PostAbsencesLookupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/absences/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAbsencesIdRequest generates requests for GetAbsencesId
func NewGetAbsencesIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/absences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActivitiesRequest generates requests for GetActivities
func NewGetActivitiesRequest(server string, params *GetActivitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Member != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "member", runtime.ParamLocationQuery, *params.Member); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Teacher != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teacher", runtime.ParamLocationQuery, *params.Teacher); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Organisation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organisation", runtime.ParamLocationQuery, *params.Organisation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Group != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartDateOnOrBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate.onOrBefore", runtime.ParamLocationQuery, *params.StartDateOnOrBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartDateOnOrAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate.onOrAfter", runtime.ParamLocationQuery, *params.StartDateOnOrAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndDateOnOrBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate.onOrBefore", runtime.ParamLocationQuery, *params.EndDateOnOrBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndDateOnOrAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate.onOrAfter", runtime.ParamLocationQuery, *params.EndDateOnOrAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.before", runtime.ParamLocationQuery, *params.MetaCreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.after", runtime.ParamLocationQuery, *params.MetaCreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.before", runtime.ParamLocationQuery, *params.MetaModifiedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.after", runtime.ParamLocationQuery, *params.MetaModifiedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sortkey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortkey", runtime.ParamLocationQuery, *params.Sortkey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostActivitiesLookupRequest calls the generic PostActivitiesLookup builder with application/json body
func NewPostActivitiesLookupRequest(server string, params *PostActivitiesLookupParams, body PostActivitiesLookupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostActivitiesLookupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostActivitiesLookupRequestWithBody generates requests for PostActivitiesLookup with any type of body
func NewPostActivitiesLookupRequestWithBody(server string, params *PostActivitiesLookupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetActivitiesIdRequest generates requests for GetActivitiesId
func NewGetActivitiesIdRequest(server string, id openapi_types.UUID, params *GetActivitiesIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAggregatedAttendanceRequest generates requests for GetAggregatedAttendance
func NewGetAggregatedAttendanceRequest(server string, params *GetAggregatedAttendanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aggregatedAttendance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, params.StartDate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, params.EndDate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Organisation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organisation", runtime.ParamLocationQuery, *params.Organisation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SchoolType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schoolType", runtime.ParamLocationQuery, *params.SchoolType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Student != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "student", runtime.ParamLocationQuery, *params.Student); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAttendanceEventsRequest generates requests for GetAttendanceEvents
func NewGetAttendanceEventsRequest(server string, params *GetAttendanceEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attendanceEvents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Group != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Person != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "person", runtime.ParamLocationQuery, *params.Person); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.before", runtime.ParamLocationQuery, *params.MetaCreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.after", runtime.ParamLocationQuery, *params.MetaCreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.before", runtime.ParamLocationQuery, *params.MetaModifiedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.after", runtime.ParamLocationQuery, *params.MetaModifiedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAttendanceEventsRequest calls the generic PostAttendanceEvents builder with application/json body
func NewPostAttendanceEventsRequest(server string, body PostAttendanceEventsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAttendanceEventsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAttendanceEventsRequestWithBody generates requests for PostAttendanceEvents with any type of body
func NewPostAttendanceEventsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attendanceEvents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostAttendanceEventsLookupRequest calls the generic PostAttendanceEventsLookup builder with application/json body
func NewPostAttendanceEventsLookupRequest(server string, params *PostAttendanceEventsLookupParams, body PostAttendanceEventsLookupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAttendanceEventsLookupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAttendanceEventsLookupRequestWithBody generates requests for PostAttendanceEventsLookup with any type of body
func NewPostAttendanceEventsLookupRequestWithBody(server string, params *PostAttendanceEventsLookupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attendanceEvents/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAttendanceEventsIdRequest generates requests for DeleteAttendanceEventsId
func NewDeleteAttendanceEventsIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attendanceEvents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAttendanceEventsIdRequest generates requests for GetAttendanceEventsId
func NewGetAttendanceEventsIdRequest(server string, id openapi_types.UUID, params *GetAttendanceEventsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attendanceEvents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAttendanceScheduleRequest generates requests for GetAttendanceSchedule
func NewGetAttendanceScheduleRequest(server string, params *GetAttendanceScheduleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attendanceSchedule")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Placement != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "placement", runtime.ParamLocationQuery, *params.Placement); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Group != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartDateOnOrBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate.onOrBefore", runtime.ParamLocationQuery, *params.StartDateOnOrBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartDateOnOrAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate.onOrAfter", runtime.ParamLocationQuery, *params.StartDateOnOrAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndDateOnOrBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate.onOrBefore", runtime.ParamLocationQuery, *params.EndDateOnOrBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndDateOnOrAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate.onOrAfter", runtime.ParamLocationQuery, *params.EndDateOnOrAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.before", runtime.ParamLocationQuery, *params.MetaCreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.after", runtime.ParamLocationQuery, *params.MetaCreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.before", runtime.ParamLocationQuery, *params.MetaModifiedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.after", runtime.ParamLocationQuery, *params.MetaModifiedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAttendanceScheduleRequest calls the generic PostAttendanceSchedule builder with application/json body
func NewPostAttendanceScheduleRequest(server string, body PostAttendanceScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAttendanceScheduleRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAttendanceScheduleRequestWithBody generates requests for PostAttendanceSchedule with any type of body
func NewPostAttendanceScheduleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attendanceSchedule")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostAttendanceScheduleLookupRequest calls the generic PostAttendanceScheduleLookup builder with application/json body
func NewPostAttendanceScheduleLookupRequest(server string, params *PostAttendanceScheduleLookupParams, body PostAttendanceScheduleLookupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAttendanceScheduleLookupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAttendanceScheduleLookupRequestWithBody generates requests for PostAttendanceScheduleLookup with any type of body
func NewPostAttendanceScheduleLookupRequestWithBody(server string, params *PostAttendanceScheduleLookupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attendanceSchedule/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAttendanceScheduleIdRequest generates requests for DeleteAttendanceScheduleId
func NewDeleteAttendanceScheduleIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attendanceSchedule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAttendanceScheduleIdRequest generates requests for GetAttendanceScheduleId
func NewGetAttendanceScheduleIdRequest(server string, id openapi_types.UUID, params *GetAttendanceScheduleIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attendanceSchedule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAttendancesRequest generates requests for GetAttendances
func NewGetAttendancesRequest(server string, params *GetAttendancesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attendances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Student != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "student", runtime.ParamLocationQuery, *params.Student); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Organisation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organisation", runtime.ParamLocationQuery, *params.Organisation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CalendarEvent != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "calendarEvent", runtime.ParamLocationQuery, *params.CalendarEvent); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.before", runtime.ParamLocationQuery, *params.MetaCreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.after", runtime.ParamLocationQuery, *params.MetaCreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.before", runtime.ParamLocationQuery, *params.MetaModifiedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.after", runtime.ParamLocationQuery, *params.MetaModifiedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAttendancesRequest calls the generic PostAttendances builder with application/json body
func NewPostAttendancesRequest(server string, body PostAttendancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAttendancesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAttendancesRequestWithBody generates requests for PostAttendances with any type of body
func NewPostAttendancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attendances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostAttendancesLookupRequest calls the generic PostAttendancesLookup builder with application/json body
func NewPostAttendancesLookupRequest(server string, params *PostAttendancesLookupParams, body PostAttendancesLookupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAttendancesLookupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAttendancesLookupRequestWithBody generates requests for PostAttendancesLookup with any type of body
func NewPostAttendancesLookupRequestWithBody(server string, params *PostAttendancesLookupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attendances/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAttendancesIdRequest generates requests for DeleteAttendancesId
func NewDeleteAttendancesIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attendances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAttendancesIdRequest generates requests for GetAttendancesId
func NewGetAttendancesIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attendances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCalendarEventsRequest generates requests for GetCalendarEvents
func NewGetCalendarEventsRequest(server string, params *GetCalendarEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEvents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime.onOrAfter", runtime.ParamLocationQuery, params.StartTimeOnOrAfter); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime.onOrBefore", runtime.ParamLocationQuery, params.StartTimeOnOrBefore); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.EndTimeOnOrBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endTime.onOrBefore", runtime.ParamLocationQuery, *params.EndTimeOnOrBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndTimeOnOrAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endTime.onOrAfter", runtime.ParamLocationQuery, *params.EndTimeOnOrAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Activity != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "activity", runtime.ParamLocationQuery, *params.Activity); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Student != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "student", runtime.ParamLocationQuery, *params.Student); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Teacher != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teacher", runtime.ParamLocationQuery, *params.Teacher); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Organisation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organisation", runtime.ParamLocationQuery, *params.Organisation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Group != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.before", runtime.ParamLocationQuery, *params.MetaCreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.after", runtime.ParamLocationQuery, *params.MetaCreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.before", runtime.ParamLocationQuery, *params.MetaModifiedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.after", runtime.ParamLocationQuery, *params.MetaModifiedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sortkey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortkey", runtime.ParamLocationQuery, *params.Sortkey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCalendarEventsLookupRequest calls the generic PostCalendarEventsLookup builder with application/json body
func NewPostCalendarEventsLookupRequest(server string, params *PostCalendarEventsLookupParams, body PostCalendarEventsLookupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCalendarEventsLookupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostCalendarEventsLookupRequestWithBody generates requests for PostCalendarEventsLookup with any type of body
func NewPostCalendarEventsLookupRequestWithBody(server string, params *PostCalendarEventsLookupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEvents/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCalendarEventsIdRequest generates requests for GetCalendarEventsId
func NewGetCalendarEventsIdRequest(server string, id openapi_types.UUID, params *GetCalendarEventsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEvents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeletedEntitiesRequest generates requests for GetDeletedEntities
func NewGetDeletedEntitiesRequest(server string, params *GetDeletedEntitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deletedEntities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Entities != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entities", runtime.ParamLocationQuery, *params.Entities); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDutiesRequest generates requests for GetDuties
func NewGetDutiesRequest(server string, params *GetDutiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/duties")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Organisation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organisation", runtime.ParamLocationQuery, *params.Organisation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DutyRole != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dutyRole", runtime.ParamLocationQuery, *params.DutyRole); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Person != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "person", runtime.ParamLocationQuery, *params.Person); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartDateOnOrBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate.onOrBefore", runtime.ParamLocationQuery, *params.StartDateOnOrBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartDateOnOrAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate.onOrAfter", runtime.ParamLocationQuery, *params.StartDateOnOrAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndDateOnOrBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate.onOrBefore", runtime.ParamLocationQuery, *params.EndDateOnOrBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndDateOnOrAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate.onOrAfter", runtime.ParamLocationQuery, *params.EndDateOnOrAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.before", runtime.ParamLocationQuery, *params.MetaCreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.after", runtime.ParamLocationQuery, *params.MetaCreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.before", runtime.ParamLocationQuery, *params.MetaModifiedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.after", runtime.ParamLocationQuery, *params.MetaModifiedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sortkey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortkey", runtime.ParamLocationQuery, *params.Sortkey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostDutiesLookupRequest calls the generic PostDutiesLookup builder with application/json body
func NewPostDutiesLookupRequest(server string, params *PostDutiesLookupParams, body PostDutiesLookupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDutiesLookupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostDutiesLookupRequestWithBody generates requests for PostDutiesLookup with any type of body
func NewPostDutiesLookupRequestWithBody(server string, params *PostDutiesLookupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/duties/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDutiesIdRequest generates requests for GetDutiesId
func NewGetDutiesIdRequest(server string, id openapi_types.UUID, params *GetDutiesIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/duties/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGradesRequest generates requests for GetGrades
func NewGetGradesRequest(server string, params *GetGradesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/grades")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Organisation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organisation", runtime.ParamLocationQuery, *params.Organisation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Student != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "student", runtime.ParamLocationQuery, *params.Student); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RegisteredBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "registeredBy", runtime.ParamLocationQuery, *params.RegisteredBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GradingTeacher != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gradingTeacher", runtime.ParamLocationQuery, *params.GradingTeacher); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RegisteredDateOnOrAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "registeredDate.onOrAfter", runtime.ParamLocationQuery, *params.RegisteredDateOnOrAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RegisteredDateOnOrBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "registeredDate.onOrBefore", runtime.ParamLocationQuery, *params.RegisteredDateOnOrBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.before", runtime.ParamLocationQuery, *params.MetaCreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.after", runtime.ParamLocationQuery, *params.MetaCreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.before", runtime.ParamLocationQuery, *params.MetaModifiedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.after", runtime.ParamLocationQuery, *params.MetaModifiedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sortkey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortkey", runtime.ParamLocationQuery, *params.Sortkey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostGradesLookupRequest calls the generic PostGradesLookup builder with application/json body
func NewPostGradesLookupRequest(server string, params *PostGradesLookupParams, body PostGradesLookupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostGradesLookupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostGradesLookupRequestWithBody generates requests for PostGradesLookup with any type of body
func NewPostGradesLookupRequestWithBody(server string, params *PostGradesLookupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/grades/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGradesIdRequest generates requests for GetGradesId
func NewGetGradesIdRequest(server string, id openapi_types.UUID, params *GetGradesIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/grades/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupsRequest generates requests for GetGroups
func NewGetGroupsRequest(server string, params *GetGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.GroupType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupType", runtime.ParamLocationQuery, *params.GroupType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SchoolTypes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schoolTypes", runtime.ParamLocationQuery, *params.SchoolTypes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Organisation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organisation", runtime.ParamLocationQuery, *params.Organisation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartDateOnOrBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate.onOrBefore", runtime.ParamLocationQuery, *params.StartDateOnOrBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartDateOnOrAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate.onOrAfter", runtime.ParamLocationQuery, *params.StartDateOnOrAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndDateOnOrBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate.onOrBefore", runtime.ParamLocationQuery, *params.EndDateOnOrBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndDateOnOrAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate.onOrAfter", runtime.ParamLocationQuery, *params.EndDateOnOrAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.before", runtime.ParamLocationQuery, *params.MetaCreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.after", runtime.ParamLocationQuery, *params.MetaCreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.before", runtime.ParamLocationQuery, *params.MetaModifiedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.after", runtime.ParamLocationQuery, *params.MetaModifiedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sortkey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortkey", runtime.ParamLocationQuery, *params.Sortkey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostGroupsLookupRequest calls the generic PostGroupsLookup builder with application/json body
func NewPostGroupsLookupRequest(server string, params *PostGroupsLookupParams, body PostGroupsLookupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostGroupsLookupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostGroupsLookupRequestWithBody generates requests for PostGroupsLookup with any type of body
func NewPostGroupsLookupRequestWithBody(server string, params *PostGroupsLookupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGroupsIdRequest generates requests for GetGroupsId
func NewGetGroupsIdRequest(server string, id openapi_types.UUID, params *GetGroupsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLogRequest calls the generic PostLog builder with application/json body
func NewPostLogRequest(server string, body PostLogJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLogRequestWithBody(server, "application/json", bodyReader)
}

// NewPostLogRequestWithBody generates requests for PostLog with any type of body
func NewPostLogRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/log/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOrganisationsRequest generates requests for GetOrganisations
func NewGetOrganisationsRequest(server string, params *GetOrganisationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Parent != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent", runtime.ParamLocationQuery, *params.Parent); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SchoolUnitCode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schoolUnitCode", runtime.ParamLocationQuery, *params.SchoolUnitCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrganisationCode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organisationCode", runtime.ParamLocationQuery, *params.OrganisationCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MunicipalityCode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "municipalityCode", runtime.ParamLocationQuery, *params.MunicipalityCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SchoolTypes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schoolTypes", runtime.ParamLocationQuery, *params.SchoolTypes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartDateOnOrBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate.onOrBefore", runtime.ParamLocationQuery, *params.StartDateOnOrBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartDateOnOrAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate.onOrAfter", runtime.ParamLocationQuery, *params.StartDateOnOrAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndDateOnOrBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate.onOrBefore", runtime.ParamLocationQuery, *params.EndDateOnOrBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndDateOnOrAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate.onOrAfter", runtime.ParamLocationQuery, *params.EndDateOnOrAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.before", runtime.ParamLocationQuery, *params.MetaCreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.after", runtime.ParamLocationQuery, *params.MetaCreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.before", runtime.ParamLocationQuery, *params.MetaModifiedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.after", runtime.ParamLocationQuery, *params.MetaModifiedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sortkey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortkey", runtime.ParamLocationQuery, *params.Sortkey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrganisationsLookupRequest calls the generic PostOrganisationsLookup builder with application/json body
func NewPostOrganisationsLookupRequest(server string, params *PostOrganisationsLookupParams, body PostOrganisationsLookupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrganisationsLookupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostOrganisationsLookupRequestWithBody generates requests for PostOrganisationsLookup with any type of body
func NewPostOrganisationsLookupRequestWithBody(server string, params *PostOrganisationsLookupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisations/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOrganisationsIdRequest generates requests for GetOrganisationsId
func NewGetOrganisationsIdRequest(server string, id openapi_types.UUID, params *GetOrganisationsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonsRequest generates requests for GetPersons
func NewGetPersonsRequest(server string, params *GetPersonsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.NameContains != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameContains", runtime.ParamLocationQuery, *params.NameContains); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CivicNo != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "civicNo", runtime.ParamLocationQuery, *params.CivicNo); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EduPersonPrincipalName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eduPersonPrincipalName", runtime.ParamLocationQuery, *params.EduPersonPrincipalName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IdentifierValue != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "identifier.value", runtime.ParamLocationQuery, *params.IdentifierValue); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IdentifierContext != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "identifier.context", runtime.ParamLocationQuery, *params.IdentifierContext); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RelationshipEntityType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "relationship.entity.type", runtime.ParamLocationQuery, *params.RelationshipEntityType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RelationshipOrganisation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "relationship.organisation", runtime.ParamLocationQuery, *params.RelationshipOrganisation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RelationshipStartDateOnOrBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "relationship.startDate.onOrBefore", runtime.ParamLocationQuery, *params.RelationshipStartDateOnOrBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RelationshipStartDateOnOrAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "relationship.startDate.onOrAfter", runtime.ParamLocationQuery, *params.RelationshipStartDateOnOrAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RelationshipEndDateOnOrBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "relationship.endDate.onOrBefore", runtime.ParamLocationQuery, *params.RelationshipEndDateOnOrBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RelationshipEndDateOnOrAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "relationship.endDate.onOrAfter", runtime.ParamLocationQuery, *params.RelationshipEndDateOnOrAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.before", runtime.ParamLocationQuery, *params.MetaCreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.after", runtime.ParamLocationQuery, *params.MetaCreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.before", runtime.ParamLocationQuery, *params.MetaModifiedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.after", runtime.ParamLocationQuery, *params.MetaModifiedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sortkey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortkey", runtime.ParamLocationQuery, *params.Sortkey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPersonsLookupRequest calls the generic PostPersonsLookup builder with application/json body
func NewPostPersonsLookupRequest(server string, params *PostPersonsLookupParams, body PostPersonsLookupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPersonsLookupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostPersonsLookupRequestWithBody generates requests for PostPersonsLookup with any type of body
func NewPostPersonsLookupRequestWithBody(server string, params *PostPersonsLookupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPersonsIdRequest generates requests for GetPersonsId
func NewGetPersonsIdRequest(server string, id openapi_types.UUID, params *GetPersonsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlacementsRequest generates requests for GetPlacements
func NewGetPlacementsRequest(server string, params *GetPlacementsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/placements")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Organisation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organisation", runtime.ParamLocationQuery, *params.Organisation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Group != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartDateOnOrBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate.onOrBefore", runtime.ParamLocationQuery, *params.StartDateOnOrBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartDateOnOrAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate.onOrAfter", runtime.ParamLocationQuery, *params.StartDateOnOrAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndDateOnOrBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate.onOrBefore", runtime.ParamLocationQuery, *params.EndDateOnOrBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndDateOnOrAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate.onOrAfter", runtime.ParamLocationQuery, *params.EndDateOnOrAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Child != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "child", runtime.ParamLocationQuery, *params.Child); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Owner != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "owner", runtime.ParamLocationQuery, *params.Owner); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.before", runtime.ParamLocationQuery, *params.MetaCreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.after", runtime.ParamLocationQuery, *params.MetaCreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.before", runtime.ParamLocationQuery, *params.MetaModifiedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.after", runtime.ParamLocationQuery, *params.MetaModifiedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sortkey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortkey", runtime.ParamLocationQuery, *params.Sortkey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPlacementsLookupRequest calls the generic PostPlacementsLookup builder with application/json body
func NewPostPlacementsLookupRequest(server string, params *PostPlacementsLookupParams, body PostPlacementsLookupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPlacementsLookupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostPlacementsLookupRequestWithBody generates requests for PostPlacementsLookup with any type of body
func NewPostPlacementsLookupRequestWithBody(server string, params *PostPlacementsLookupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/placements/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlacementsIdRequest generates requests for GetPlacementsId
func NewGetPlacementsIdRequest(server string, id openapi_types.UUID, params *GetPlacementsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/placements/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProgrammesRequest generates requests for GetProgrammes
func NewGetProgrammesRequest(server string, params *GetProgrammesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/programmes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.SchoolType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schoolType", runtime.ParamLocationQuery, *params.SchoolType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Code != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ParentProgramme != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentProgramme", runtime.ParamLocationQuery, *params.ParentProgramme); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.before", runtime.ParamLocationQuery, *params.MetaCreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.after", runtime.ParamLocationQuery, *params.MetaCreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.before", runtime.ParamLocationQuery, *params.MetaModifiedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.after", runtime.ParamLocationQuery, *params.MetaModifiedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sortkey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortkey", runtime.ParamLocationQuery, *params.Sortkey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProgrammesLookupRequest calls the generic PostProgrammesLookup builder with application/json body
func NewPostProgrammesLookupRequest(server string, params *PostProgrammesLookupParams, body PostProgrammesLookupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProgrammesLookupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostProgrammesLookupRequestWithBody generates requests for PostProgrammesLookup with any type of body
func NewPostProgrammesLookupRequestWithBody(server string, params *PostProgrammesLookupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/programmes/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProgrammesIdRequest generates requests for GetProgrammesId
func NewGetProgrammesIdRequest(server string, id openapi_types.UUID, params *GetProgrammesIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/programmes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourcesRequest generates requests for GetResources
func NewGetResourcesRequest(server string, params *GetResourcesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Organisation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organisation", runtime.ParamLocationQuery, *params.Organisation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.before", runtime.ParamLocationQuery, *params.MetaCreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.after", runtime.ParamLocationQuery, *params.MetaCreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.before", runtime.ParamLocationQuery, *params.MetaModifiedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.after", runtime.ParamLocationQuery, *params.MetaModifiedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sortkey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortkey", runtime.ParamLocationQuery, *params.Sortkey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostResourcesLookupRequest calls the generic PostResourcesLookup builder with application/json body
func NewPostResourcesLookupRequest(server string, params *PostResourcesLookupParams, body PostResourcesLookupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostResourcesLookupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostResourcesLookupRequestWithBody generates requests for PostResourcesLookup with any type of body
func NewPostResourcesLookupRequestWithBody(server string, params *PostResourcesLookupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetResourcesIdRequest generates requests for GetResourcesId
func NewGetResourcesIdRequest(server string, id openapi_types.UUID, params *GetResourcesIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoomsRequest generates requests for GetRooms
func NewGetRoomsRequest(server string, params *GetRoomsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rooms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Organisation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organisation", runtime.ParamLocationQuery, *params.Organisation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.before", runtime.ParamLocationQuery, *params.MetaCreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.after", runtime.ParamLocationQuery, *params.MetaCreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.before", runtime.ParamLocationQuery, *params.MetaModifiedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.after", runtime.ParamLocationQuery, *params.MetaModifiedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sortkey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortkey", runtime.ParamLocationQuery, *params.Sortkey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRoomsLookupRequest calls the generic PostRoomsLookup builder with application/json body
func NewPostRoomsLookupRequest(server string, params *PostRoomsLookupParams, body PostRoomsLookupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRoomsLookupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostRoomsLookupRequestWithBody generates requests for PostRoomsLookup with any type of body
func NewPostRoomsLookupRequestWithBody(server string, params *PostRoomsLookupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rooms/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRoomsIdRequest generates requests for GetRoomsId
func NewGetRoomsIdRequest(server string, id openapi_types.UUID, params *GetRoomsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rooms/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchoolUnitOfferingsRequest generates requests for GetSchoolUnitOfferings
func NewGetSchoolUnitOfferingsRequest(server string, params *GetSchoolUnitOfferingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schoolUnitOfferings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Organisation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organisation", runtime.ParamLocationQuery, *params.Organisation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.before", runtime.ParamLocationQuery, *params.MetaCreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.after", runtime.ParamLocationQuery, *params.MetaCreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.before", runtime.ParamLocationQuery, *params.MetaModifiedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.after", runtime.ParamLocationQuery, *params.MetaModifiedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sortkey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortkey", runtime.ParamLocationQuery, *params.Sortkey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSchoolUnitOfferingsLookupRequest calls the generic PostSchoolUnitOfferingsLookup builder with application/json body
func NewPostSchoolUnitOfferingsLookupRequest(server string, params *PostSchoolUnitOfferingsLookupParams, body PostSchoolUnitOfferingsLookupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSchoolUnitOfferingsLookupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostSchoolUnitOfferingsLookupRequestWithBody generates requests for PostSchoolUnitOfferingsLookup with any type of body
func NewPostSchoolUnitOfferingsLookupRequestWithBody(server string, params *PostSchoolUnitOfferingsLookupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schoolUnitOfferings/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSchoolUnitOfferingsIdRequest generates requests for GetSchoolUnitOfferingsId
func NewGetSchoolUnitOfferingsIdRequest(server string, id openapi_types.UUID, params *GetSchoolUnitOfferingsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schoolUnitOfferings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostStatisticsRequest calls the generic PostStatistics builder with application/json body
func NewPostStatisticsRequest(server string, body PostStatisticsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostStatisticsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostStatisticsRequestWithBody generates requests for PostStatistics with any type of body
func NewPostStatisticsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/statistics/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStudyplansRequest generates requests for GetStudyplans
func NewGetStudyplansRequest(server string, params *GetStudyplansParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/studyplans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Student != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "student", runtime.ParamLocationQuery, *params.Student); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartDateOnOrBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate.onOrBefore", runtime.ParamLocationQuery, *params.StartDateOnOrBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartDateOnOrAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate.onOrAfter", runtime.ParamLocationQuery, *params.StartDateOnOrAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndDateOnOrBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate.onOrBefore", runtime.ParamLocationQuery, *params.EndDateOnOrBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndDateOnOrAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate.onOrAfter", runtime.ParamLocationQuery, *params.EndDateOnOrAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.before", runtime.ParamLocationQuery, *params.MetaCreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.after", runtime.ParamLocationQuery, *params.MetaCreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.before", runtime.ParamLocationQuery, *params.MetaModifiedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.after", runtime.ParamLocationQuery, *params.MetaModifiedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sortkey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortkey", runtime.ParamLocationQuery, *params.Sortkey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStudyplansIdRequest generates requests for GetStudyplansId
func NewGetStudyplansIdRequest(server string, id openapi_types.UUID, params *GetStudyplansIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/studyplans/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionsRequest generates requests for GetSubscriptions
func NewGetSubscriptionsRequest(server string, params *GetSubscriptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSubscriptionsRequest calls the generic PostSubscriptions builder with application/json body
func NewPostSubscriptionsRequest(server string, body PostSubscriptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSubscriptionsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSubscriptionsRequestWithBody generates requests for PostSubscriptions with any type of body
func NewPostSubscriptionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubscriptionsIdRequest generates requests for DeleteSubscriptionsId
func NewDeleteSubscriptionsIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionsIdRequest generates requests for GetSubscriptionsId
func NewGetSubscriptionsIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSubscriptionsIdRequest generates requests for PatchSubscriptionsId
func NewPatchSubscriptionsIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSyllabusesRequest generates requests for GetSyllabuses
func NewGetSyllabusesRequest(server string, params *GetSyllabusesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/syllabuses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.MetaCreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.before", runtime.ParamLocationQuery, *params.MetaCreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaCreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.created.after", runtime.ParamLocationQuery, *params.MetaCreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.before", runtime.ParamLocationQuery, *params.MetaModifiedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MetaModifiedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta.modified.after", runtime.ParamLocationQuery, *params.MetaModifiedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sortkey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortkey", runtime.ParamLocationQuery, *params.Sortkey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSyllabusesLookupRequest calls the generic PostSyllabusesLookup builder with application/json body
func NewPostSyllabusesLookupRequest(server string, params *PostSyllabusesLookupParams, body PostSyllabusesLookupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSyllabusesLookupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostSyllabusesLookupRequestWithBody generates requests for PostSyllabusesLookup with any type of body
func NewPostSyllabusesLookupRequestWithBody(server string, params *PostSyllabusesLookupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/syllabuses/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSyllabusesIdRequest generates requests for GetSyllabusesId
func NewGetSyllabusesIdRequest(server string, id openapi_types.UUID, params *GetSyllabusesIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/syllabuses/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExpandReferenceNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expandReferenceNames", runtime.ParamLocationQuery, *params.ExpandReferenceNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAbsences request
	GetAbsencesWithResponse(ctx context.Context, params *GetAbsencesParams, reqEditors ...RequestEditorFn) (*GetAbsencesResponse, error)

	// PostAbsences request with any body
	PostAbsencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAbsencesResponse, error)

	PostAbsencesWithResponse(ctx context.Context, body PostAbsencesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAbsencesResponse, error)

	// PostAbsencesLookup request with any body
	PostAbsencesLookupWithBodyWithResponse(ctx context.Context, params *PostAbsencesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAbsencesLookupResponse, error)

	PostAbsencesLookupWithResponse(ctx context.Context, params *PostAbsencesLookupParams, body PostAbsencesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAbsencesLookupResponse, error)

	// GetAbsencesId request
	GetAbsencesIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAbsencesIdResponse, error)

	// GetActivities request
	GetActivitiesWithResponse(ctx context.Context, params *GetActivitiesParams, reqEditors ...RequestEditorFn) (*GetActivitiesResponse, error)

	// PostActivitiesLookup request with any body
	PostActivitiesLookupWithBodyWithResponse(ctx context.Context, params *PostActivitiesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostActivitiesLookupResponse, error)

	PostActivitiesLookupWithResponse(ctx context.Context, params *PostActivitiesLookupParams, body PostActivitiesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostActivitiesLookupResponse, error)

	// GetActivitiesId request
	GetActivitiesIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetActivitiesIdParams, reqEditors ...RequestEditorFn) (*GetActivitiesIdResponse, error)

	// GetAggregatedAttendance request
	GetAggregatedAttendanceWithResponse(ctx context.Context, params *GetAggregatedAttendanceParams, reqEditors ...RequestEditorFn) (*GetAggregatedAttendanceResponse, error)

	// GetAttendanceEvents request
	GetAttendanceEventsWithResponse(ctx context.Context, params *GetAttendanceEventsParams, reqEditors ...RequestEditorFn) (*GetAttendanceEventsResponse, error)

	// PostAttendanceEvents request with any body
	PostAttendanceEventsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAttendanceEventsResponse, error)

	PostAttendanceEventsWithResponse(ctx context.Context, body PostAttendanceEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAttendanceEventsResponse, error)

	// PostAttendanceEventsLookup request with any body
	PostAttendanceEventsLookupWithBodyWithResponse(ctx context.Context, params *PostAttendanceEventsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAttendanceEventsLookupResponse, error)

	PostAttendanceEventsLookupWithResponse(ctx context.Context, params *PostAttendanceEventsLookupParams, body PostAttendanceEventsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAttendanceEventsLookupResponse, error)

	// DeleteAttendanceEventsId request
	DeleteAttendanceEventsIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteAttendanceEventsIdResponse, error)

	// GetAttendanceEventsId request
	GetAttendanceEventsIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetAttendanceEventsIdParams, reqEditors ...RequestEditorFn) (*GetAttendanceEventsIdResponse, error)

	// GetAttendanceSchedule request
	GetAttendanceScheduleWithResponse(ctx context.Context, params *GetAttendanceScheduleParams, reqEditors ...RequestEditorFn) (*GetAttendanceScheduleResponse, error)

	// PostAttendanceSchedule request with any body
	PostAttendanceScheduleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAttendanceScheduleResponse, error)

	PostAttendanceScheduleWithResponse(ctx context.Context, body PostAttendanceScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAttendanceScheduleResponse, error)

	// PostAttendanceScheduleLookup request with any body
	PostAttendanceScheduleLookupWithBodyWithResponse(ctx context.Context, params *PostAttendanceScheduleLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAttendanceScheduleLookupResponse, error)

	PostAttendanceScheduleLookupWithResponse(ctx context.Context, params *PostAttendanceScheduleLookupParams, body PostAttendanceScheduleLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAttendanceScheduleLookupResponse, error)

	// DeleteAttendanceScheduleId request
	DeleteAttendanceScheduleIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteAttendanceScheduleIdResponse, error)

	// GetAttendanceScheduleId request
	GetAttendanceScheduleIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetAttendanceScheduleIdParams, reqEditors ...RequestEditorFn) (*GetAttendanceScheduleIdResponse, error)

	// GetAttendances request
	GetAttendancesWithResponse(ctx context.Context, params *GetAttendancesParams, reqEditors ...RequestEditorFn) (*GetAttendancesResponse, error)

	// PostAttendances request with any body
	PostAttendancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAttendancesResponse, error)

	PostAttendancesWithResponse(ctx context.Context, body PostAttendancesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAttendancesResponse, error)

	// PostAttendancesLookup request with any body
	PostAttendancesLookupWithBodyWithResponse(ctx context.Context, params *PostAttendancesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAttendancesLookupResponse, error)

	PostAttendancesLookupWithResponse(ctx context.Context, params *PostAttendancesLookupParams, body PostAttendancesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAttendancesLookupResponse, error)

	// DeleteAttendancesId request
	DeleteAttendancesIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteAttendancesIdResponse, error)

	// GetAttendancesId request
	GetAttendancesIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAttendancesIdResponse, error)

	// GetCalendarEvents request
	GetCalendarEventsWithResponse(ctx context.Context, params *GetCalendarEventsParams, reqEditors ...RequestEditorFn) (*GetCalendarEventsResponse, error)

	// PostCalendarEventsLookup request with any body
	PostCalendarEventsLookupWithBodyWithResponse(ctx context.Context, params *PostCalendarEventsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCalendarEventsLookupResponse, error)

	PostCalendarEventsLookupWithResponse(ctx context.Context, params *PostCalendarEventsLookupParams, body PostCalendarEventsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCalendarEventsLookupResponse, error)

	// GetCalendarEventsId request
	GetCalendarEventsIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetCalendarEventsIdParams, reqEditors ...RequestEditorFn) (*GetCalendarEventsIdResponse, error)

	// GetDeletedEntities request
	GetDeletedEntitiesWithResponse(ctx context.Context, params *GetDeletedEntitiesParams, reqEditors ...RequestEditorFn) (*GetDeletedEntitiesResponse, error)

	// GetDuties request
	GetDutiesWithResponse(ctx context.Context, params *GetDutiesParams, reqEditors ...RequestEditorFn) (*GetDutiesResponse, error)

	// PostDutiesLookup request with any body
	PostDutiesLookupWithBodyWithResponse(ctx context.Context, params *PostDutiesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDutiesLookupResponse, error)

	PostDutiesLookupWithResponse(ctx context.Context, params *PostDutiesLookupParams, body PostDutiesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDutiesLookupResponse, error)

	// GetDutiesId request
	GetDutiesIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetDutiesIdParams, reqEditors ...RequestEditorFn) (*GetDutiesIdResponse, error)

	// GetGrades request
	GetGradesWithResponse(ctx context.Context, params *GetGradesParams, reqEditors ...RequestEditorFn) (*GetGradesResponse, error)

	// PostGradesLookup request with any body
	PostGradesLookupWithBodyWithResponse(ctx context.Context, params *PostGradesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGradesLookupResponse, error)

	PostGradesLookupWithResponse(ctx context.Context, params *PostGradesLookupParams, body PostGradesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGradesLookupResponse, error)

	// GetGradesId request
	GetGradesIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetGradesIdParams, reqEditors ...RequestEditorFn) (*GetGradesIdResponse, error)

	// GetGroups request
	GetGroupsWithResponse(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*GetGroupsResponse, error)

	// PostGroupsLookup request with any body
	PostGroupsLookupWithBodyWithResponse(ctx context.Context, params *PostGroupsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGroupsLookupResponse, error)

	PostGroupsLookupWithResponse(ctx context.Context, params *PostGroupsLookupParams, body PostGroupsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGroupsLookupResponse, error)

	// GetGroupsId request
	GetGroupsIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetGroupsIdParams, reqEditors ...RequestEditorFn) (*GetGroupsIdResponse, error)

	// PostLog request with any body
	PostLogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLogResponse, error)

	PostLogWithResponse(ctx context.Context, body PostLogJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLogResponse, error)

	// GetOrganisations request
	GetOrganisationsWithResponse(ctx context.Context, params *GetOrganisationsParams, reqEditors ...RequestEditorFn) (*GetOrganisationsResponse, error)

	// PostOrganisationsLookup request with any body
	PostOrganisationsLookupWithBodyWithResponse(ctx context.Context, params *PostOrganisationsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrganisationsLookupResponse, error)

	PostOrganisationsLookupWithResponse(ctx context.Context, params *PostOrganisationsLookupParams, body PostOrganisationsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrganisationsLookupResponse, error)

	// GetOrganisationsId request
	GetOrganisationsIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetOrganisationsIdParams, reqEditors ...RequestEditorFn) (*GetOrganisationsIdResponse, error)

	// GetPersons request
	GetPersonsWithResponse(ctx context.Context, params *GetPersonsParams, reqEditors ...RequestEditorFn) (*GetPersonsResponse, error)

	// PostPersonsLookup request with any body
	PostPersonsLookupWithBodyWithResponse(ctx context.Context, params *PostPersonsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPersonsLookupResponse, error)

	PostPersonsLookupWithResponse(ctx context.Context, params *PostPersonsLookupParams, body PostPersonsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPersonsLookupResponse, error)

	// GetPersonsId request
	GetPersonsIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetPersonsIdParams, reqEditors ...RequestEditorFn) (*GetPersonsIdResponse, error)

	// GetPlacements request
	GetPlacementsWithResponse(ctx context.Context, params *GetPlacementsParams, reqEditors ...RequestEditorFn) (*GetPlacementsResponse, error)

	// PostPlacementsLookup request with any body
	PostPlacementsLookupWithBodyWithResponse(ctx context.Context, params *PostPlacementsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPlacementsLookupResponse, error)

	PostPlacementsLookupWithResponse(ctx context.Context, params *PostPlacementsLookupParams, body PostPlacementsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPlacementsLookupResponse, error)

	// GetPlacementsId request
	GetPlacementsIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetPlacementsIdParams, reqEditors ...RequestEditorFn) (*GetPlacementsIdResponse, error)

	// GetProgrammes request
	GetProgrammesWithResponse(ctx context.Context, params *GetProgrammesParams, reqEditors ...RequestEditorFn) (*GetProgrammesResponse, error)

	// PostProgrammesLookup request with any body
	PostProgrammesLookupWithBodyWithResponse(ctx context.Context, params *PostProgrammesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProgrammesLookupResponse, error)

	PostProgrammesLookupWithResponse(ctx context.Context, params *PostProgrammesLookupParams, body PostProgrammesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProgrammesLookupResponse, error)

	// GetProgrammesId request
	GetProgrammesIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetProgrammesIdParams, reqEditors ...RequestEditorFn) (*GetProgrammesIdResponse, error)

	// GetResources request
	GetResourcesWithResponse(ctx context.Context, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*GetResourcesResponse, error)

	// PostResourcesLookup request with any body
	PostResourcesLookupWithBodyWithResponse(ctx context.Context, params *PostResourcesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostResourcesLookupResponse, error)

	PostResourcesLookupWithResponse(ctx context.Context, params *PostResourcesLookupParams, body PostResourcesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostResourcesLookupResponse, error)

	// GetResourcesId request
	GetResourcesIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetResourcesIdParams, reqEditors ...RequestEditorFn) (*GetResourcesIdResponse, error)

	// GetRooms request
	GetRoomsWithResponse(ctx context.Context, params *GetRoomsParams, reqEditors ...RequestEditorFn) (*GetRoomsResponse, error)

	// PostRoomsLookup request with any body
	PostRoomsLookupWithBodyWithResponse(ctx context.Context, params *PostRoomsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRoomsLookupResponse, error)

	PostRoomsLookupWithResponse(ctx context.Context, params *PostRoomsLookupParams, body PostRoomsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRoomsLookupResponse, error)

	// GetRoomsId request
	GetRoomsIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetRoomsIdParams, reqEditors ...RequestEditorFn) (*GetRoomsIdResponse, error)

	// GetSchoolUnitOfferings request
	GetSchoolUnitOfferingsWithResponse(ctx context.Context, params *GetSchoolUnitOfferingsParams, reqEditors ...RequestEditorFn) (*GetSchoolUnitOfferingsResponse, error)

	// PostSchoolUnitOfferingsLookup request with any body
	PostSchoolUnitOfferingsLookupWithBodyWithResponse(ctx context.Context, params *PostSchoolUnitOfferingsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSchoolUnitOfferingsLookupResponse, error)

	PostSchoolUnitOfferingsLookupWithResponse(ctx context.Context, params *PostSchoolUnitOfferingsLookupParams, body PostSchoolUnitOfferingsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSchoolUnitOfferingsLookupResponse, error)

	// GetSchoolUnitOfferingsId request
	GetSchoolUnitOfferingsIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetSchoolUnitOfferingsIdParams, reqEditors ...RequestEditorFn) (*GetSchoolUnitOfferingsIdResponse, error)

	// PostStatistics request with any body
	PostStatisticsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStatisticsResponse, error)

	PostStatisticsWithResponse(ctx context.Context, body PostStatisticsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStatisticsResponse, error)

	// GetStudyplans request
	GetStudyplansWithResponse(ctx context.Context, params *GetStudyplansParams, reqEditors ...RequestEditorFn) (*GetStudyplansResponse, error)

	// GetStudyplansId request
	GetStudyplansIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetStudyplansIdParams, reqEditors ...RequestEditorFn) (*GetStudyplansIdResponse, error)

	// GetSubscriptions request
	GetSubscriptionsWithResponse(ctx context.Context, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetSubscriptionsResponse, error)

	// PostSubscriptions request with any body
	PostSubscriptionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSubscriptionsResponse, error)

	PostSubscriptionsWithResponse(ctx context.Context, body PostSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSubscriptionsResponse, error)

	// DeleteSubscriptionsId request
	DeleteSubscriptionsIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteSubscriptionsIdResponse, error)

	// GetSubscriptionsId request
	GetSubscriptionsIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSubscriptionsIdResponse, error)

	// PatchSubscriptionsId request
	PatchSubscriptionsIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*PatchSubscriptionsIdResponse, error)

	// GetSyllabuses request
	GetSyllabusesWithResponse(ctx context.Context, params *GetSyllabusesParams, reqEditors ...RequestEditorFn) (*GetSyllabusesResponse, error)

	// PostSyllabusesLookup request with any body
	PostSyllabusesLookupWithBodyWithResponse(ctx context.Context, params *PostSyllabusesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSyllabusesLookupResponse, error)

	PostSyllabusesLookupWithResponse(ctx context.Context, params *PostSyllabusesLookupParams, body PostSyllabusesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSyllabusesLookupResponse, error)

	// GetSyllabusesId request
	GetSyllabusesIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetSyllabusesIdParams, reqEditors ...RequestEditorFn) (*GetSyllabusesIdResponse, error)
}

type GetAbsencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Absences
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAbsencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAbsencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAbsencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Absence
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostAbsencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAbsencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAbsencesLookupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AbsencesArray
	JSON403      *Error
	JSON503      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostAbsencesLookupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAbsencesLookupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAbsencesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Absence
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAbsencesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAbsencesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Activities
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostActivitiesLookupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActivitiesArray
	JSON403      *Error
	JSON503      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostActivitiesLookupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostActivitiesLookupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivitiesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActivityExpanded
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetActivitiesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivitiesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAggregatedAttendanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AggregatedAttendances
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAggregatedAttendanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAggregatedAttendanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttendanceEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AttendanceEvents
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAttendanceEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttendanceEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAttendanceEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AttendanceEvent
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostAttendanceEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAttendanceEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAttendanceEventsLookupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AttendanceEvent
	JSON403      *Error
	JSON503      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostAttendanceEventsLookupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAttendanceEventsLookupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAttendanceEventsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteAttendanceEventsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAttendanceEventsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttendanceEventsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AttendanceEvent
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAttendanceEventsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttendanceEventsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttendanceScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AttendanceSchedules
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAttendanceScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttendanceScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAttendanceScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AttendanceSchedule
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostAttendanceScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAttendanceScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAttendanceScheduleLookupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActivitiesArray
	JSON403      *Error
	JSON503      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostAttendanceScheduleLookupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAttendanceScheduleLookupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAttendanceScheduleIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteAttendanceScheduleIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAttendanceScheduleIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttendanceScheduleIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AttendanceSchedule
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAttendanceScheduleIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttendanceScheduleIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttendancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Attendances
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAttendancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttendancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAttendancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Attendance
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostAttendancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAttendancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAttendancesLookupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AttendancesArray
	JSON503      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostAttendancesLookupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAttendancesLookupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAttendancesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteAttendancesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAttendancesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttendancesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Attendance
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAttendancesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttendancesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCalendarEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CalendarEvents
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetCalendarEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCalendarEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCalendarEventsLookupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AttendancesArray
	JSON503      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostCalendarEventsLookupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCalendarEventsLookupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCalendarEventsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CalendarEvent
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetCalendarEventsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCalendarEventsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeletedEntitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeletedEntities
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetDeletedEntitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeletedEntitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDutiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Duties
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetDutiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDutiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDutiesLookupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DutiesArray
	JSON403      *Error
	JSON503      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostDutiesLookupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDutiesLookupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDutiesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DutyExpanded
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetDutiesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDutiesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGradesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Grades
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetGradesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGradesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGradesLookupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GradesArray
	JSON403      *Error
	JSON503      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostGradesLookupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGradesLookupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGradesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Grade
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetGradesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGradesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupsExpanded
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGroupsLookupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupsExpandedArray
	JSON403      *Error
	JSON503      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostGroupsLookupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGroupsLookupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupExpanded
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetGroupsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganisationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Organisations
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetOrganisationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganisationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrganisationsLookupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrganisationsArray
	JSON403      *Error
	JSON503      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostOrganisationsLookupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrganisationsLookupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganisationsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Organisation
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetOrganisationsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganisationsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersonsExpanded
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetPersonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPersonsLookupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersonsExpandedArray
	JSON403      *Error
	JSON503      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostPersonsLookupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPersonsLookupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersonExpanded
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetPersonsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlacementsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Placements
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetPlacementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlacementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPlacementsLookupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlacementsArray
	JSON403      *Error
	JSON503      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostPlacementsLookupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPlacementsLookupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlacementsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlacementExpanded
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetPlacementsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlacementsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgrammesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Programmes
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetProgrammesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgrammesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProgrammesLookupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProgrammesArray
	JSON403      *Error
	JSON503      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostProgrammesLookupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProgrammesLookupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgrammesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Programme
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetProgrammesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgrammesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Resources
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetResourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostResourcesLookupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResourcesArray
	JSON403      *Error
	JSON503      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostResourcesLookupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostResourcesLookupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourcesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Resource
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetResourcesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourcesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoomsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Rooms
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRoomsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoomsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRoomsLookupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoomsArray
	JSON403      *Error
	JSON503      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostRoomsLookupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRoomsLookupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoomsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Room
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRoomsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoomsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchoolUnitOfferingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchoolUnitOfferings
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSchoolUnitOfferingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchoolUnitOfferingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSchoolUnitOfferingsLookupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchoolUnitOfferingsArray
	JSON403      *Error
	JSON503      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostSchoolUnitOfferingsLookupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSchoolUnitOfferingsLookupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchoolUnitOfferingsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchoolUnitOffering
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSchoolUnitOfferingsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchoolUnitOfferingsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStudyplansResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StudyPlans
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStudyplansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStudyplansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStudyplansIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StudyPlan
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStudyplansIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStudyplansIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Subscriptions
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Subscription
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubscriptionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSubscriptionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubscriptionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Subscription
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSubscriptionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Subscription
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchSubscriptionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSubscriptionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyllabusesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Syllabuses
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSyllabusesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyllabusesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSyllabusesLookupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyllabusesArray
	JSON403      *Error
	JSON503      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostSyllabusesLookupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSyllabusesLookupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyllabusesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Syllabus
	JSON400      *Error
	JSON403      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSyllabusesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyllabusesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAbsencesWithResponse request returning *GetAbsencesResponse
func (c *ClientWithResponses) GetAbsencesWithResponse(ctx context.Context, params *GetAbsencesParams, reqEditors ...RequestEditorFn) (*GetAbsencesResponse, error) {
	rsp, err := c.GetAbsences(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAbsencesResponse(rsp)
}

// PostAbsencesWithBodyWithResponse request with arbitrary body returning *PostAbsencesResponse
func (c *ClientWithResponses) PostAbsencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAbsencesResponse, error) {
	rsp, err := c.PostAbsencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAbsencesResponse(rsp)
}

func (c *ClientWithResponses) PostAbsencesWithResponse(ctx context.Context, body PostAbsencesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAbsencesResponse, error) {
	rsp, err := c.PostAbsences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAbsencesResponse(rsp)
}

// PostAbsencesLookupWithBodyWithResponse request with arbitrary body returning *PostAbsencesLookupResponse
func (c *ClientWithResponses) PostAbsencesLookupWithBodyWithResponse(ctx context.Context, params *PostAbsencesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAbsencesLookupResponse, error) {
	rsp, err := c.PostAbsencesLookupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAbsencesLookupResponse(rsp)
}

func (c *ClientWithResponses) PostAbsencesLookupWithResponse(ctx context.Context, params *PostAbsencesLookupParams, body PostAbsencesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAbsencesLookupResponse, error) {
	rsp, err := c.PostAbsencesLookup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAbsencesLookupResponse(rsp)
}

// GetAbsencesIdWithResponse request returning *GetAbsencesIdResponse
func (c *ClientWithResponses) GetAbsencesIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAbsencesIdResponse, error) {
	rsp, err := c.GetAbsencesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAbsencesIdResponse(rsp)
}

// GetActivitiesWithResponse request returning *GetActivitiesResponse
func (c *ClientWithResponses) GetActivitiesWithResponse(ctx context.Context, params *GetActivitiesParams, reqEditors ...RequestEditorFn) (*GetActivitiesResponse, error) {
	rsp, err := c.GetActivities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivitiesResponse(rsp)
}

// PostActivitiesLookupWithBodyWithResponse request with arbitrary body returning *PostActivitiesLookupResponse
func (c *ClientWithResponses) PostActivitiesLookupWithBodyWithResponse(ctx context.Context, params *PostActivitiesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostActivitiesLookupResponse, error) {
	rsp, err := c.PostActivitiesLookupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostActivitiesLookupResponse(rsp)
}

func (c *ClientWithResponses) PostActivitiesLookupWithResponse(ctx context.Context, params *PostActivitiesLookupParams, body PostActivitiesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostActivitiesLookupResponse, error) {
	rsp, err := c.PostActivitiesLookup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostActivitiesLookupResponse(rsp)
}

// GetActivitiesIdWithResponse request returning *GetActivitiesIdResponse
func (c *ClientWithResponses) GetActivitiesIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetActivitiesIdParams, reqEditors ...RequestEditorFn) (*GetActivitiesIdResponse, error) {
	rsp, err := c.GetActivitiesId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivitiesIdResponse(rsp)
}

// GetAggregatedAttendanceWithResponse request returning *GetAggregatedAttendanceResponse
func (c *ClientWithResponses) GetAggregatedAttendanceWithResponse(ctx context.Context, params *GetAggregatedAttendanceParams, reqEditors ...RequestEditorFn) (*GetAggregatedAttendanceResponse, error) {
	rsp, err := c.GetAggregatedAttendance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAggregatedAttendanceResponse(rsp)
}

// GetAttendanceEventsWithResponse request returning *GetAttendanceEventsResponse
func (c *ClientWithResponses) GetAttendanceEventsWithResponse(ctx context.Context, params *GetAttendanceEventsParams, reqEditors ...RequestEditorFn) (*GetAttendanceEventsResponse, error) {
	rsp, err := c.GetAttendanceEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttendanceEventsResponse(rsp)
}

// PostAttendanceEventsWithBodyWithResponse request with arbitrary body returning *PostAttendanceEventsResponse
func (c *ClientWithResponses) PostAttendanceEventsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAttendanceEventsResponse, error) {
	rsp, err := c.PostAttendanceEventsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAttendanceEventsResponse(rsp)
}

func (c *ClientWithResponses) PostAttendanceEventsWithResponse(ctx context.Context, body PostAttendanceEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAttendanceEventsResponse, error) {
	rsp, err := c.PostAttendanceEvents(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAttendanceEventsResponse(rsp)
}

// PostAttendanceEventsLookupWithBodyWithResponse request with arbitrary body returning *PostAttendanceEventsLookupResponse
func (c *ClientWithResponses) PostAttendanceEventsLookupWithBodyWithResponse(ctx context.Context, params *PostAttendanceEventsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAttendanceEventsLookupResponse, error) {
	rsp, err := c.PostAttendanceEventsLookupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAttendanceEventsLookupResponse(rsp)
}

func (c *ClientWithResponses) PostAttendanceEventsLookupWithResponse(ctx context.Context, params *PostAttendanceEventsLookupParams, body PostAttendanceEventsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAttendanceEventsLookupResponse, error) {
	rsp, err := c.PostAttendanceEventsLookup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAttendanceEventsLookupResponse(rsp)
}

// DeleteAttendanceEventsIdWithResponse request returning *DeleteAttendanceEventsIdResponse
func (c *ClientWithResponses) DeleteAttendanceEventsIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteAttendanceEventsIdResponse, error) {
	rsp, err := c.DeleteAttendanceEventsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAttendanceEventsIdResponse(rsp)
}

// GetAttendanceEventsIdWithResponse request returning *GetAttendanceEventsIdResponse
func (c *ClientWithResponses) GetAttendanceEventsIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetAttendanceEventsIdParams, reqEditors ...RequestEditorFn) (*GetAttendanceEventsIdResponse, error) {
	rsp, err := c.GetAttendanceEventsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttendanceEventsIdResponse(rsp)
}

// GetAttendanceScheduleWithResponse request returning *GetAttendanceScheduleResponse
func (c *ClientWithResponses) GetAttendanceScheduleWithResponse(ctx context.Context, params *GetAttendanceScheduleParams, reqEditors ...RequestEditorFn) (*GetAttendanceScheduleResponse, error) {
	rsp, err := c.GetAttendanceSchedule(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttendanceScheduleResponse(rsp)
}

// PostAttendanceScheduleWithBodyWithResponse request with arbitrary body returning *PostAttendanceScheduleResponse
func (c *ClientWithResponses) PostAttendanceScheduleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAttendanceScheduleResponse, error) {
	rsp, err := c.PostAttendanceScheduleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAttendanceScheduleResponse(rsp)
}

func (c *ClientWithResponses) PostAttendanceScheduleWithResponse(ctx context.Context, body PostAttendanceScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAttendanceScheduleResponse, error) {
	rsp, err := c.PostAttendanceSchedule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAttendanceScheduleResponse(rsp)
}

// PostAttendanceScheduleLookupWithBodyWithResponse request with arbitrary body returning *PostAttendanceScheduleLookupResponse
func (c *ClientWithResponses) PostAttendanceScheduleLookupWithBodyWithResponse(ctx context.Context, params *PostAttendanceScheduleLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAttendanceScheduleLookupResponse, error) {
	rsp, err := c.PostAttendanceScheduleLookupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAttendanceScheduleLookupResponse(rsp)
}

func (c *ClientWithResponses) PostAttendanceScheduleLookupWithResponse(ctx context.Context, params *PostAttendanceScheduleLookupParams, body PostAttendanceScheduleLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAttendanceScheduleLookupResponse, error) {
	rsp, err := c.PostAttendanceScheduleLookup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAttendanceScheduleLookupResponse(rsp)
}

// DeleteAttendanceScheduleIdWithResponse request returning *DeleteAttendanceScheduleIdResponse
func (c *ClientWithResponses) DeleteAttendanceScheduleIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteAttendanceScheduleIdResponse, error) {
	rsp, err := c.DeleteAttendanceScheduleId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAttendanceScheduleIdResponse(rsp)
}

// GetAttendanceScheduleIdWithResponse request returning *GetAttendanceScheduleIdResponse
func (c *ClientWithResponses) GetAttendanceScheduleIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetAttendanceScheduleIdParams, reqEditors ...RequestEditorFn) (*GetAttendanceScheduleIdResponse, error) {
	rsp, err := c.GetAttendanceScheduleId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttendanceScheduleIdResponse(rsp)
}

// GetAttendancesWithResponse request returning *GetAttendancesResponse
func (c *ClientWithResponses) GetAttendancesWithResponse(ctx context.Context, params *GetAttendancesParams, reqEditors ...RequestEditorFn) (*GetAttendancesResponse, error) {
	rsp, err := c.GetAttendances(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttendancesResponse(rsp)
}

// PostAttendancesWithBodyWithResponse request with arbitrary body returning *PostAttendancesResponse
func (c *ClientWithResponses) PostAttendancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAttendancesResponse, error) {
	rsp, err := c.PostAttendancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAttendancesResponse(rsp)
}

func (c *ClientWithResponses) PostAttendancesWithResponse(ctx context.Context, body PostAttendancesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAttendancesResponse, error) {
	rsp, err := c.PostAttendances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAttendancesResponse(rsp)
}

// PostAttendancesLookupWithBodyWithResponse request with arbitrary body returning *PostAttendancesLookupResponse
func (c *ClientWithResponses) PostAttendancesLookupWithBodyWithResponse(ctx context.Context, params *PostAttendancesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAttendancesLookupResponse, error) {
	rsp, err := c.PostAttendancesLookupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAttendancesLookupResponse(rsp)
}

func (c *ClientWithResponses) PostAttendancesLookupWithResponse(ctx context.Context, params *PostAttendancesLookupParams, body PostAttendancesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAttendancesLookupResponse, error) {
	rsp, err := c.PostAttendancesLookup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAttendancesLookupResponse(rsp)
}

// DeleteAttendancesIdWithResponse request returning *DeleteAttendancesIdResponse
func (c *ClientWithResponses) DeleteAttendancesIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteAttendancesIdResponse, error) {
	rsp, err := c.DeleteAttendancesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAttendancesIdResponse(rsp)
}

// GetAttendancesIdWithResponse request returning *GetAttendancesIdResponse
func (c *ClientWithResponses) GetAttendancesIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAttendancesIdResponse, error) {
	rsp, err := c.GetAttendancesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttendancesIdResponse(rsp)
}

// GetCalendarEventsWithResponse request returning *GetCalendarEventsResponse
func (c *ClientWithResponses) GetCalendarEventsWithResponse(ctx context.Context, params *GetCalendarEventsParams, reqEditors ...RequestEditorFn) (*GetCalendarEventsResponse, error) {
	rsp, err := c.GetCalendarEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCalendarEventsResponse(rsp)
}

// PostCalendarEventsLookupWithBodyWithResponse request with arbitrary body returning *PostCalendarEventsLookupResponse
func (c *ClientWithResponses) PostCalendarEventsLookupWithBodyWithResponse(ctx context.Context, params *PostCalendarEventsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCalendarEventsLookupResponse, error) {
	rsp, err := c.PostCalendarEventsLookupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCalendarEventsLookupResponse(rsp)
}

func (c *ClientWithResponses) PostCalendarEventsLookupWithResponse(ctx context.Context, params *PostCalendarEventsLookupParams, body PostCalendarEventsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCalendarEventsLookupResponse, error) {
	rsp, err := c.PostCalendarEventsLookup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCalendarEventsLookupResponse(rsp)
}

// GetCalendarEventsIdWithResponse request returning *GetCalendarEventsIdResponse
func (c *ClientWithResponses) GetCalendarEventsIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetCalendarEventsIdParams, reqEditors ...RequestEditorFn) (*GetCalendarEventsIdResponse, error) {
	rsp, err := c.GetCalendarEventsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCalendarEventsIdResponse(rsp)
}

// GetDeletedEntitiesWithResponse request returning *GetDeletedEntitiesResponse
func (c *ClientWithResponses) GetDeletedEntitiesWithResponse(ctx context.Context, params *GetDeletedEntitiesParams, reqEditors ...RequestEditorFn) (*GetDeletedEntitiesResponse, error) {
	rsp, err := c.GetDeletedEntities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeletedEntitiesResponse(rsp)
}

// GetDutiesWithResponse request returning *GetDutiesResponse
func (c *ClientWithResponses) GetDutiesWithResponse(ctx context.Context, params *GetDutiesParams, reqEditors ...RequestEditorFn) (*GetDutiesResponse, error) {
	rsp, err := c.GetDuties(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDutiesResponse(rsp)
}

// PostDutiesLookupWithBodyWithResponse request with arbitrary body returning *PostDutiesLookupResponse
func (c *ClientWithResponses) PostDutiesLookupWithBodyWithResponse(ctx context.Context, params *PostDutiesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDutiesLookupResponse, error) {
	rsp, err := c.PostDutiesLookupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDutiesLookupResponse(rsp)
}

func (c *ClientWithResponses) PostDutiesLookupWithResponse(ctx context.Context, params *PostDutiesLookupParams, body PostDutiesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDutiesLookupResponse, error) {
	rsp, err := c.PostDutiesLookup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDutiesLookupResponse(rsp)
}

// GetDutiesIdWithResponse request returning *GetDutiesIdResponse
func (c *ClientWithResponses) GetDutiesIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetDutiesIdParams, reqEditors ...RequestEditorFn) (*GetDutiesIdResponse, error) {
	rsp, err := c.GetDutiesId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDutiesIdResponse(rsp)
}

// GetGradesWithResponse request returning *GetGradesResponse
func (c *ClientWithResponses) GetGradesWithResponse(ctx context.Context, params *GetGradesParams, reqEditors ...RequestEditorFn) (*GetGradesResponse, error) {
	rsp, err := c.GetGrades(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGradesResponse(rsp)
}

// PostGradesLookupWithBodyWithResponse request with arbitrary body returning *PostGradesLookupResponse
func (c *ClientWithResponses) PostGradesLookupWithBodyWithResponse(ctx context.Context, params *PostGradesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGradesLookupResponse, error) {
	rsp, err := c.PostGradesLookupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGradesLookupResponse(rsp)
}

func (c *ClientWithResponses) PostGradesLookupWithResponse(ctx context.Context, params *PostGradesLookupParams, body PostGradesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGradesLookupResponse, error) {
	rsp, err := c.PostGradesLookup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGradesLookupResponse(rsp)
}

// GetGradesIdWithResponse request returning *GetGradesIdResponse
func (c *ClientWithResponses) GetGradesIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetGradesIdParams, reqEditors ...RequestEditorFn) (*GetGradesIdResponse, error) {
	rsp, err := c.GetGradesId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGradesIdResponse(rsp)
}

// GetGroupsWithResponse request returning *GetGroupsResponse
func (c *ClientWithResponses) GetGroupsWithResponse(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*GetGroupsResponse, error) {
	rsp, err := c.GetGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsResponse(rsp)
}

// PostGroupsLookupWithBodyWithResponse request with arbitrary body returning *PostGroupsLookupResponse
func (c *ClientWithResponses) PostGroupsLookupWithBodyWithResponse(ctx context.Context, params *PostGroupsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGroupsLookupResponse, error) {
	rsp, err := c.PostGroupsLookupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGroupsLookupResponse(rsp)
}

func (c *ClientWithResponses) PostGroupsLookupWithResponse(ctx context.Context, params *PostGroupsLookupParams, body PostGroupsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGroupsLookupResponse, error) {
	rsp, err := c.PostGroupsLookup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGroupsLookupResponse(rsp)
}

// GetGroupsIdWithResponse request returning *GetGroupsIdResponse
func (c *ClientWithResponses) GetGroupsIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetGroupsIdParams, reqEditors ...RequestEditorFn) (*GetGroupsIdResponse, error) {
	rsp, err := c.GetGroupsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsIdResponse(rsp)
}

// PostLogWithBodyWithResponse request with arbitrary body returning *PostLogResponse
func (c *ClientWithResponses) PostLogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLogResponse, error) {
	rsp, err := c.PostLogWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLogResponse(rsp)
}

func (c *ClientWithResponses) PostLogWithResponse(ctx context.Context, body PostLogJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLogResponse, error) {
	rsp, err := c.PostLog(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLogResponse(rsp)
}

// GetOrganisationsWithResponse request returning *GetOrganisationsResponse
func (c *ClientWithResponses) GetOrganisationsWithResponse(ctx context.Context, params *GetOrganisationsParams, reqEditors ...RequestEditorFn) (*GetOrganisationsResponse, error) {
	rsp, err := c.GetOrganisations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganisationsResponse(rsp)
}

// PostOrganisationsLookupWithBodyWithResponse request with arbitrary body returning *PostOrganisationsLookupResponse
func (c *ClientWithResponses) PostOrganisationsLookupWithBodyWithResponse(ctx context.Context, params *PostOrganisationsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrganisationsLookupResponse, error) {
	rsp, err := c.PostOrganisationsLookupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrganisationsLookupResponse(rsp)
}

func (c *ClientWithResponses) PostOrganisationsLookupWithResponse(ctx context.Context, params *PostOrganisationsLookupParams, body PostOrganisationsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrganisationsLookupResponse, error) {
	rsp, err := c.PostOrganisationsLookup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrganisationsLookupResponse(rsp)
}

// GetOrganisationsIdWithResponse request returning *GetOrganisationsIdResponse
func (c *ClientWithResponses) GetOrganisationsIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetOrganisationsIdParams, reqEditors ...RequestEditorFn) (*GetOrganisationsIdResponse, error) {
	rsp, err := c.GetOrganisationsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganisationsIdResponse(rsp)
}

// GetPersonsWithResponse request returning *GetPersonsResponse
func (c *ClientWithResponses) GetPersonsWithResponse(ctx context.Context, params *GetPersonsParams, reqEditors ...RequestEditorFn) (*GetPersonsResponse, error) {
	rsp, err := c.GetPersons(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonsResponse(rsp)
}

// PostPersonsLookupWithBodyWithResponse request with arbitrary body returning *PostPersonsLookupResponse
func (c *ClientWithResponses) PostPersonsLookupWithBodyWithResponse(ctx context.Context, params *PostPersonsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPersonsLookupResponse, error) {
	rsp, err := c.PostPersonsLookupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPersonsLookupResponse(rsp)
}

func (c *ClientWithResponses) PostPersonsLookupWithResponse(ctx context.Context, params *PostPersonsLookupParams, body PostPersonsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPersonsLookupResponse, error) {
	rsp, err := c.PostPersonsLookup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPersonsLookupResponse(rsp)
}

// GetPersonsIdWithResponse request returning *GetPersonsIdResponse
func (c *ClientWithResponses) GetPersonsIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetPersonsIdParams, reqEditors ...RequestEditorFn) (*GetPersonsIdResponse, error) {
	rsp, err := c.GetPersonsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonsIdResponse(rsp)
}

// GetPlacementsWithResponse request returning *GetPlacementsResponse
func (c *ClientWithResponses) GetPlacementsWithResponse(ctx context.Context, params *GetPlacementsParams, reqEditors ...RequestEditorFn) (*GetPlacementsResponse, error) {
	rsp, err := c.GetPlacements(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlacementsResponse(rsp)
}

// PostPlacementsLookupWithBodyWithResponse request with arbitrary body returning *PostPlacementsLookupResponse
func (c *ClientWithResponses) PostPlacementsLookupWithBodyWithResponse(ctx context.Context, params *PostPlacementsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPlacementsLookupResponse, error) {
	rsp, err := c.PostPlacementsLookupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPlacementsLookupResponse(rsp)
}

func (c *ClientWithResponses) PostPlacementsLookupWithResponse(ctx context.Context, params *PostPlacementsLookupParams, body PostPlacementsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPlacementsLookupResponse, error) {
	rsp, err := c.PostPlacementsLookup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPlacementsLookupResponse(rsp)
}

// GetPlacementsIdWithResponse request returning *GetPlacementsIdResponse
func (c *ClientWithResponses) GetPlacementsIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetPlacementsIdParams, reqEditors ...RequestEditorFn) (*GetPlacementsIdResponse, error) {
	rsp, err := c.GetPlacementsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlacementsIdResponse(rsp)
}

// GetProgrammesWithResponse request returning *GetProgrammesResponse
func (c *ClientWithResponses) GetProgrammesWithResponse(ctx context.Context, params *GetProgrammesParams, reqEditors ...RequestEditorFn) (*GetProgrammesResponse, error) {
	rsp, err := c.GetProgrammes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgrammesResponse(rsp)
}

// PostProgrammesLookupWithBodyWithResponse request with arbitrary body returning *PostProgrammesLookupResponse
func (c *ClientWithResponses) PostProgrammesLookupWithBodyWithResponse(ctx context.Context, params *PostProgrammesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProgrammesLookupResponse, error) {
	rsp, err := c.PostProgrammesLookupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProgrammesLookupResponse(rsp)
}

func (c *ClientWithResponses) PostProgrammesLookupWithResponse(ctx context.Context, params *PostProgrammesLookupParams, body PostProgrammesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProgrammesLookupResponse, error) {
	rsp, err := c.PostProgrammesLookup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProgrammesLookupResponse(rsp)
}

// GetProgrammesIdWithResponse request returning *GetProgrammesIdResponse
func (c *ClientWithResponses) GetProgrammesIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetProgrammesIdParams, reqEditors ...RequestEditorFn) (*GetProgrammesIdResponse, error) {
	rsp, err := c.GetProgrammesId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgrammesIdResponse(rsp)
}

// GetResourcesWithResponse request returning *GetResourcesResponse
func (c *ClientWithResponses) GetResourcesWithResponse(ctx context.Context, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*GetResourcesResponse, error) {
	rsp, err := c.GetResources(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourcesResponse(rsp)
}

// PostResourcesLookupWithBodyWithResponse request with arbitrary body returning *PostResourcesLookupResponse
func (c *ClientWithResponses) PostResourcesLookupWithBodyWithResponse(ctx context.Context, params *PostResourcesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostResourcesLookupResponse, error) {
	rsp, err := c.PostResourcesLookupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostResourcesLookupResponse(rsp)
}

func (c *ClientWithResponses) PostResourcesLookupWithResponse(ctx context.Context, params *PostResourcesLookupParams, body PostResourcesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostResourcesLookupResponse, error) {
	rsp, err := c.PostResourcesLookup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostResourcesLookupResponse(rsp)
}

// GetResourcesIdWithResponse request returning *GetResourcesIdResponse
func (c *ClientWithResponses) GetResourcesIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetResourcesIdParams, reqEditors ...RequestEditorFn) (*GetResourcesIdResponse, error) {
	rsp, err := c.GetResourcesId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourcesIdResponse(rsp)
}

// GetRoomsWithResponse request returning *GetRoomsResponse
func (c *ClientWithResponses) GetRoomsWithResponse(ctx context.Context, params *GetRoomsParams, reqEditors ...RequestEditorFn) (*GetRoomsResponse, error) {
	rsp, err := c.GetRooms(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoomsResponse(rsp)
}

// PostRoomsLookupWithBodyWithResponse request with arbitrary body returning *PostRoomsLookupResponse
func (c *ClientWithResponses) PostRoomsLookupWithBodyWithResponse(ctx context.Context, params *PostRoomsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRoomsLookupResponse, error) {
	rsp, err := c.PostRoomsLookupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRoomsLookupResponse(rsp)
}

func (c *ClientWithResponses) PostRoomsLookupWithResponse(ctx context.Context, params *PostRoomsLookupParams, body PostRoomsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRoomsLookupResponse, error) {
	rsp, err := c.PostRoomsLookup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRoomsLookupResponse(rsp)
}

// GetRoomsIdWithResponse request returning *GetRoomsIdResponse
func (c *ClientWithResponses) GetRoomsIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetRoomsIdParams, reqEditors ...RequestEditorFn) (*GetRoomsIdResponse, error) {
	rsp, err := c.GetRoomsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoomsIdResponse(rsp)
}

// GetSchoolUnitOfferingsWithResponse request returning *GetSchoolUnitOfferingsResponse
func (c *ClientWithResponses) GetSchoolUnitOfferingsWithResponse(ctx context.Context, params *GetSchoolUnitOfferingsParams, reqEditors ...RequestEditorFn) (*GetSchoolUnitOfferingsResponse, error) {
	rsp, err := c.GetSchoolUnitOfferings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchoolUnitOfferingsResponse(rsp)
}

// PostSchoolUnitOfferingsLookupWithBodyWithResponse request with arbitrary body returning *PostSchoolUnitOfferingsLookupResponse
func (c *ClientWithResponses) PostSchoolUnitOfferingsLookupWithBodyWithResponse(ctx context.Context, params *PostSchoolUnitOfferingsLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSchoolUnitOfferingsLookupResponse, error) {
	rsp, err := c.PostSchoolUnitOfferingsLookupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSchoolUnitOfferingsLookupResponse(rsp)
}

func (c *ClientWithResponses) PostSchoolUnitOfferingsLookupWithResponse(ctx context.Context, params *PostSchoolUnitOfferingsLookupParams, body PostSchoolUnitOfferingsLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSchoolUnitOfferingsLookupResponse, error) {
	rsp, err := c.PostSchoolUnitOfferingsLookup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSchoolUnitOfferingsLookupResponse(rsp)
}

// GetSchoolUnitOfferingsIdWithResponse request returning *GetSchoolUnitOfferingsIdResponse
func (c *ClientWithResponses) GetSchoolUnitOfferingsIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetSchoolUnitOfferingsIdParams, reqEditors ...RequestEditorFn) (*GetSchoolUnitOfferingsIdResponse, error) {
	rsp, err := c.GetSchoolUnitOfferingsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchoolUnitOfferingsIdResponse(rsp)
}

// PostStatisticsWithBodyWithResponse request with arbitrary body returning *PostStatisticsResponse
func (c *ClientWithResponses) PostStatisticsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStatisticsResponse, error) {
	rsp, err := c.PostStatisticsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStatisticsResponse(rsp)
}

func (c *ClientWithResponses) PostStatisticsWithResponse(ctx context.Context, body PostStatisticsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStatisticsResponse, error) {
	rsp, err := c.PostStatistics(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStatisticsResponse(rsp)
}

// GetStudyplansWithResponse request returning *GetStudyplansResponse
func (c *ClientWithResponses) GetStudyplansWithResponse(ctx context.Context, params *GetStudyplansParams, reqEditors ...RequestEditorFn) (*GetStudyplansResponse, error) {
	rsp, err := c.GetStudyplans(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStudyplansResponse(rsp)
}

// GetStudyplansIdWithResponse request returning *GetStudyplansIdResponse
func (c *ClientWithResponses) GetStudyplansIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetStudyplansIdParams, reqEditors ...RequestEditorFn) (*GetStudyplansIdResponse, error) {
	rsp, err := c.GetStudyplansId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStudyplansIdResponse(rsp)
}

// GetSubscriptionsWithResponse request returning *GetSubscriptionsResponse
func (c *ClientWithResponses) GetSubscriptionsWithResponse(ctx context.Context, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetSubscriptionsResponse, error) {
	rsp, err := c.GetSubscriptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionsResponse(rsp)
}

// PostSubscriptionsWithBodyWithResponse request with arbitrary body returning *PostSubscriptionsResponse
func (c *ClientWithResponses) PostSubscriptionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSubscriptionsResponse, error) {
	rsp, err := c.PostSubscriptionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSubscriptionsResponse(rsp)
}

func (c *ClientWithResponses) PostSubscriptionsWithResponse(ctx context.Context, body PostSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSubscriptionsResponse, error) {
	rsp, err := c.PostSubscriptions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSubscriptionsResponse(rsp)
}

// DeleteSubscriptionsIdWithResponse request returning *DeleteSubscriptionsIdResponse
func (c *ClientWithResponses) DeleteSubscriptionsIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteSubscriptionsIdResponse, error) {
	rsp, err := c.DeleteSubscriptionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubscriptionsIdResponse(rsp)
}

// GetSubscriptionsIdWithResponse request returning *GetSubscriptionsIdResponse
func (c *ClientWithResponses) GetSubscriptionsIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSubscriptionsIdResponse, error) {
	rsp, err := c.GetSubscriptionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionsIdResponse(rsp)
}

// PatchSubscriptionsIdWithResponse request returning *PatchSubscriptionsIdResponse
func (c *ClientWithResponses) PatchSubscriptionsIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*PatchSubscriptionsIdResponse, error) {
	rsp, err := c.PatchSubscriptionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSubscriptionsIdResponse(rsp)
}

// GetSyllabusesWithResponse request returning *GetSyllabusesResponse
func (c *ClientWithResponses) GetSyllabusesWithResponse(ctx context.Context, params *GetSyllabusesParams, reqEditors ...RequestEditorFn) (*GetSyllabusesResponse, error) {
	rsp, err := c.GetSyllabuses(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyllabusesResponse(rsp)
}

// PostSyllabusesLookupWithBodyWithResponse request with arbitrary body returning *PostSyllabusesLookupResponse
func (c *ClientWithResponses) PostSyllabusesLookupWithBodyWithResponse(ctx context.Context, params *PostSyllabusesLookupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSyllabusesLookupResponse, error) {
	rsp, err := c.PostSyllabusesLookupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSyllabusesLookupResponse(rsp)
}

func (c *ClientWithResponses) PostSyllabusesLookupWithResponse(ctx context.Context, params *PostSyllabusesLookupParams, body PostSyllabusesLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSyllabusesLookupResponse, error) {
	rsp, err := c.PostSyllabusesLookup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSyllabusesLookupResponse(rsp)
}

// GetSyllabusesIdWithResponse request returning *GetSyllabusesIdResponse
func (c *ClientWithResponses) GetSyllabusesIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetSyllabusesIdParams, reqEditors ...RequestEditorFn) (*GetSyllabusesIdResponse, error) {
	rsp, err := c.GetSyllabusesId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyllabusesIdResponse(rsp)
}

// ParseGetAbsencesResponse parses an HTTP response from a GetAbsencesWithResponse call
func ParseGetAbsencesResponse(rsp *http.Response) (*GetAbsencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAbsencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Absences
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostAbsencesResponse parses an HTTP response from a PostAbsencesWithResponse call
func ParsePostAbsencesResponse(rsp *http.Response) (*PostAbsencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAbsencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Absence
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostAbsencesLookupResponse parses an HTTP response from a PostAbsencesLookupWithResponse call
func ParsePostAbsencesLookupResponse(rsp *http.Response) (*PostAbsencesLookupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAbsencesLookupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AbsencesArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAbsencesIdResponse parses an HTTP response from a GetAbsencesIdWithResponse call
func ParseGetAbsencesIdResponse(rsp *http.Response) (*GetAbsencesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAbsencesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Absence
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetActivitiesResponse parses an HTTP response from a GetActivitiesWithResponse call
func ParseGetActivitiesResponse(rsp *http.Response) (*GetActivitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Activities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostActivitiesLookupResponse parses an HTTP response from a PostActivitiesLookupWithResponse call
func ParsePostActivitiesLookupResponse(rsp *http.Response) (*PostActivitiesLookupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostActivitiesLookupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActivitiesArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetActivitiesIdResponse parses an HTTP response from a GetActivitiesIdWithResponse call
func ParseGetActivitiesIdResponse(rsp *http.Response) (*GetActivitiesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivitiesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActivityExpanded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAggregatedAttendanceResponse parses an HTTP response from a GetAggregatedAttendanceWithResponse call
func ParseGetAggregatedAttendanceResponse(rsp *http.Response) (*GetAggregatedAttendanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAggregatedAttendanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AggregatedAttendances
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAttendanceEventsResponse parses an HTTP response from a GetAttendanceEventsWithResponse call
func ParseGetAttendanceEventsResponse(rsp *http.Response) (*GetAttendanceEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttendanceEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttendanceEvents
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostAttendanceEventsResponse parses an HTTP response from a PostAttendanceEventsWithResponse call
func ParsePostAttendanceEventsResponse(rsp *http.Response) (*PostAttendanceEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAttendanceEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttendanceEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostAttendanceEventsLookupResponse parses an HTTP response from a PostAttendanceEventsLookupWithResponse call
func ParsePostAttendanceEventsLookupResponse(rsp *http.Response) (*PostAttendanceEventsLookupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAttendanceEventsLookupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AttendanceEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAttendanceEventsIdResponse parses an HTTP response from a DeleteAttendanceEventsIdWithResponse call
func ParseDeleteAttendanceEventsIdResponse(rsp *http.Response) (*DeleteAttendanceEventsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAttendanceEventsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAttendanceEventsIdResponse parses an HTTP response from a GetAttendanceEventsIdWithResponse call
func ParseGetAttendanceEventsIdResponse(rsp *http.Response) (*GetAttendanceEventsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttendanceEventsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttendanceEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAttendanceScheduleResponse parses an HTTP response from a GetAttendanceScheduleWithResponse call
func ParseGetAttendanceScheduleResponse(rsp *http.Response) (*GetAttendanceScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttendanceScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttendanceSchedules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostAttendanceScheduleResponse parses an HTTP response from a PostAttendanceScheduleWithResponse call
func ParsePostAttendanceScheduleResponse(rsp *http.Response) (*PostAttendanceScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAttendanceScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttendanceSchedule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostAttendanceScheduleLookupResponse parses an HTTP response from a PostAttendanceScheduleLookupWithResponse call
func ParsePostAttendanceScheduleLookupResponse(rsp *http.Response) (*PostAttendanceScheduleLookupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAttendanceScheduleLookupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActivitiesArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAttendanceScheduleIdResponse parses an HTTP response from a DeleteAttendanceScheduleIdWithResponse call
func ParseDeleteAttendanceScheduleIdResponse(rsp *http.Response) (*DeleteAttendanceScheduleIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAttendanceScheduleIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAttendanceScheduleIdResponse parses an HTTP response from a GetAttendanceScheduleIdWithResponse call
func ParseGetAttendanceScheduleIdResponse(rsp *http.Response) (*GetAttendanceScheduleIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttendanceScheduleIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttendanceSchedule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAttendancesResponse parses an HTTP response from a GetAttendancesWithResponse call
func ParseGetAttendancesResponse(rsp *http.Response) (*GetAttendancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttendancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Attendances
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostAttendancesResponse parses an HTTP response from a PostAttendancesWithResponse call
func ParsePostAttendancesResponse(rsp *http.Response) (*PostAttendancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAttendancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Attendance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostAttendancesLookupResponse parses an HTTP response from a PostAttendancesLookupWithResponse call
func ParsePostAttendancesLookupResponse(rsp *http.Response) (*PostAttendancesLookupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAttendancesLookupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttendancesArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAttendancesIdResponse parses an HTTP response from a DeleteAttendancesIdWithResponse call
func ParseDeleteAttendancesIdResponse(rsp *http.Response) (*DeleteAttendancesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAttendancesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAttendancesIdResponse parses an HTTP response from a GetAttendancesIdWithResponse call
func ParseGetAttendancesIdResponse(rsp *http.Response) (*GetAttendancesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttendancesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Attendance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCalendarEventsResponse parses an HTTP response from a GetCalendarEventsWithResponse call
func ParseGetCalendarEventsResponse(rsp *http.Response) (*GetCalendarEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCalendarEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CalendarEvents
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostCalendarEventsLookupResponse parses an HTTP response from a PostCalendarEventsLookupWithResponse call
func ParsePostCalendarEventsLookupResponse(rsp *http.Response) (*PostCalendarEventsLookupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCalendarEventsLookupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttendancesArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCalendarEventsIdResponse parses an HTTP response from a GetCalendarEventsIdWithResponse call
func ParseGetCalendarEventsIdResponse(rsp *http.Response) (*GetCalendarEventsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCalendarEventsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CalendarEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDeletedEntitiesResponse parses an HTTP response from a GetDeletedEntitiesWithResponse call
func ParseGetDeletedEntitiesResponse(rsp *http.Response) (*GetDeletedEntitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeletedEntitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeletedEntities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDutiesResponse parses an HTTP response from a GetDutiesWithResponse call
func ParseGetDutiesResponse(rsp *http.Response) (*GetDutiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDutiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Duties
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostDutiesLookupResponse parses an HTTP response from a PostDutiesLookupWithResponse call
func ParsePostDutiesLookupResponse(rsp *http.Response) (*PostDutiesLookupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDutiesLookupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DutiesArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDutiesIdResponse parses an HTTP response from a GetDutiesIdWithResponse call
func ParseGetDutiesIdResponse(rsp *http.Response) (*GetDutiesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDutiesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DutyExpanded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGradesResponse parses an HTTP response from a GetGradesWithResponse call
func ParseGetGradesResponse(rsp *http.Response) (*GetGradesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGradesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Grades
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostGradesLookupResponse parses an HTTP response from a PostGradesLookupWithResponse call
func ParsePostGradesLookupResponse(rsp *http.Response) (*PostGradesLookupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGradesLookupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GradesArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGradesIdResponse parses an HTTP response from a GetGradesIdWithResponse call
func ParseGetGradesIdResponse(rsp *http.Response) (*GetGradesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGradesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Grade
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGroupsResponse parses an HTTP response from a GetGroupsWithResponse call
func ParseGetGroupsResponse(rsp *http.Response) (*GetGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupsExpanded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostGroupsLookupResponse parses an HTTP response from a PostGroupsLookupWithResponse call
func ParsePostGroupsLookupResponse(rsp *http.Response) (*PostGroupsLookupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGroupsLookupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupsExpandedArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGroupsIdResponse parses an HTTP response from a GetGroupsIdWithResponse call
func ParseGetGroupsIdResponse(rsp *http.Response) (*GetGroupsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupExpanded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostLogResponse parses an HTTP response from a PostLogWithResponse call
func ParsePostLogResponse(rsp *http.Response) (*PostLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOrganisationsResponse parses an HTTP response from a GetOrganisationsWithResponse call
func ParseGetOrganisationsResponse(rsp *http.Response) (*GetOrganisationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganisationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Organisations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostOrganisationsLookupResponse parses an HTTP response from a PostOrganisationsLookupWithResponse call
func ParsePostOrganisationsLookupResponse(rsp *http.Response) (*PostOrganisationsLookupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrganisationsLookupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrganisationsArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOrganisationsIdResponse parses an HTTP response from a GetOrganisationsIdWithResponse call
func ParseGetOrganisationsIdResponse(rsp *http.Response) (*GetOrganisationsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganisationsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Organisation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPersonsResponse parses an HTTP response from a GetPersonsWithResponse call
func ParseGetPersonsResponse(rsp *http.Response) (*GetPersonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersonsExpanded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostPersonsLookupResponse parses an HTTP response from a PostPersonsLookupWithResponse call
func ParsePostPersonsLookupResponse(rsp *http.Response) (*PostPersonsLookupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPersonsLookupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersonsExpandedArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPersonsIdResponse parses an HTTP response from a GetPersonsIdWithResponse call
func ParseGetPersonsIdResponse(rsp *http.Response) (*GetPersonsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersonExpanded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPlacementsResponse parses an HTTP response from a GetPlacementsWithResponse call
func ParseGetPlacementsResponse(rsp *http.Response) (*GetPlacementsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlacementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Placements
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostPlacementsLookupResponse parses an HTTP response from a PostPlacementsLookupWithResponse call
func ParsePostPlacementsLookupResponse(rsp *http.Response) (*PostPlacementsLookupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPlacementsLookupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlacementsArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPlacementsIdResponse parses an HTTP response from a GetPlacementsIdWithResponse call
func ParseGetPlacementsIdResponse(rsp *http.Response) (*GetPlacementsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlacementsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlacementExpanded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProgrammesResponse parses an HTTP response from a GetProgrammesWithResponse call
func ParseGetProgrammesResponse(rsp *http.Response) (*GetProgrammesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgrammesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Programmes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostProgrammesLookupResponse parses an HTTP response from a PostProgrammesLookupWithResponse call
func ParsePostProgrammesLookupResponse(rsp *http.Response) (*PostProgrammesLookupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProgrammesLookupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProgrammesArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProgrammesIdResponse parses an HTTP response from a GetProgrammesIdWithResponse call
func ParseGetProgrammesIdResponse(rsp *http.Response) (*GetProgrammesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgrammesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Programme
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetResourcesResponse parses an HTTP response from a GetResourcesWithResponse call
func ParseGetResourcesResponse(rsp *http.Response) (*GetResourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resources
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostResourcesLookupResponse parses an HTTP response from a PostResourcesLookupWithResponse call
func ParsePostResourcesLookupResponse(rsp *http.Response) (*PostResourcesLookupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostResourcesLookupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourcesArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetResourcesIdResponse parses an HTTP response from a GetResourcesIdWithResponse call
func ParseGetResourcesIdResponse(rsp *http.Response) (*GetResourcesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourcesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRoomsResponse parses an HTTP response from a GetRoomsWithResponse call
func ParseGetRoomsResponse(rsp *http.Response) (*GetRoomsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoomsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Rooms
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostRoomsLookupResponse parses an HTTP response from a PostRoomsLookupWithResponse call
func ParsePostRoomsLookupResponse(rsp *http.Response) (*PostRoomsLookupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRoomsLookupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoomsArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRoomsIdResponse parses an HTTP response from a GetRoomsIdWithResponse call
func ParseGetRoomsIdResponse(rsp *http.Response) (*GetRoomsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoomsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Room
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSchoolUnitOfferingsResponse parses an HTTP response from a GetSchoolUnitOfferingsWithResponse call
func ParseGetSchoolUnitOfferingsResponse(rsp *http.Response) (*GetSchoolUnitOfferingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchoolUnitOfferingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchoolUnitOfferings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSchoolUnitOfferingsLookupResponse parses an HTTP response from a PostSchoolUnitOfferingsLookupWithResponse call
func ParsePostSchoolUnitOfferingsLookupResponse(rsp *http.Response) (*PostSchoolUnitOfferingsLookupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSchoolUnitOfferingsLookupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchoolUnitOfferingsArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSchoolUnitOfferingsIdResponse parses an HTTP response from a GetSchoolUnitOfferingsIdWithResponse call
func ParseGetSchoolUnitOfferingsIdResponse(rsp *http.Response) (*GetSchoolUnitOfferingsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchoolUnitOfferingsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchoolUnitOffering
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostStatisticsResponse parses an HTTP response from a PostStatisticsWithResponse call
func ParsePostStatisticsResponse(rsp *http.Response) (*PostStatisticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStudyplansResponse parses an HTTP response from a GetStudyplansWithResponse call
func ParseGetStudyplansResponse(rsp *http.Response) (*GetStudyplansResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStudyplansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StudyPlans
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStudyplansIdResponse parses an HTTP response from a GetStudyplansIdWithResponse call
func ParseGetStudyplansIdResponse(rsp *http.Response) (*GetStudyplansIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStudyplansIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StudyPlan
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSubscriptionsResponse parses an HTTP response from a GetSubscriptionsWithResponse call
func ParseGetSubscriptionsResponse(rsp *http.Response) (*GetSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Subscriptions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSubscriptionsResponse parses an HTTP response from a PostSubscriptionsWithResponse call
func ParsePostSubscriptionsResponse(rsp *http.Response) (*PostSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSubscriptionsIdResponse parses an HTTP response from a DeleteSubscriptionsIdWithResponse call
func ParseDeleteSubscriptionsIdResponse(rsp *http.Response) (*DeleteSubscriptionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubscriptionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSubscriptionsIdResponse parses an HTTP response from a GetSubscriptionsIdWithResponse call
func ParseGetSubscriptionsIdResponse(rsp *http.Response) (*GetSubscriptionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchSubscriptionsIdResponse parses an HTTP response from a PatchSubscriptionsIdWithResponse call
func ParsePatchSubscriptionsIdResponse(rsp *http.Response) (*PatchSubscriptionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSubscriptionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSyllabusesResponse parses an HTTP response from a GetSyllabusesWithResponse call
func ParseGetSyllabusesResponse(rsp *http.Response) (*GetSyllabusesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyllabusesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Syllabuses
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSyllabusesLookupResponse parses an HTTP response from a PostSyllabusesLookupWithResponse call
func ParsePostSyllabusesLookupResponse(rsp *http.Response) (*PostSyllabusesLookupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSyllabusesLookupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyllabusesArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSyllabusesIdResponse parses an HTTP response from a GetSyllabusesIdWithResponse call
func ParseGetSyllabusesIdResponse(rsp *http.Response) (*GetSyllabusesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyllabusesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Syllabus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
